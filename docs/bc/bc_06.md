# 部分 III. Hyperledger

## 第 24 章 Hyperledger Fabric v2.0.0

区块链技术发展至今，形成了公有链、联盟链和邦链三种种主流技术平台。

公有链：面向大众，用户可以匿名参与，非常方便，账本数据也公开，加上强大的智能合约，因此公有链极大地促进了区块链概念和技术的普及，比如比特币、Ethereum 平台等。

联盟链：考虑到商业应用对安全、隐私、监管、审计、性能的需求，提高准入门槛，增加了安全、隐私、可监管审计等商业特性，是区块链技术在商业领域的应用探索。

邦链：暂时资料比较少。

概念

通道（ Channel ）：通道是构建在 Hyperledger Fabric 区块链网络上的私有区块链，实现了数据的隔离和保密。通道中的 Chaincode 和交易只有加入该通道的节点（ Peer ）可见。同一个节点可以加入多个通道，并为每个通道内容维护一个账本。每一个通道即为一条逻辑上的区块链。可以按照业务来划分通道，也可以按照行政职能和隐私策略来划分通道。

节点（ Peer ）： 维护账本的网络节点，通常区块链网络架构中存在多种角色，如 endorser 和 committer 。

排序服务或共识服务（ Order Services ） ： 提供排序服务或共识服务的网络节点，完成交易的排序和区块打包等工作，支持可插拔的共识组件，当前生产环境下使用 Kafka 进行交易排序。

分布式账本（ Distribute Ledger ） ：由网络中若干去中心化节点共同维护的数据账本。

组织（ Org ） ：联盟链中按照访问和使用账本的网络节点，一个联盟（或者一个区块链网络）有多个组织（成员），一个组织内可以有多个节点（ Peer ），每个节点参与账本和世界状态维护。

智能合约（ Smart Contract ）：根据特定条件自动执行的合约程序。智能合约是区块链的重要特征，是用户与区块链进行交互，利用区块链实现业务逻辑的重要途径。

链码（ Chaincode ）：链码是 Hyperledger Fabric 对智能合约的一种实现方式，是运行于 Hyperledger Fabric 网络之上一段应用程序代码，也是用户与 Hyperledger Fabric 交互的唯一途径。

链（ Chain ）：一个链即是一个由若干区块通过特定指向链接、摘要算法或加密算法锚定组成的数据集合。

## 1. 安装 Hyperledger Fabric v1.1.x

### 1.1. 依赖工具

```

yum -y install epel-release
yum install -y git
yum install -y golang

```

### 1.2. 安装 Docker

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/docker.centos7.ce.sh	 | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/registry-mirror.sh	 | bash
or 
curl -fsSL https://get.docker.com/ | sh	

创建 2 个 docker 网络,如下：
docker network create fabric_noops
docker network create fabric_pbft

```

安装 docker-compose

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/docker-compose/docker-compose.sh	 | bash			

```

### 1.3. 安装 Node.js 环境

```

yum install -y nodejs
npm install

```

### 1.4. 安装 hyperledger 1.1.0

运行后 hyperledger 相关镜像被安装到 Docker 中

```

cd /usr/local/src
curl -s https://raw.githubusercontent.com/hyperledger/fabric/release/scripts/bootstrap-1.1.0.sh | bash			

```

由于上面脚本会安装所有节点，速度较慢，作者建议你参考下一章节，手工安装所需最低配置节点。

### 1.5. 手工安装 hyperledger v 1.1.0 开发环境

对于开发环境，最小化的环境，包括 1 个 peer 节点、1 个 Orderer 节点、1 个 CA 节点。

准备一个服务器或者虚拟机，安装 CentOS 操作系统。

如果你是在已有的 Docker 上安装，建议你删除所有容器后在安装。以免出现冲突等情况。

```

docker stop $(docker ps -q) && docker rm $(docker ps -aq)			

```

#### 1.5.1. 登录 docker

```

[root@localhost ~]# docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: netkiller
Password: 
Login Succeeded				

```

#### 1.5.2. Docker 安装

```

docker pull hyperledger/fabric-baseimage:latest \
  && docker pull hyperledger/fabric-membersrvc:latest \
  && docker pull hyperledger/fabric-peer:latest \
  && docker pull hyperledger/fabric-orderer:latest \
  && docker pull hyperledger/fabric-ca:latest \
  && docker pull hyperledger/blockchain-explorer:latest

```

安装会出现下面问题

```

[root@localhost ~]# docker search fabric-peer | grep hyperledger/fabric-peer
hyperledger/fabric-peer            Fabric Peer docker image for Hyperledger Pro…   69

[root@localhost ~]# docker pull hyperledger/fabric-peer:latest
Error response from daemon: manifest for hyperledger/fabric-peer:latest not found

```

可以 search 到的镜像 pull 不了，原因是 fabric-peer:latest，latest 不存在，你需要指定版本号。

```

docker pull hyperledger/fabric-ca:x86_64-1.1.0 \
&& docker pull hyperledger/fabric-peer:x86_64-1.1.0 \
&& docker pull hyperledger/fabric-orderer:x86_64-1.1.0 \
&& docker pull hyperledger/fabric-couchdb:x86_64-1.1.0 \
&& docker pull hyperledger/fabric-tools:x86_64-1.1.0

docker tag hyperledger/fabric-ca:x86_64-1.1.0 hyperledger/fabric-ca \
&& docker tag hyperledger/fabric-peer:x86_64-1.1.0 hyperledger/fabric-peer \
&& docker tag hyperledger/fabric-orderer:x86_64-1.1.0 hyperledger/fabric-orderer \
&& docker tag hyperledger/fabric-couchdb:x86_64-1.1.0 hyperledger/fabric-couchdb \
&& docker tag hyperledger/fabric-tools:x86_64-1.1.0 hyperledger/fabric-tools

```

查看镜像

```

[root@localhost src]# docker images
REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE
hyperledger/fabric-orderer      latest              368c78b6f03b        2 months ago        151MB
hyperledger/fabric-orderer      x86_64-1.1.0        368c78b6f03b        2 months ago        151MB
hyperledger/fabric-peer         latest              c2ab022f0bdb        2 months ago        154MB
hyperledger/fabric-peer         x86_64-1.1.0        c2ab022f0bdb        2 months ago        154MB
hyperledger/fabric-membersrvc   latest              b3654d32e4f9        15 months ago       1.42GB				

```

#### 1.5.3. 编译安装

```

git config --global core.autocrlf false				
$ git clone https://github.com/hyperledger/fabric.git 
$ make docker 
$ git clone https://github.com/hyperledger/fabric-ca.git		
$ make docker 

cd fabric/devenv
vagrant box add hyperledger/fabric-baseimage centos7.box
vagrant up

yum -y install epel-release
yum -y install git
yum -y install golang
yum -y install python-pip	
pip install --upgrade backports.ssl_match_hostname
pip install docker-compose

docker-compose -version

```

### 1.6. 启动 docker 虚拟机

体验 Hyperledger Fabric 在 https://github.com/hyperledger/fabric/tree/release/examples 下面有一些例子供用户学习。这里我选择的是 fabric-samples

这里我们最小化启动，需要四个节点，分别是 ca, peer, order, couchdb。

创建文件 docker-compose.yml

```

[root@localhost ~]# mkdir -p docker
[root@localhost ~]# cd docker
[root@localhost docker]# vim docker-compose.yml
#
# Copyright IBM Corp All Rights Reserved
#
# SPDX-License-Identifier: Apache-2.0
#
version: '2'

networks:
  basic:

services:
  ca.example.com:
    image: hyperledger/fabric-ca
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.example.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/4239aa0dcd76daeeb8ba0cda701851d14504d31aad1b2ddddbac6a57365e497c_sk
    ports:
      - "7054:7054"
    command: sh -c 'fabric-ca-server start -b admin:adminpw -d'
    volumes:
      - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-config
    container_name: ca.example.com
    networks:
      - basic

  orderer.example.com:
    container_name: orderer.example.com
    image: hyperledger/fabric-orderer
    environment:
      - ORDERER_GENERAL_LOGLEVEL=debug
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/configtx/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp/orderer/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/orderer
    command: orderer
    ports:
      - 7050:7050
    volumes:
        - ./config/:/etc/hyperledger/configtx
        - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/:/etc/hyperledger/msp/orderer
        - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peerOrg1
    networks:
      - basic

  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    image: hyperledger/fabric-peer
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.example.com
      - CORE_LOGGING_PEER=debug
      - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      # # the following setting starts chaincode containers on the same
      # # bridge network as the peers
      # # https://docs.docker.com/compose/networking/
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_basic
      - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
      - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984
      # The CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME and CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD
      # provide the credentials for ledger to connect to CouchDB.  The username and password must
      # match the username and password set for the associated CouchDB.
      - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=
      - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric
    command: peer node start
    # command: peer node start --peer-chaincodedev=true
    ports:
      - 7051:7051
      - 7053:7053
    volumes:
        - /var/run/:/host/var/run/
        - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/msp/peer
        - ./crypto-config/peerOrganizations/org1.example.com/users:/etc/hyperledger/msp/users
        - ./config:/etc/hyperledger/configtx
    depends_on:
      - orderer.example.com
      - couchdb
    networks:
      - basic

  couchdb:
    container_name: couchdb
    image: hyperledger/fabric-couchdb
    # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password
    # for CouchDB.  This will prevent CouchDB from operating in an "Admin Party" mode.
    environment:
      - COUCHDB_USER=
      - COUCHDB_PASSWORD=
    ports:
      - 5984:5984
    networks:
      - basic

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
      - CORE_CHAINCODE_KEEPALIVE=10
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: /bin/bash
    volumes:
        - /var/run/:/host/var/run/
        - ./../chaincode/:/opt/gopath/src/github.com/
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
    networks:
        - basic
    #depends_on:
    #  - orderer.example.com
    #  - peer0.org1.example.com
    #  - couchdb

```

启动 Docker

```

[root@localhost docker]# docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb			

```

查看进程

```

[root@localhost docker]# docker-compose ps 
         Name                       Command               State                       Ports                      
----------------------------------------------------------------------------------------------------------------
ca.example.com           sh -c fabric-ca-server sta ...   Up      0.0.0.0:7054->7054/tcp                         
cli                      /bin/bash                        Up                                                     
couchdb                  tini -- /docker-entrypoint ...   Up      4369/tcp, 0.0.0.0:5984->5984/tcp, 9100/tcp     
orderer.example.com      orderer                          Up      0.0.0.0:7050->7050/tcp                         
peer0.org1.example.com   peer node start                  Up      0.0.0.0:7051->7051/tcp, 0.0.0.0:7053->7053/tcp

```

### 1.7. 管理 hyperledger

#### 1.7.1. CouchDB 管理界面

```

[root@localhost fabcar]# curl http://localhost:5984
{"couchdb":"Welcome","version":"2.0.0","vendor":{"name":"The Apache Software Foundation"}}					

```

[`localhost:5984/_utils/`](http://localhost:5984/_utils/)

### 1.8. 部署 chaincode

#### 1.8.1. channel 管理

Hyperledger Fabric Channel 可以理解为 vlan （交换机术语） 用来实现区块隔离。

```

[root@localhost docker]# docker-compose exec peer0.org1.example.com bash
root@dcb09db1cbc8:/go/src/github.com/hyperledger/fabric#				

```

##### 1.8.1.1. 列出 channel

```

root@595ec455c0ff:/opt/gopath/src/github.com/hyperledger/fabric# peer channel list 
2018-02-07 03:24:41.151 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-07 03:24:41.152 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-07 03:24:41.154 UTC [channelCmd] InitCmdFactory -> INFO 003 Endorser and orderer connections initialized
2018-02-07 03:24:41.155 UTC [msp/identity] Sign -> DEBU 004 Sign: plaintext: 0A85070A5B08031A0B08F9E2E9D30510...631A0D0A0B4765744368616E6E656C73 
2018-02-07 03:24:41.156 UTC [msp/identity] Sign -> DEBU 005 Sign: digest: 238CBAB61A0524954DC3C511588EB8FC1F886E636A8800131EBE16FB95FB0C9A 
2018-02-07 03:24:41.167 UTC [channelCmd] list -> INFO 006 Channels peers has joined to: 
2018-02-07 03:24:41.167 UTC [channelCmd] list -> INFO 007 mychannel 
2018-02-07 03:24:41.167 UTC [main] main -> INFO 008 Exiting.....					

```

##### 1.8.1.2. 创建 Channel

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp
peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx					

```

##### 1.8.1.3. 加入 Channel

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp
peer channel join -b mychannel.block

```

#### 1.8.2. 部署连

```

[root@localhost basic-network]# docker-compose exec cli bash
root@b1ded848f967:/opt/gopath/src/github.com/hyperledger/fabric/peer#

```

安装合约

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
peer chaincode install -n fabcar -v 1.0 -p github.com/fabcar			

```

实例化合约

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n fabcar -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

```

初始化合约

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"initLedger","Args":[""]}'				

```

#### 1.8.3. 查询合约

```

root@b1ded848f967:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode query -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"queryCar","Args":["CAR9"]}'
2018-02-07 05:11:59.737 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-07 05:11:59.737 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-07 05:11:59.738 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-07 05:11:59.738 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-07 05:11:59.738 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0A93070A6908031A0C089F95EAD30510...0A0871756572794361720A0443415239 
2018-02-07 05:11:59.739 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: 84E6F021BEA8C5F2D97B1C8BFEA4BB07B91DBC167E0BBD188260B234DC4620E8 
Query Result: {"colour":"brown","make":"Holden","model":"Barina","owner":"Shotaro"}
2018-02-07 05:11:59.771 UTC [main] main -> INFO 007 Exiting.....

```

#### 1.8.4. 调用合约

调用合约，新增一条记录，然后做查询操作。

```

peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"createCar","Args":["CAR15", "Toyota", "Rezi", "White", "Neo"]}'				
peer chaincode query -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"queryCar","Args":["CAR15"]}'

```

演示结果

```

root@b1ded848f967:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"createCar","Args":["CAR15", "Toyota", "Rezi", "White", "Neo"]}'
2018-02-07 05:16:57.415 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-07 05:16:57.415 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-07 05:16:57.417 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-07 05:16:57.417 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-07 05:16:57.418 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0A93070A6908031A0C08C997EAD30510...52657A690A0557686974650A034E656F 
2018-02-07 05:16:57.418 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: D9BDF565353FFAD37CDC64DBFBD06DA8B5A049AA32305E1668A695E6522C3043 
2018-02-07 05:16:57.443 UTC [msp/identity] Sign -> DEBU 007 Sign: plaintext: 0A93070A6908031A0C08C997EAD30510...4B5F674D96D8DE9BE699613B72ED46B1 
2018-02-07 05:16:57.443 UTC [msp/identity] Sign -> DEBU 008 Sign: digest: 2951E3522A902D2644E08508E52A1D833AF9E11A420EE933851CC5673B005375 
2018-02-07 05:16:57.451 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> DEBU 009 ESCC invoke result: version:1 response:<status:200 message:"OK" > payload:"\n \327\324\006\316\004\230\3262{\300\\|\275\035\336\243\316L\232\247x\020n`2\346\334\031\n(<\262\022\204\001\nn\022T\n\006fabcar\022J\032H\n\005CAR15\032?{\"make\":\"Toyota\",\"model\":\"Rezi\",\"colour\":\"White\",\"owner\":\"Neo\"}\022\026\n\004lscc\022\016\n\014\n\006fabcar\022\002\010\001\032\003\010\310\001\"\r\022\006fabcar\032\0031.0" endorsement:<endorser:"\n\007Org1MSP\022\200\006-----BEGIN -----\nMIICGjCCAcCgAwIBAgIRAPlwF/rUZUP9mqN4wSml4iswCgYIKoZIzj0EAwIwczEL\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\ncmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh\nLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcwODMxMDkxNDMyWhcNMjcwODI5MDkxNDMy\nWjBbMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN\nU2FuIEZyYW5jaXNjbzEfMB0GA1UEAxMWcGVlcjAub3JnMS5leGFtcGxlLmNvbTBZ\nMBMGByqGSM49AgEGCCqGSM49AwEHA0IABHihxW6ks3B2+5XdbAVq3CBgxRRRZ22x\nzzpqnD86nKkz7fBElBuhlXl2K6rTxyY2OBOB0ts8keqZ93xueRGymrajTTBLMA4G\nA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKAIEI5qg3Ndtru\nuLoM2nAYUdFFBNMarRst3dusalc2Xkl8MAoGCCqGSM49BAMCA0gAMEUCIQD4j0Rn\ne1rrd0FSCzsR6u+IuuPK5dI/kR/bh7+VLf0TNgIgCfUtkJvfvzVEwZLFoFyjoHtr\ntvwzNUS1U0hEqIaDeo4=\n-----END -----\n" signature:"0E\002!\000\364q\r\026\267\205\357\245\006\364\354v\333r92\022l\2267[Yb@F\263N\230\324\351.\025\002 \022K\275P\234\262A\3338\244\337\216\340q%-K_gM\226\330\336\233\346\231a;r\355F\261" > 
2018-02-07 05:16:57.451 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 00a Chaincode invoke successful. result: status:200 
2018-02-07 05:16:57.451 UTC [main] main -> INFO 00b Exiting.....

root@b1ded848f967:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode query -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"queryCar","Args":["CAR15"]}'
2018-02-07 05:17:07.383 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-07 05:17:07.383 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-07 05:17:07.383 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-07 05:17:07.383 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-07 05:17:07.384 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0A93070A6908031A0C08D397EAD30510...0871756572794361720A054341523135 
2018-02-07 05:17:07.384 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: FBFD595C716FB185BABBBD3709040F6D1538964931BA47A8B653E878C2084C4B 
Query Result: {"colour":"White","make":"Toyota","model":"Rezi","owner":"Neo"}
2018-02-07 05:17:07.411 UTC [main] main -> INFO 007 Exiting.....

```

## 2. Ubuntu 环境安装 Hyperledger Fabric v1.1.0

### 2.1. 安装 Docker

Ubuntu apt 库中携带的 docker.io 版本过低，我们从官网安装 Docker CE（社区版）取代他。

确保环境是干净的，卸载旧版本的 Docker

```

sudo apt-get remove docker docker-engine docker.io			

```

从官网安装新版本的 Docker

```

sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"

sudo apt-get update
sudo apt-get install docker-ce

sudo apt-get install python-pip
pip install docker-compose

```

启动 docker

```

neo@netkiller ~ % sudo systemctl start docker
neo@netkiller ~ % sudo systemctl status docker 
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: active (running) since Sat 2018-03-10 04:56:01 HST; 4s ago
     Docs: https://docs.docker.com
 Main PID: 27572 (dockerd)
    Tasks: 18
   Memory: 21.9M
      CPU: 578ms
   CGroup: /system.slice/docker.service
           ├─27572 /usr/bin/dockerd -H fd://
           └─27587 docker-containerd --config /var/run/docker/containerd/containerd.toml

Mar 10 04:56:00 netkiller dockerd[27572]: time="2018-03-10T04:56:00.020801698-10:00" level=warning msg="Your kernel does not support swap memory limit"
Mar 10 04:56:00 netkiller dockerd[27572]: time="2018-03-10T04:56:00.020948715-10:00" level=warning msg="Your kernel does not support cgroup rt period"
Mar 10 04:56:00 netkiller dockerd[27572]: time="2018-03-10T04:56:00.020991877-10:00" level=warning msg="Your kernel does not support cgroup rt runtime"
Mar 10 04:56:00 netkiller dockerd[27572]: time="2018-03-10T04:56:00.024334084-10:00" level=info msg="Loading containers: start."
Mar 10 04:56:00 netkiller dockerd[27572]: time="2018-03-10T04:56:00.786564515-10:00" level=info msg="Default bridge (docker0) is assigned with an IP address 172.17.0.0/16\. Daemon option --bip can be use
Mar 10 04:56:01 netkiller dockerd[27572]: time="2018-03-10T04:56:01.243512581-10:00" level=info msg="Loading containers: done."
Mar 10 04:56:01 netkiller dockerd[27572]: time="2018-03-10T04:56:01.262158514-10:00" level=info msg="Docker daemon" commit=7390fc6 graphdriver(s)=btrfs version=17.12.1-ce
Mar 10 04:56:01 netkiller dockerd[27572]: time="2018-03-10T04:56:01.262329696-10:00" level=info msg="Daemon has completed initialization"
Mar 10 04:56:01 netkiller dockerd[27572]: time="2018-03-10T04:56:01.280874987-10:00" level=info msg="API listen on /var/run/docker.sock"
Mar 10 04:56:01 netkiller systemd[1]: Started Docker Application Container Engine.			

```

### 2.2. 安装 Hyperledger Fabric v1.1.0 Docker 镜像

```

sudo docker pull hyperledger/fabric-ca:x86_64-1.1.0
sudo docker pull hyperledger/fabric-peer:x86_64-1.1.0 
sudo docker pull hyperledger/fabric-orderer:x86_64-1.1.0 
sudo docker pull hyperledger/fabric-couchdb:x86_64-1.1.0 
sudo docker pull hyperledger/fabric-tools:x86_64-1.1.0

sudo docker tag hyperledger/fabric-ca:x86_64-1.1.0 hyperledger/fabric-ca 
sudo docker tag hyperledger/fabric-peer:x86_64-1.1.0 hyperledger/fabric-peer 
sudo docker tag hyperledger/fabric-orderer:x86_64-1.1.0 hyperledger/fabric-orderer 
sudo docker tag hyperledger/fabric-couchdb:x86_64-1.1.0 hyperledger/fabric-couchdb 
sudo docker tag hyperledger/fabric-tools:x86_64-1.1.0 hyperledger/fabric-tools

```

```

neo@netkiller ~ % sudo docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
hyperledger/fabric-couchdb   latest              380446aa57b6        2 weeks ago         1.5GB
hyperledger/fabric-couchdb   x86_64-1.1.0        380446aa57b6        2 weeks ago         1.5GB
hyperledger/fabric-tools     latest              322eaa2b8786        3 weeks ago         1.33GB
hyperledger/fabric-tools     x86_64-1.1.0        322eaa2b8786        3 weeks ago         1.33GB
hyperledger/fabric-orderer   latest              659d92c1be85        3 weeks ago         151MB
hyperledger/fabric-orderer   x86_64-1.1.0        659d92c1be85        3 weeks ago         151MB
hyperledger/fabric-peer      latest              28c7c07db540        3 weeks ago         154MB
hyperledger/fabric-peer      x86_64-1.1.0        28c7c07db540        3 weeks ago         154MB
hyperledger/fabric-ca        latest              fe3c9b6542cf        3 weeks ago         238MB
hyperledger/fabric-ca        x86_64-1.1.0        fe3c9b6542cf        3 weeks ago         238MB

```

### 2.3. docker-compose

```

neo@netkiller ~ % sudo apt install python3-pip
neo@netkiller ~ % pip3 install docker-compose

```

或者

```

neo@netkiller ~ % sudo curl -sL https://github.com/docker/compose/releases/download/1.19.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
neo@netkiller ~ % sudo chmod +x /usr/local/bin/docker-compose
neo@netkiller ~ % docker-compose --version
docker-compose version 1.19.0, build 9e633ef			

```

## 3. Netkiller OSCM 一键安装

### 3.1. 安装 Docker

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/docker.centos7.ce.sh	 | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/registry-mirror.sh	 | bash

```

安装 docker-compose

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/docker-compose/docker-compose.sh | bash			

```

### 3.2. 清理 Docker 容器和镜像

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/hyperledger/fabric/uninstall.sh | bash			

```

### 3.3. Hyperledger Fabric 1.0.6

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/hyperledger/fabric/1.0.6/all-in-one.sh | bash

```

### 3.4. Hyperledger Fabric 1.1.0

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/hyperledger/fabric/1.1.0/all-in-one.sh | bash

```

### 3.5. Hyperledger Fabric 1.2.0

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/hyperledger/fabric/uninstall.sh | bash			
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/hyperledger/fabric/1.2.0/all-in-one.sh | bash

```

## 4. CentOS 8.0 安装 Fabric 2.0.0

### 4.1. CentOS 8 初始化

```

[root@localhost ~]# dnf update -y

```

禁用防火墙

```

[root@localhost ~]# systemctl disable firewalld
Removed /etc/systemd/system/multi-user.target.wants/firewalld.service.
Removed /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.		

```

### 4.2. 安装依赖命令和语言

```

if [ ! -f /usr/bin/bunzip2 ];then
    dnf install -y bzip2
fi

if [ ! -f /usr/bin/git ];then
    dnf install -y git
fi

if [ ! -f /usr/bin/go ];then
    dnf install -y golang
fi

```

```

curl -L --retry 5 --retry-delay 3 https://github.com/hyperledger/fabric/releases/download/v1.4.6/hyperledger-fabric-linux-amd64-1.4.6.tar.gz | tar xz
curl -L --retry 5 --retry-delay 3 https://github.com/hyperledger/fabric-ca/releases/download/v1.4.6/hyperledger-fabric-ca-linux-amd64-1.4.6.tar.gz | tar xz

mkdir -p /srv/hyperledger/fabric
mv bin config /srv/hyperledger/fabric
PATH=$PATH:/srv/hyperledger/fabric/bin

```

### 4.3. 安装 Docker

```

dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo

dnf install -y docker-ce

systemctl enable docker
systemctl start docker

```

安装 docker-compose

```

sudo curl -L "https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose		

```

### 4.4. 安装 Fabric 2.0.0

```

IMAGES=(ca peer orderer couchdb ccenv kafka zookeeper tools javaenv)		
FABRIC_TAG=latest
for IMAGE in ${IMAGES}; do
    echo "==> FABRIC IMAGE: $IMAGE"
    echo
    docker pull hyperledger/fabric-$IMAGE:$FABRIC_TAG
    echo
done		

```

按照完成检查镜像

```

[root@localhost src]# docker images
REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE
hyperledger/fabric-zookeeper   latest              21e55e9a2862        12 days ago         276MB
hyperledger/fabric-kafka       latest              28a93b376dbe        12 days ago         270MB
hyperledger/fabric-couchdb     latest              03ac1654afc5        12 days ago         261MB
hyperledger/fabric-ca          latest              3b96a893c1e4        2 weeks ago         150MB
hyperledger/fabric-tools       latest              0f9743ac0662        2 weeks ago         1.49GB
hyperledger/fabric-ccenv       latest              191911f4454f        2 weeks ago         1.36GB
hyperledger/fabric-orderer     latest              84eaba5388e7        2 weeks ago         120MB
hyperledger/fabric-peer        latest              5a52faa5d8c2        2 weeks ago         128MB		

```

## 5. fabric-samples

安装 fabric-samples

```

git clone https://github.com/hyperledger/fabric-samples.git
cd fabric-samples

```

fabric-samples 包含了很多例子，我们只运行几个常用的例子。

### 5.1. test-network

进入 fabric-samples/test-network 目录启动 Hyperledger Fabric 2.0，测试网络是否可用

```

[root@localhost ~]# cd fabric-samples/test-network/
[root@localhost ~]# ./network.sh up	

```

如果现实如下，恭喜！你的 Hyperledger Fabric 2.0 已经安装成功！

```

Creating network "net_test" with the default driver
Creating volume "net_orderer.example.com" with default driver
Creating volume "net_peer0.org1.example.com" with default driver
Creating volume "net_peer0.org2.example.com" with default driver
Creating orderer.example.com    ... done
Creating peer0.org2.example.com ... done
Creating peer0.org1.example.com ... done
CONTAINER ID        IMAGE                               COMMAND             CREATED             STATUS                  PORTS                              NAMES
8d0c74b9d6af        hyperledger/fabric-orderer:latest   "orderer"           4 seconds ago       Up Less than a second   0.0.0.0:7050->7050/tcp             orderer.example.com
ea1cf82b5b99        hyperledger/fabric-peer:latest      "peer node start"   4 seconds ago       Up Less than a second   0.0.0.0:7051->7051/tcp             peer0.org1.example.com
cd8d9b23cb56        hyperledger/fabric-peer:latest      "peer node start"   4 seconds ago       Up 1 second             7051/tcp, 0.0.0.0:9051->9051/tcp   peer0.org2.example.com		

```

### 5.2. fabcar

```

cd fabric-samples/fabcar				

```

启动

```

[root@localhost fabcar]# ./startFabric.sh 

# don't rewrite paths for Windows Git Bash users
export MSYS_NO_PATHCONV=1

docker-compose -f docker-compose.yml down
Stopping peer0.org1.example.com ... done
Stopping couchdb ... done
Stopping orderer.example.com ... done
Stopping ca.example.com ... done
Removing peer0.org1.example.com ... done
Removing couchdb ... done
Removing orderer.example.com ... done
Removing ca.example.com ... done
Removing network net_basic

docker-compose -f docker-compose.yml up -d ca.example.com orderer.example.com peer0.org1.example.com couchdb
Creating network "net_basic" with the default driver
Creating couchdb
Creating orderer.example.com
Creating ca.example.com
Creating peer0.org1.example.com

# wait for Hyperledger Fabric to start
# incase of errors when running later commands, issue export FABRIC_START_TIMEOUT=<larger number>
export FABRIC_START_TIMEOUT=10
#echo ${FABRIC_START_TIMEOUT}
sleep ${FABRIC_START_TIMEOUT}

# Create the channel
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp" peer0.org1.example.com peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx
2018-02-06 04:27:38.822 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-06 04:27:38.822 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-06 04:27:38.825 UTC [channelCmd] InitCmdFactory -> INFO 003 Endorser and orderer connections initialized
2018-02-06 04:27:38.825 UTC [msp] GetLocalMSP -> DEBU 004 Returning existing local MSP
2018-02-06 04:27:38.825 UTC [msp] GetDefaultSigningIdentity -> DEBU 005 Obtaining default signing identity
2018-02-06 04:27:38.826 UTC [msp] GetLocalMSP -> DEBU 006 Returning existing local MSP
2018-02-06 04:27:38.826 UTC [msp] GetDefaultSigningIdentity -> DEBU 007 Obtaining default signing identity
2018-02-06 04:27:38.826 UTC [msp/identity] Sign -> DEBU 008 Sign: plaintext: 0A88060A074F7267314D535012FC052D...53616D706C65436F6E736F727469756D 
2018-02-06 04:27:38.826 UTC [msp/identity] Sign -> DEBU 009 Sign: digest: D2F2DB3135CE892465FB7B6C2C89A6C566EC6E0081034AF00AF62014ED098E10 
2018-02-06 04:27:38.827 UTC [msp] GetLocalMSP -> DEBU 00a Returning existing local MSP
2018-02-06 04:27:38.827 UTC [msp] GetDefaultSigningIdentity -> DEBU 00b Obtaining default signing identity
2018-02-06 04:27:38.827 UTC [msp] GetLocalMSP -> DEBU 00c Returning existing local MSP
2018-02-06 04:27:38.827 UTC [msp] GetDefaultSigningIdentity -> DEBU 00d Obtaining default signing identity
2018-02-06 04:27:38.827 UTC [msp/identity] Sign -> DEBU 00e Sign: plaintext: 0ABF060A1508021A0608BADDE4D30522...4447D0A2A449E39255165BEE40760F3E 
2018-02-06 04:27:38.827 UTC [msp/identity] Sign -> DEBU 00f Sign: digest: BE32EAB1C6CE6A2C7F79FED4D1C646702EE07A3D64014B5EE2B77F8B35E9CF5F 
2018-02-06 04:27:38.935 UTC [msp] GetLocalMSP -> DEBU 010 Returning existing local MSP
2018-02-06 04:27:38.935 UTC [msp] GetDefaultSigningIdentity -> DEBU 011 Obtaining default signing identity
2018-02-06 04:27:38.935 UTC [msp] GetLocalMSP -> DEBU 012 Returning existing local MSP
2018-02-06 04:27:38.935 UTC [msp] GetDefaultSigningIdentity -> DEBU 013 Obtaining default signing identity
2018-02-06 04:27:38.935 UTC [msp/identity] Sign -> DEBU 014 Sign: plaintext: 0ABF060A1508021A0608BADDE4D30522...96444BF5E3AA12080A021A0012021A00 
2018-02-06 04:27:38.936 UTC [msp/identity] Sign -> DEBU 015 Sign: digest: 11D42E8978C507DC0C33304B81E089DB5DAB72967A153BD52932C5A4054C3D4B 
2018-02-06 04:27:38.937 UTC [channelCmd] readBlock -> DEBU 016 Got status: &{NOT_FOUND}
2018-02-06 04:27:38.937 UTC [msp] GetLocalMSP -> DEBU 017 Returning existing local MSP
2018-02-06 04:27:38.937 UTC [msp] GetDefaultSigningIdentity -> DEBU 018 Obtaining default signing identity
2018-02-06 04:27:38.939 UTC [channelCmd] InitCmdFactory -> INFO 019 Endorser and orderer connections initialized
2018-02-06 04:27:39.139 UTC [msp] GetLocalMSP -> DEBU 01a Returning existing local MSP
2018-02-06 04:27:39.139 UTC [msp] GetDefaultSigningIdentity -> DEBU 01b Obtaining default signing identity
2018-02-06 04:27:39.140 UTC [msp] GetLocalMSP -> DEBU 01c Returning existing local MSP
2018-02-06 04:27:39.140 UTC [msp] GetDefaultSigningIdentity -> DEBU 01d Obtaining default signing identity
2018-02-06 04:27:39.140 UTC [msp/identity] Sign -> DEBU 01e Sign: plaintext: 0ABF060A1508021A0608BBDDE4D30522...75CF3E958E8612080A021A0012021A00 
2018-02-06 04:27:39.140 UTC [msp/identity] Sign -> DEBU 01f Sign: digest: 26B8D88C16CF0DC0573F9BB9A69EC1BF1FEA8C12D052F832B3DB7B2A10D2CA6D 
2018-02-06 04:27:39.145 UTC [channelCmd] readBlock -> DEBU 020 Received block: 0
2018-02-06 04:27:39.146 UTC [main] main -> INFO 021 Exiting.....
# Join peer0.org1.example.com to the channel.
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp" peer0.org1.example.com peer channel join -b mychannel.block
2018-02-06 04:27:39.465 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-06 04:27:39.465 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-06 04:27:39.467 UTC [channelCmd] InitCmdFactory -> INFO 003 Endorser and orderer connections initialized
2018-02-06 04:27:39.468 UTC [msp/identity] Sign -> DEBU 004 Sign: plaintext: 0A86070A5C08011A0C08BBDDE4D30510...2A0C0B6B1D4B1A080A000A000A000A00 
2018-02-06 04:27:39.468 UTC [msp/identity] Sign -> DEBU 005 Sign: digest: 455E4221B3AE6DD1238BF5C8893970131846C096F1465D4CA89385AF3C7C0B2F 
2018-02-06 04:27:39.991 UTC [channelCmd] executeJoin -> INFO 006 Peer joined the channel!
2018-02-06 04:27:39.991 UTC [main] main -> INFO 007 Exiting.....
Creating cli
2018-02-06 04:27:46.123 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-06 04:27:46.123 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-06 04:27:46.123 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-06 04:27:46.123 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-06 04:27:47.513 UTC [golang-platform] getCodeFromFS -> DEBU 005 getCodeFromFS github.com/fabcar
2018-02-06 04:27:48.448 UTC [golang-platform] func1 -> DEBU 006 Discarding GOROOT package bytes
2018-02-06 04:27:48.449 UTC [golang-platform] func1 -> DEBU 007 Discarding GOROOT package encoding/json
2018-02-06 04:27:48.449 UTC [golang-platform] func1 -> DEBU 008 Discarding GOROOT package fmt
2018-02-06 04:27:48.449 UTC [golang-platform] func1 -> DEBU 009 Discarding provided package github.com/hyperledger/fabric/core/chaincode/shim
2018-02-06 04:27:48.449 UTC [golang-platform] func1 -> DEBU 00a Discarding provided package github.com/hyperledger/fabric/protos/peer
2018-02-06 04:27:48.449 UTC [golang-platform] func1 -> DEBU 00b Discarding GOROOT package strconv
2018-02-06 04:27:48.449 UTC [golang-platform] GetDeploymentPayload -> DEBU 00c done
2018-02-06 04:27:48.458 UTC [msp/identity] Sign -> DEBU 00d Sign: plaintext: 0A86070A5C08031A0C08C4DDE4D30510...939FFF060000FFFF9C08DC0700200000 
2018-02-06 04:27:48.459 UTC [msp/identity] Sign -> DEBU 00e Sign: digest: 881EE9535C8EC4371B72CE38BC52BD950864D1CA50F1F64B707EC7492B38AC75 
2018-02-06 04:27:48.512 UTC [chaincodeCmd] install -> DEBU 00f Installed remotely response:<status:200 payload:"OK" > 
2018-02-06 04:27:48.512 UTC [main] main -> INFO 010 Exiting.....
2018-02-06 04:27:48.845 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-06 04:27:48.845 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-06 04:27:48.847 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-06 04:27:48.848 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-06 04:27:48.849 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0A91070A6708031A0C08C4DDE4D30510...324D53500A04657363630A0476736363 
2018-02-06 04:27:48.849 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: 7279142B6DCADB92F178A42EB4812C9103108F2AEE8F40F8AD0125D3E13AEC25 
2018-02-06 04:28:51.790 UTC [msp/identity] Sign -> DEBU 007 Sign: plaintext: 0A91070A6708031A0C08C4DDE4D30510...33975E7D10605FC261528FBDEEC0A9A8 
2018-02-06 04:28:51.790 UTC [msp/identity] Sign -> DEBU 008 Sign: digest: 6A3D493ACD5E447FAD3D91C518CD60C45D0DB8E20D5DCFB70B45DA7572C666C0 
2018-02-06 04:28:51.885 UTC [main] main -> INFO 009 Exiting.....
2018-02-06 04:29:02.974 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-06 04:29:02.974 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-06 04:29:02.976 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-06 04:29:02.976 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-06 04:29:02.977 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0A93070A6908031A0C088EDEE4D30510...1A0E0A0A696E69744C65646765720A00 
2018-02-06 04:29:02.977 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: F5979DA908E3058B28762469FEECB498F506FB2A7D62F01ED56C5CCE3354D5CE 
2018-02-06 04:29:03.103 UTC [msp/identity] Sign -> DEBU 007 Sign: plaintext: 0A93070A6908031A0C088EDEE4D30510...EEB1365266BC4EF15DDAB42DD4202559 
2018-02-06 04:29:03.103 UTC [msp/identity] Sign -> DEBU 008 Sign: digest: 027F185369407246B34B7247E6B83E08078761FFA13C43F508CD7257BBF5BC7B 
2018-02-06 04:29:03.113 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> DEBU 009 ESCC invoke result: version:1 response:<status:200 message:"OK" > payload:"\n e\350\256\026\2161o\374\224\311\210g\322\001\234\332Vt\026+\204\034\013\310;\371\234\353\030`:\360\022\267\006\n\240\006\022\205\006\n\006fabcar\022\372\005\032J\n\004CAR0\032B{\"make\":\"Toyota\",\"model\":\"Prius\",\"colour\":\"blue\",\"owner\":\"Tomoko\"}\032G\n\004CAR1\032?{\"make\":\"Ford\",\"model\":\"Mustang\",\"colour\":\"red\",\"owner\":\"Brad\"}\032N\n\004CAR2\032F{\"make\":\"Hyundai\",\"model\":\"Tucson\",\"colour\":\"green\",\"owner\":\"Jin Soo\"}\032N\n\004CAR3\032F{\"make\":\"Volkswagen\",\"model\":\"Passat\",\"colour\":\"yellow\",\"owner\":\"Max\"}\032G\n\004CAR4\032?{\"make\":\"Tesla\",\"model\":\"S\",\"colour\":\"black\",\"owner\":\"Adriana\"}\032K\n\004CAR5\032C{\"make\":\"Peugeot\",\"model\":\"205\",\"colour\":\"purple\",\"owner\":\"Michel\"}\032H\n\004CAR6\032@{\"make\":\"Chery\",\"model\":\"S22L\",\"colour\":\"white\",\"owner\":\"Aarav\"}\032H\n\004CAR7\032@{\"make\":\"Fiat\",\"model\":\"Punto\",\"colour\":\"violet\",\"owner\":\"Pari\"}\032J\n\004CAR8\032B{\"make\":\"Tata\",\"model\":\"Nano\",\"colour\":\"indigo\",\"owner\":\"Valeria\"}\032M\n\004CAR9\032E{\"make\":\"Holden\",\"model\":\"Barina\",\"colour\":\"brown\",\"owner\":\"Shotaro\"}\022\026\n\004lscc\022\016\n\014\n\006fabcar\022\002\010\001\032\003\010\310\001\"\r\022\006fabcar\032\0031.0" endorsement:<endorser:"\n\007Org1MSP\022\200\006-----BEGIN -----\nMIICGjCCAcCgAwIBAgIRAPlwF/rUZUP9mqN4wSml4iswCgYIKoZIzj0EAwIwczEL\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\ncmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh\nLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcwODMxMDkxNDMyWhcNMjcwODI5MDkxNDMy\nWjBbMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN\nU2FuIEZyYW5jaXNjbzEfMB0GA1UEAxMWcGVlcjAub3JnMS5leGFtcGxlLmNvbTBZ\nMBMGByqGSM49AgEGCCqGSM49AwEHA0IABHihxW6ks3B2+5XdbAVq3CBgxRRRZ22x\nzzpqnD86nKkz7fBElBuhlXl2K6rTxyY2OBOB0ts8keqZ93xueRGymrajTTBLMA4G\nA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1UdIwQkMCKAIEI5qg3Ndtru\nuLoM2nAYUdFFBNMarRst3dusalc2Xkl8MAoGCCqGSM49BAMCA0gAMEUCIQD4j0Rn\ne1rrd0FSCzsR6u+IuuPK5dI/kR/bh7+VLf0TNgIgCfUtkJvfvzVEwZLFoFyjoHtr\ntvwzNUS1U0hEqIaDeo4=\n-----END -----\n" signature:"0E\002!\000\271u\265\3621\223\255|\353h\003\364g\363\3474\310>\032\351\225\326\306z\356\324\013\366\235\334J\237\002 ^>\200AhmDWh\261\301\204Ye\346\345\356\2616Rf\274N\361]\332\264-\324 %Y" > 
2018-02-06 04:29:03.113 UTC [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 00a Chaincode invoke successful. result: status:200 
2018-02-06 04:29:03.113 UTC [main] main -> INFO 00b Exiting.....

Total setup execution time : 136 secs ...

Start by installing required packages run 'npm install'
Then run 'node enrollAdmin.js', then 'node registerUser'

The 'node invoke.js' will fail until it has been updated with valid arguments
The 'node query.js' may be run at anytime once the user has been registered

```

至此 hyperledger 开发环境已经启动完毕

```

node enrollAdmin.js
node registerUser.js 
node invoke.js
node query.js 		

```

```

[root@localhost fabcar]# node enrollAdmin.js
 Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded admin from persistence
Assigned the admin user to the fabric client ::{"name":"admin","mspid":"Org1MSP","roles":null,"affiliation":"","enrollmentSecret":"","enrollment":{"signingIdentity":"9995fba0ac327e43983b07d09a50423de8cb510176484566abfce0cb86e5f594","identity":{"certificate":"-----BEGIN CERTIFICATE-----\nMIIB8TCCAZegAwIBAgIUNH9h0PUYxF1vpUqzEXKRfVc2a7YwCgYIKoZIzj0EAwIw\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTgwMjA2MDQ0NTAwWhcNMTkwMjA2MDQ0\nNTAwWjAQMQ4wDAYDVQQDEwVhZG1pbjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA\nBEhyVSI9Dl7S2fIYQdiJAB2zeXR9aHIQSVSG7auK3y3yVvABOQPA/Kyn2iMAl4rr\nky/0FYY5B+lxYLLSype/2zKjbDBqMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8E\nAjAAMB0GA1UdDgQWBBRotEXOHR/h1ZLwHV/eAUT80bIQFTArBgNVHSMEJDAigCBC\nOaoNzXba7ri6DNpwGFHRRQTTGq0bLd3brGpXNl5JfDAKBggqhkjOPQQDAgNIADBF\nAiEAnBH8WJvb24o2eC5VmMvtQMoB8NDBTpdq5RNyVJx97HcCIBhWMM6R7crkL8M7\n3wmZ1lNNkAJmpRoes7cNxO/ak5Xy\n-----END CERTIFICATE-----\n"}}}

[root@localhost fabcar]# node registerUser.js 
 Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded admin from persistence
Successfully registered user1 - secret:ZjzLwIaVjEAV
Successfully enrolled member user "user1" 
User1 was successfully registered and enrolled and is ready to intreact with the fabric network

[root@localhost fabcar]# node query.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  [{"Key":"CAR0", "Record":{"colour":"blue","make":"Toyota","model":"Prius","owner":"Tomoko"}},{"Key":"CAR1", "Record":{"colour":"red","make":"Ford","model":"Mustang","owner":"Brad"}},{"Key":"CAR2", "Record":{"colour":"green","make":"Hyundai","model":"Tucson","owner":"Jin Soo"}},{"Key":"CAR3", "Record":{"colour":"yellow","make":"Volkswagen","model":"Passat","owner":"Max"}},{"Key":"CAR4", "Record":{"colour":"black","make":"Tesla","model":"S","owner":"Adriana"}},{"Key":"CAR5", "Record":{"colour":"purple","make":"Peugeot","model":"205","owner":"Michel"}},{"Key":"CAR6", "Record":{"colour":"white","make":"Chery","model":"S22L","owner":"Aarav"}},{"Key":"CAR7", "Record":{"colour":"violet","make":"Fiat","model":"Punto","owner":"Pari"}},{"Key":"CAR8", "Record":{"colour":"indigo","make":"Tata","model":"Nano","owner":"Valeria"}},{"Key":"CAR9", "Record":{"colour":"brown","make":"Holden","model":"Barina","owner":"Shotaro"}}]		

```

invoke.js 脚本会出现下面错误

```

[root@localhost fabcar]# node invoke.js
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Assigning transaction_id:  424c946e96d43005e4b815f56fa43bd58d1370404f6713b3ce267928d4499b78
error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: 2 UNKNOWN: chaincode error (status: 500, message: Invalid Smart Contract function name.)
    at new createStatusError (/root/fabric-samples/fabcar/node_modules/grpc/src/client.js:65:15)
    at /root/fabric-samples/fabcar/node_modules/grpc/src/client.js:568:15
Transaction proposal was bad
Failed to send Proposal or receive valid response. Response null or status is not 200\. exiting...
Failed to invoke successfully :: Error: Failed to send Proposal or receive valid response. Response null or status is not 200\. exiting...			

```

这里出错，是因为没有提供相关的调用方法和参数，暂时不去纠结，继续做实验。

#### 5.2.1. 智能合约

```

[root@localhost fabric-samples]# cat chaincode/fabcar/fabcar.go 
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * The sample smart contract for documentation topic:
 * Writing Your First Blockchain Application
 */

package main

/* Imports
 * 4 utility libraries for formatting, handling bytes, reading and writing JSON, and string manipulation
 * 2 specific Hyperledger Fabric specific libraries for Smart Contracts
 */
import (
	"bytes"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	sc "github.com/hyperledger/fabric/protos/peer"
)

// Define the Smart Contract structure
type SmartContract struct {
}

// Define the car structure, with 4 properties.  Structure tags are used by encoding/json library
type Car struct {
	Make   string `json:"make"`
	Model  string `json:"model"`
	Colour string `json:"colour"`
	Owner  string `json:"owner"`
}

/*
 * The Init method is called when the Smart Contract "fabcar" is instantiated by the blockchain network
 * Best practice is to have any Ledger initialization in separate function -- see initLedger()
 */
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
	return shim.Success(nil)
}

/*
 * The Invoke method is called as a result of an application request to run the Smart Contract "fabcar"
 * The calling application program has also specified the particular smart contract function to be called, with arguments
 */
func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "queryCar" {
		return s.queryCar(APIstub, args)
	} else if function == "initLedger" {
		return s.initLedger(APIstub)
	} else if function == "createCar" {
		return s.createCar(APIstub, args)
	} else if function == "queryAllCars" {
		return s.queryAllCars(APIstub)
	} else if function == "changeCarOwner" {
		return s.changeCarOwner(APIstub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}

func (s *SmartContract) queryCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	carAsBytes, _ := APIstub.GetState(args[0])
	return shim.Success(carAsBytes)
}

func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response {
	cars := []Car{
		Car{Make: "Toyota", Model: "Prius", Colour: "blue", Owner: "Tomoko"},
		Car{Make: "Ford", Model: "Mustang", Colour: "red", Owner: "Brad"},
		Car{Make: "Hyundai", Model: "Tucson", Colour: "green", Owner: "Jin Soo"},
		Car{Make: "Volkswagen", Model: "Passat", Colour: "yellow", Owner: "Max"},
		Car{Make: "Tesla", Model: "S", Colour: "black", Owner: "Adriana"},
		Car{Make: "Peugeot", Model: "205", Colour: "purple", Owner: "Michel"},
		Car{Make: "Chery", Model: "S22L", Colour: "white", Owner: "Aarav"},
		Car{Make: "Fiat", Model: "Punto", Colour: "violet", Owner: "Pari"},
		Car{Make: "Tata", Model: "Nano", Colour: "indigo", Owner: "Valeria"},
		Car{Make: "Holden", Model: "Barina", Colour: "brown", Owner: "Shotaro"},
	}

	i := 0
	for i < len(cars) {
		fmt.Println("i is ", i)
		carAsBytes, _ := json.Marshal(cars[i])
		APIstub.PutState("CAR"+strconv.Itoa(i), carAsBytes)
		fmt.Println("Added", cars[i])
		i = i + 1
	}

	return shim.Success(nil)
}

func (s *SmartContract) createCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 5 {
		return shim.Error("Incorrect number of arguments. Expecting 5")
	}

	var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]}

	carAsBytes, _ := json.Marshal(car)
	APIstub.PutState(args[0], carAsBytes)

	return shim.Success(nil)
}

func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "CAR0"
	endKey := "CAR999"

	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return shim.Error(err.Error())
		}
		// Add a comma before array members, suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- queryAllCars:\n%s\n", buffer.String())

	return shim.Success(buffer.Bytes())
}

func (s *SmartContract) changeCarOwner(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	carAsBytes, _ := APIstub.GetState(args[0])
	car := Car{}

	json.Unmarshal(carAsBytes, &car)
	car.Owner = args[1]

	carAsBytes, _ = json.Marshal(car)
	APIstub.PutState(args[0], carAsBytes)

	return shim.Success(nil)
}

// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}				

```

#### 5.2.2. 创建记录

```

[root@localhost fabcar]# cp invoke.js createCar.js
[root@localhost fabcar]# vim createCar.js

```

```

var request = {
                //targets: let default to the peer assigned to the client
                chaincodeId: 'fabcar',
                fcn: '',
                args: [''],
                chainId: 'mychannel',
                txId: tx_id
        };

```

改为

```

	var request = {
		//targets: let default to the peer assigned to the client
		chaincodeId: 'fabcar',
		fcn: 'createCar',
		args: ['CAR10', 'Chevy', 'Volt', 'Red', 'Nick'],
		chainId: 'mychannel',
		txId: tx_id
	};				

```

运行结果

```

[root@localhost fabcar]# node createCar.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Assigning transaction_id:  907d35d7c5debf952f28135b2c341797acdb7ef1f1389607fb04891a27e8ba19
Transaction proposal was good
Successfully sent Proposal and received ProposalResponse: Status - 200, message - "OK"
info: [EventHub.js]: _connect - options {}
The transaction has been committed on peer localhost:7053
Send transaction promise and event listener promise have completed
Successfully sent transaction to the orderer.
Successfully committed the change to the ledger by the peer				

```

#### 5.2.3. 查询单条记录

查找 CAR5 这条记录的数据。

```

[root@localhost fabcar]# node queryOne.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  {"colour":"purple","make":"Peugeot","model":"205","owner":"Michel"}
[root@localhost fabcar]# cat queryOne.js 
'use strict';
/*
* Copyright IBM Corp All Rights Reserved
*
* SPDX-License-Identifier: Apache-2.0
*/
/*
 * Chaincode query
 */

var Fabric_Client = require('fabric-client');
var path = require('path');
var util = require('util');
var os = require('os');

//
var fabric_client = new Fabric_Client();

// setup the fabric network
var channel = fabric_client.newChannel('mychannel');
var peer = fabric_client.newPeer('grpc://localhost:7051');
channel.addPeer(peer);

//
var member_user = null;
var store_path = path.join(__dirname, 'hfc-key-store');
console.log('Store path:'+store_path);
var tx_id = null;

// create the key value store as defined in the fabric-client/config/default.json 'key-value-store' setting
Fabric_Client.newDefaultKeyValueStore({ path: store_path
}).then((state_store) => {
	// assign the store to the fabric client
	fabric_client.setStateStore(state_store);
	var crypto_suite = Fabric_Client.newCryptoSuite();
	// use the same location for the state store (where the users' certificate are kept)
	// and the crypto store (where the users' keys are kept)
	var crypto_store = Fabric_Client.newCryptoKeyStore({path: store_path});
	crypto_suite.setCryptoKeyStore(crypto_store);
	fabric_client.setCryptoSuite(crypto_suite);

	// get the enrolled user from persistence, this user will sign all requests
	return fabric_client.getUserContext('user1', true);
}).then((user_from_store) => {
	if (user_from_store && user_from_store.isEnrolled()) {
		console.log('Successfully loaded user1 from persistence');
		member_user = user_from_store;
	} else {
		throw new Error('Failed to get user1.... run registerUser.js');
	}

	// queryCar chaincode function - requires 1 argument, ex: args: ['CAR4'],
	// queryAllCars chaincode function - requires no arguments , ex: args: [''],
	const request = {
		//targets : --- letting this default to the peers assigned to the channel
		chaincodeId: 'fabcar',
		fcn: 'queryCar',
		args: ['CAR10']
	};

	// send the query proposal to the peer
	return channel.queryByChaincode(request);
}).then((query_responses) => {
	console.log("Query has completed, checking results");
	// query_responses could have more than one  results if there multiple peers were used as targets
	if (query_responses && query_responses.length == 1) {
		if (query_responses[0] instanceof Error) {
			console.error("error from query = ", query_responses[0]);
		} else {
			console.log("Response is ", query_responses[0].toString());
		}
	} else {
		console.log("No payloads were returned from query");
	}
}).catch((err) => {
	console.error('Failed to query successfully :: ' + err);
});

```

运行结果

```

[root@localhost fabcar]# node queryOne.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  {"colour":"Red","make":"Chevy","model":"Volt","owner":"Nick"}			

```

#### 5.2.4. 修改汽车所有者

```

[root@localhost fabcar]# cp invoke.js changeCarOwner.js
[root@localhost fabcar]# vim changeCarOwner.js 				

```

```

        var request = {
                //targets: let default to the peer assigned to the client
                chaincodeId: 'fabcar',
                fcn: '',
                args: [''],
                chainId: 'mychannel',
                txId: tx_id
        };				

```

修改为

```

        var request = {
                //targets: let default to the peer assigned to the client
                chaincodeId: 'fabcar',
                fcn: 'changeCarOwner',
                args: ['CAR10', 'Neo'],
                chainId: 'mychannel',
                txId: tx_id
        };				

```

运行结果

```

[root@localhost fabcar]# node changeCarOwner.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Assigning transaction_id:  b183a7bac6161ff7c7e9974e20bb1a72b2ac5f11ab698a2ae4f63cfdbc33a735
Transaction proposal was good
Successfully sent Proposal and received ProposalResponse: Status - 200, message - "OK"
info: [EventHub.js]: _connect - options {}
The transaction has been committed on peer localhost:7053
Send transaction promise and event listener promise have completed
Successfully sent transaction to the orderer.
Successfully committed the change to the ledger by the peer

[root@localhost fabcar]# node queryOne.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  {"colour":"Red","make":"Chevy","model":"Volt","owner":"Neo"}

```

现在我们可以看到 所有者已经改为 Neo

### 5.3. balance-transfer

```

[root@localhost fabric-samples]# cd balance-transfer/
[root@localhost balance-transfer]# ./runApp.sh 

Stopping peer0.org1.example.com ... done
Stopping peer0.org2.example.com ... done
Stopping peer1.org2.example.com ... done
Stopping peer1.org1.example.com ... done
Stopping ca_peerOrg1 ... done
Stopping orderer.example.com ... done
Stopping ca_peerOrg2 ... done
Removing peer0.org1.example.com ... done
Removing peer0.org2.example.com ... done
Removing peer1.org2.example.com ... done
Removing peer1.org1.example.com ... done
Removing ca_peerOrg1 ... done
Removing orderer.example.com ... done
Removing ca_peerOrg2 ... done
Removing network artifacts_default

========== No containers available for deletion ==========

========== No images available for deletion ===========

Creating network "artifacts_default" with the default driver
Creating ca_peerOrg2
Creating orderer.example.com
Creating ca_peerOrg1
Creating peer1.org2.example.com
Creating peer0.org2.example.com
Creating peer0.org1.example.com
Creating peer1.org1.example.com
/root/fabric-samples/balance-transfer

============== node modules installed already =============

[2018-02-06 09:14:54.916] [DEBUG] Helper - [crypto_ecdsa_aes]: constructor, keySize: 256
[2018-02-06 09:14:54.921] [DEBUG] Helper - [crypto_ecdsa_aes]: Hash algorithm: SHA2, hash output size: 256
[2018-02-06 09:14:55.046] [DEBUG] Helper - [utils.CryptoKeyStore]: CryptoKeyStore, constructor - start
[2018-02-06 09:14:55.048] [DEBUG] Helper - [utils.CryptoKeyStore]: constructor, no super class specified, using config: fabric-client/lib/impl/FileKeyValueStore.js
[2018-02-06 09:14:55.056] [DEBUG] Helper - [crypto_ecdsa_aes]: constructor, keySize: 256
[2018-02-06 09:14:55.056] [DEBUG] Helper - [crypto_ecdsa_aes]: Hash algorithm: SHA2, hash output size: 256
[2018-02-06 09:14:55.057] [DEBUG] Helper - [utils.CryptoKeyStore]: CryptoKeyStore, constructor - start
[2018-02-06 09:14:55.057] [DEBUG] Helper - [utils.CryptoKeyStore]: constructor, no super class specified, using config: fabric-client/lib/impl/FileKeyValueStore.js
[2018-02-06 09:14:55.082] [INFO] SampleWebApp - ****************** SERVER STARTED ************************
[2018-02-06 09:14:55.082] [INFO] SampleWebApp - **************  http://localhost:4000  ******************

```

安装 jq 工具

```

yum install -y jq			

```

API 测试结果

```

[root@localhost balance-transfer]# ./testAPIs.sh 
POST request Enroll on Org1  ...

{"success":true,"secret":"uXlJIPvBgLbh","message":"Jim enrolled Successfully","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTc5NjMwMDUsInVzZXJuYW1lIjoiSmltIiwib3JnTmFtZSI6Im9yZzEiLCJpYXQiOjE1MTc5MjcwMDV9.pBqwAVac32NIA_x5S163h9_lRfIHMx4shX05D0geO5k"}

ORG1 token is eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTc5NjMwMDUsInVzZXJuYW1lIjoiSmltIiwib3JnTmFtZSI6Im9yZzEiLCJpYXQiOjE1MTc5MjcwMDV9.pBqwAVac32NIA_x5S163h9_lRfIHMx4shX05D0geO5k

POST request Enroll on Org2 ...

{"success":true,"secret":"kXcltqsAoiDf","message":"Barry enrolled Successfully","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTc5NjMwMDcsInVzZXJuYW1lIjoiQmFycnkiLCJvcmdOYW1lIjoib3JnMiIsImlhdCI6MTUxNzkyNzAwN30.ePexFJ2r9WoYNma5iKomJu3anEvg3PTgBEqI6K-s6F0"}

ORG2 token is eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1MTc5NjMwMDcsInVzZXJuYW1lIjoiQmFycnkiLCJvcmdOYW1lIjoib3JnMiIsImlhdCI6MTUxNzkyNzAwN30.ePexFJ2r9WoYNma5iKomJu3anEvg3PTgBEqI6K-s6F0

POST request Create channel  ...

{"success":true,"message":"Channel 'mychannel' created Successfully"}

POST request Join channel on Org1

{"success":true,"message":"Successfully joined peers in organization org1 to the channel 'mychannel'"}

POST request Join channel on Org2

{"success":true,"message":"Successfully joined peers in organization org2 to the channel 'mychannel'"}

POST Install chaincode on Org1

Successfully Installed chaincode on organization org1

POST Install chaincode on Org2

Successfully Installed chaincode on organization org2

POST instantiate chaincode on peer1 of Org1

Failed to order the transaction. Error code: undefined

POST invoke chaincode on peers of Org1 and Org2

Transacton ID is Failed to order the transaction. Error code: undefined

GET query chaincode on peer1 of Org1

a now has Error: 2 UNKNOWN: could not find chaincode with name 'mycc' - make sure the chaincode mycc has been successfully instantiated and try again after the move

GET query Block by blockNumber

Error: 2 UNKNOWN: chaincode error (status: 500, message: Failed to get block number 1, error Entry not found in index)
    at new createStatusError (/root/fabric-samples/balance-transfer/node_modules/grpc/src/client.js:65:15)
    at /root/fabric-samples/balance-transfer/node_modules/grpc/src/client.js:568:15

GET query Transaction by TransactionID

Error: 2 UNKNOWN: chaincode error (status: 500, message: Failed to get transaction with id Failed, error Entry not found in index)
    at new createStatusError (/root/fabric-samples/balance-transfer/node_modules/grpc/src/client.js:65:15)
    at /root/fabric-samples/balance-transfer/node_modules/grpc/src/client.js:568:15

GET query ChainInfo

{"height":{"low":1,"high":0,"unsigned":true},"currentBlockHash":{"buffer":{"type":"Buffer","data":[8,1,18,32,180,19,234,224,76,239,188,107,147,219,120,185,108,73,201,120,81,0,242,221,32,3,94,175,16,200,181,113,100,97,129,57]},"offset":4,"markedOffset":-1,"limit":36,"littleEndian":true,"noAssert":false},"previousBlockHash":{"buffer":{"type":"Buffer","data":[]},"offset":0,"markedOffset":-1,"limit":0,"littleEndian":false,"noAssert":false}}

GET query Installed chaincodes

["name: mycc, version: v0, path: github.com/example_cc"]

GET query Instantiated chaincodes

[]

GET query Channels

{"channels":[{"channel_id":"mychannel"}]}

Total execution time : 364 secs ...			

```

上面 ERROR 可能是因为 hyperledger v1.1.0 版本的缘故。此时的 fabric-samples 仅仅支持 v1.0.0。

### 5.4. first-network

```

cd fabric-samples/first-network			

```

```

[root@localhost first-network]# ./byfn.sh -m generate 
Generating certs and genesis block for with channel 'mychannel' and CLI timeout of '10'
Continue (y/n)? y
proceeding ...
which: no cryptogen in (/root/fabric-samples/first-network/../bin:/root/fabric-samples/first-network:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/srv/php/bin::/root/bin:/usr/local/src/phalcon-devtools)
cryptogen tool not found. exiting			

```

```

[root@localhost first-network]# ./byfn.sh -m up 

```

## 6. e2e_cli

运行这个命令请慎重，这里是为了不被先前的实验产生的容易所影响，清理 Docker 虚拟机，

```

[root@localhost ~]# docker rmi -f $(docker images -q)

```

克隆源码，因为我们需要 example 目录中的文件，所以将 https://github.com/hyperledger/fabric.git 源码克隆到本地。

```

[root@localhost ~]# go get github.com/hyperledger/fabric

[root@localhost ~]# git clone --depth=1 https://github.com/hyperledger/fabric.git
[root@localhost ~]# cd fabric
[root@localhost fabric]# make release
[root@localhost ~]# cd ~/fabric/examples/e2e_cli/
[root@localhost e2e_cli]#

```

## 7. Hyperledger Composer

### Build Blockchain applications and business networks your way

[`hyperledger.github.io/composer/`](https://hyperledger.github.io/composer/)

## 8. 创世区块

创建创世区块需要两个配置文件，一个是 crypto-config.yaml 文件， 另一个是 configtx.yaml 文件

### 8.1. crypto-config.yaml

crypto-config.yaml 证书配置文件

```

OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 1
    Users:
      Count: 1			

```

Name：定义名称

Domain 与 Hostname：组合成为节点的名称，也是生成后的文件夹的名称。

Template: 模板数量

Users：用来指定添加进节点的默认用户数

Count：用来指定每个 org 下边所拥有的节点数。

如果有多个 Peer 节点参考下面配置。

```

[root@localhost netkiller]# vim crypto-config.yaml

OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 2
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 2
    Users:
      Count: 1

```

### 8.2. configtx.yaml

## 9. hyperledger/fabric-ca

go 安装方式

```

go get github.com/hyperledger/fabric-ca		

```

## 10. Restful 接口

### 10.1. 注册

```

curl -i -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d '
{

    "enrollId": "jim",
    "enrollSecret": "6avZQLwcUe9b"

}' http://localhost:7050/registrar			

```

### 10.2. 

```

curl -i -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d '
{

   "jsonrpc": "2.0",
   "method": "deploy",
   "params": {
    "type": 1,
    "chaincodeID":{
        "name": "mycc"
    },
    "ctorMsg": {
         "function":"init",
         "args":[]
     },
    "secureContext": "jim"
  },
   "id": 1

}' http://localhost:7050/chaincode	

```

## 第 25 章 Hyperledger Fabric 运维

## 1. 背景

由于区块链是区中心化，与传统运维不同，所以之前你积累的经验，不一定适用于区块链。要想运维好区块链项目，就必须理解去中心化这个概念。

首先谈谈传统运维，总结为三个字“中心化”，当然有人反对并抛出“分布式”感念，传统运维的分布式仍然建立在中心化的基础之上。

我们来看看传统应用模式，决多数应用都可以概括为：

用户 -> WEB -> Application -> Cache -> Database 

可以在这个体系下面做灵活变化，例如加入所有引擎、分布式文件系统，大数据等等应用，但都离不开这个模式。

区块链完全不同，如果举一个最接近的例子，我想可能与多数据中心远程异地灾备比较接近。

## 2. 部署拓扑

什么是区块链呢？ 区块链实际上就是数据库，一个只能插入和查询的数据库，数据不能被修改和删除，并且这个数据库没有 DBA 管理员角色。这么一说你应该明白了把，实际上运维区块链就是在维护一个分布式数据库。

网上的绝大多数安装例子中，均采用 docker 部署方案，但无一例外的是，全部安装在一个物理机上。如果是生产环境，我们必须分开不是，首先要做的工作是化整为零，拆解应用，搞明白每个容器的功能和作用。然后我们将应用拆分，独立部署到物理节点上去。

     +---------------------------------+
     |                SDK               |
     +---------------------------------+
     | golang | nodejs | python | java |
     +---------------------------------+
       |                     |
       |                     |
           |   +--------------+ |
           |   |  fabric-ca   |  |
           |   +--------------+  |
           |                     |
           V                     V
+-------------------+   +-------------------+
| Peer            |   |  Peer             |         
+-------------------+   +-------------------+
     |          |           |        |
     V          |           |        V
+-----------+   |           |   +------------+
| Orderer   |   |           |   | Orderer    |
+-----------+   |           |   +------------+
                V           V
            +-------------------+
            |     Couchdb       |
            +-------------------+

接下来我们要做的工作是将上面拓扑图种的技术点分分击破。

由于 Hyperledger Fabric 是建立在 Docker 基础之上的。所以不建议你去除 Docker 转而使用传统的本地编译安装方式。我们仍然保持使用 Docker 在每个物理节点上，省去软件的编译和安装环节。

### 2.1. 依赖关系

需要注意的是于其他传统系统一样，Hyperledger Fabric 的启动也是有顺序的，这是因为他们之间存在着依赖关系。

### 2.2. 准备物理机

CentOS (Minimal ISO)

物理机

*   ca 节点，域名：ca.example.com，IP 地址：172.16.0.20，端口：7054

*   orderer 节点，域名 orderer.example.com，IP 地址：172.16.0.21，端口：7050

*   peer 节点，域名：peer.example.com，IP 地址：172.16.0.22，端口：7051、7053

*   couchdb 节点，域名 couchdb.example.com，IP 地址：172.16.0.25，端口：5984

*   tools 节点，域名：tools.example.com，IP 地址：172.16.0.20 与 CA 共用一台机器(这里为了节省资源)

在所有节点上运行下面脚本

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/docker.centos7.ce.sh	 | bash	
curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/docker-compose/docker-compose-1.19.0.sh | bash		

```

## 3. cli 管理节点安装

Tools 在生成创世区块的时候我们就曾经使用，你可以沿用之前的 tools 节点，或者创建一个 cli 节点，这个节点主要是用于管理区块链集群，例如合约部署，调试等等。

### 3.1. 安装 Docker 镜像

```

docker pull hyperledger/fabric-tools:x86_64-1.1.0
docker tag hyperledger/fabric-tools:x86_64-1.1.0 hyperledger/fabric-tools			

```

### 3.2. docker-compose-cli.yaml

```

version: '3'

networks:
  basic:

services:

  cli:
    container_name: cli
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
      - CORE_CHAINCODE_KEEPALIVE=10
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: /bin/bash
    volumes:
        - /var/run/:/host/var/run/
        - ./chaincode/:/opt/gopath/src/github.com/
        - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
        - ~/netkiller:/root/netkiller
    networks:
        - basic
    #depends_on:
    #  - orderer.example.com
    #  - peer0.org1.example.com
    #  - couchdb	
    extra_hosts:
    		- "ca.example.com:172.16.0.20"
		- "orderer.example.com:172.16.0.21"
		- "peer0.org1.example.com:172.16.0.22"
		- "couchdb.example.com:172.16.0.25"

```

### 3.3. 启动 cli 节点

```

[root@localhost netkiller]# docker-compose -f docker-compose-cli.yaml up -d

```

后面合约的部署将在 cli 节点上进行

### 3.4. 生成证书和创世区块

这里我们需要几个命令（configtxgen configtxlator cryptogen），官方的安装方式：

```

curl -sSL https://goo.gl/byy2Qj | bash -s 1.1.0

```

无论如何我都安装不成功，可能是（https://goo.gl/byy2Qj）被天朝给墙了。不过我发现 fabric-tools 里面有这个工具。

### 提示

经过翻墙发现 https://goo.gl/byy2Qj 地址是 301 到下面地址：

[`raw.githubusercontent.com/hyperledger/fabric/v1.1.0/scripts/bootstrap.sh`](https://raw.githubusercontent.com/hyperledger/fabric/v1.1.0/scripts/bootstrap.sh)

```

[root@localhost ~]# mkdir netkiller
[root@localhost ~]# cd netkiller/
[root@localhost netkiller]# mkdir -p {chaincode,crypto-config,config,artifacts}	

```

#### 3.4.1. 创建配置文件

##### 3.4.1.1. crypto-config.yaml

创建证书

```

OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 1
    Users:
      Count: 1			

```

##### 3.4.1.2. configtx.yaml

```

---
Profiles:

    OneOrgOrdererGenesis:
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
    OneOrgChannel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1

Organizations:

    - &OrdererOrg
        Name: OrdererOrg

        ID: OrdererMSP

        MSPDir: crypto-config/ordererOrganizations/example.com/msp

    - &Org1
        Name: Org1MSP

        ID: Org1MSP

        MSPDir: crypto-config/peerOrganizations/org1.example.com/msp

        AnchorPeers:
            - Host: peer0.org1.example.com
              Port: 7051

Orderer: &OrdererDefaults

    OrdererType: solo

    Addresses:
        - orderer.example.com:7050

    BatchTimeout: 2s

    BatchSize:

        MaxMessageCount: 10

        AbsoluteMaxBytes: 99 MB

        PreferredMaxBytes: 512 KB

    Kafka:
        Brokers:
            - 127.0.0.1:9092

    Organizations:

Application: &ApplicationDefaults

    Organizations:

```

#### 3.4.2. 生成证书

命令

```

cryptogen generate --config=./crypto-config.yaml

```

演示

```

root@8f467a88de99:~/netkiller# cryptogen generate --config=./crypto-config.yaml
org1.example.com

root@8f467a88de99:~/netkiller# ls -1 crypto-config
ordererOrganizations
peerOrganizations

```

#### 3.4.3. 生成创世区块

```

root@8f467a88de99:~/netkiller# export FABRIC_CFG_PATH=$PWD				
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block
2018-02-08 08:35:30.121 UTC [common/configtx/tool] main -> INFO 001 Loading configuration
2018-02-08 08:35:30.236 UTC [common/configtx/tool] doOutputBlock -> INFO 002 Generating genesis block
2018-02-08 08:35:30.238 UTC [common/configtx/tool] doOutputBlock -> INFO 003 Writing genesis block			

```

#### 3.4.4. 生成通道配置文件

命令

```

CHANNEL_NAME=mychannel
configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME				

```

操作演示

```

root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 
2018-02-08 08:41:08.010 UTC [common/configtx/tool] main -> INFO 001 Loading configuration
2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -> INFO 002 Generating new channel configtx
2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -> INFO 003 Writing new channel tx				

```

#### 3.4.5.  generate anchor peer transaction

命令

```

CHANNEL_NAME=mychannel
configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP				

```

操作演示

```

root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
2018-02-08 08:46:19.162 UTC [common/configtx/tool] main -> INFO 001 Loading configuration
2018-02-08 08:46:19.176 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -> INFO 002 Generating anchor peer update
2018-02-08 08:46:19.177 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -> INFO 003 Writing anchor peer update

```

至此所有需要生成的配置文件全部生成完毕。

```

[root@localhost netkiller]# tree -L 4 crypto-config
crypto-config
|-- ordererOrganizations
|   `-- example.com
|       |-- ca
|       |   |-- ca.example.com-cert.pem
|       |   `-- de9204448c9c8e2a72d092f53e8ff069e12dea62001b7b8b9a83ae240d80ed57_sk
|       |-- msp
|       |   |-- admincerts
|       |   |-- cacerts
|       |   `-- tlscacerts
|       |-- orderers
|       |   `-- orderer.example.com
|       |-- tlsca
|       |   |-- c0b4dd42bd396d68f468aa07dae8ce944ab2d9832b2593cfafb27e53c69ec5e2_sk
|       |   `-- tlsca.example.com-cert.pem
|       `-- users
|           `-- Admin@example.com
`-- peerOrganizations
    `-- org1.example.com
        |-- ca
        |   |-- 74023bd84cc5e6957f9bc30b3ebcd6c5b7507016721702a014dd640df265b61a_sk
        |   `-- ca.org1.example.com-cert.pem
        |-- msp
        |   |-- admincerts
        |   |-- cacerts
        |   `-- tlscacerts
        |-- peers
        |   `-- peer0.org1.example.com
        |-- tlsca
        |   |-- 71bb82530580707aa20fa5955beab202f266aa4da4b435bef20741ce5e64abb9_sk
        |   `-- tlsca.org1.example.com-cert.pem
        `-- users
            |-- Admin@org1.example.com
            `-- User1@org1.example.com

25 directories, 8 files

```

将 config 和 crypto-config 文件加复制到 ca,orderer,peer,cli 等节点上去。

### 3.5. 清理 Docker 容器

至此所需的证书与创世区块都已生产完毕，fabric-tools 容易完成了它的使命，你可以继续保留或者清理干净。

```

[root@localhost netkiller]# docker-compose -f docker-compose-tools.yml down
Stopping tools ... done
Removing tools ... done
Removing network netkiller_basic

```

清理 tools 容器

```

docker rm -f $(docker ps -qa)

```

## 4. CA 节点安装

CA 节点需要我们之前生成 crypto-config

### 4.1. 安装 Docker 镜像

```

docker pull hyperledger/fabric-ca:x86_64-1.1.0
docker tag hyperledger/fabric-ca:x86_64-1.1.0 hyperledger/fabric-ca			

```

### 4.2. docker-compose-ca.yml

```

version: '3'

networks:
  basic:

services:
  ca.example.com:
    image: hyperledger/fabric-ca
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca.example.com
      - FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem
      - FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/4239aa0dcd76daeeb8ba0cda701851d14504d31aad1b2ddddbac6a57365e497c_sk
    ports:
      - "XXX.XXX.XXX.XXX:7054:7054"
    command: sh -c 'fabric-ca-server start -b admin:adminpw -d'
    volumes:
      - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-config
    container_name: ca.example.com
    networks:
      - basic			

```

### 4.3. 启动 CA 节点

```

docker-compose -f docker-compose-ca.yaml up -d			

```

## 5. CouchDB 节点

整个 Hyperledger Fabric 技术栈中只有这个 CouchDB 是个外来户，看到 CouchDB 我就非常兴奋，这是一个 NoSQL 数据库(它与 MongoDB 十分类似)，所以 CouchDB 100%可以独立运行，且最容易分离。

CouchDB 在这里有两个方案可以选择。

*   采用 Docker 运行 CouchDB 的方案。

*   采用传统方式物理机上本地安装 CouchDB

理论两种方案对实际结果没有什么区别，只需提供 IP 地址，用户名与密码供其他节点访问即可。但实际我们看到 Hyperledger Fabric 使用的镜像是 hyperledger/fabric-couchdb 不清楚是否有修改过 CouchDB 数据库。

如果你对 Docker 比较熟悉就采用 Docker 方案。如果不熟悉就采用本地安装方式。总之选择一种你能 Hold 住（掌控）的方案，一旦出现故障，你能第一时间排查并处理。

### 5.1. 安装 Docker 镜像

```

docker pull hyperledger/fabric-couchdb:x86_64-1.1.0
docker tag hyperledger/fabric-couchdb:x86_64-1.1.0 hyperledger/fabric-couchdb

```

### 5.2. 安装 CouchDB

下面是 Docker 方案

```

[root@localhost netkiller]# vim docker-compose-couchdb.yml

version: '3'

networks:
  basic:

services:
  couchdb:
    container_name: couchdb
    image: hyperledger/fabric-couchdb
    # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password
    # for CouchDB.  This will prevent CouchDB from operating in an "Admin Party" mode.
    environment:
      - COUCHDB_USER=admin
      - COUCHDB_PASSWORD=passw0rd
    ports:
      - 172.16.0.17:5984:5984
    networks:
      - basic

```

### 5.3. 启动 CouchDB

启动 Docker 容器

```

docker-compose -f docker-compose-couchdb.yml up -d		

```

访问 CouchDB 管理界面，http://172.16.0.17:5984/_utils/ 请使用上面设置的密码进入。若想进入到容器内部可以使用下面命令：

```

docker-compose -f docker-compose-couchdb.yml exec couchdb bash	

```

至此 CouchDB 节点部署完毕。

### 5.4. 备份与恢复 CouchDB

既然是运维区块链，对于运维工作我们最关心的就是如何备份数据，在出现故障的时候恢复数据。

```

npm install --save couchdb-backup-restore			

```

```

var cbr = require('couchdb-backup-restore');

var config = {credentials: 'http://localhost:5984'};

function done(err) {
  if (err) {
    return console.error(err);
  }
  console.log('all done!');
}

// backup 
cbr.backup(config, done).pipe(fs.createWriteStream('./db-backup.tar.gz'))

// restore 
fs.createReadStream('./db-backup.tar.gz').pipe(cbr.restore(config, done));

```

## 6. Orderer 节点安装

### 6.1. 安装 Docker 镜像

```

docker pull hyperledger/fabric-orderer:x86_64-1.1.0
docker tag hyperledger/fabric-orderer:x86_64-1.1.0 hyperledger/fabric-orderer			

```

### 6.2. docker-compose-orderer.yml

```

version: '3'

networks:
  basic:

services:
  orderer.example.com:
    container_name: orderer.example.com
    image: hyperledger/fabric-orderer
    environment:
      - ORDERER_GENERAL_LOGLEVEL=debug
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/etc/hyperledger/configtx/genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/etc/hyperledger/msp/orderer/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/orderer
    command: orderer
    ports:
      - 7050:7050
    volumes:
        - ./config/:/etc/hyperledger/configtx
        - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/:/etc/hyperledger/msp/orderer
        - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/:/etc/hyperledger/msp/peerOrg1
    networks:
      - basic			

```

### 6.3. 启动 Orderer 节点

```

docker-compose -f docker-compose-orderer.yaml up -d			

```

## 7. Peer 节点安装

### 7.1. 安装 Docker 镜像

```

docker pull hyperledger/fabric-peer:x86_64-1.1.0
docker tag hyperledger/fabric-peer:x86_64-1.1.0 hyperledger/fabric-peer

```

### 7.2. docker-compose-peer.yml

```

version: '3'

networks:
  basic:

services:

  peer0.org1.example.com:
    container_name: peer0.org1.example.com
    image: hyperledger/fabric-peer
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.org1.example.com
      - CORE_LOGGING_PEER=debug
      - CORE_CHAINCODE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      # # the following setting starts chaincode containers on the same
      # # bridge network as the peers
      # # https://docs.docker.com/compose/networking/
      - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=${COMPOSE_PROJECT_NAME}_basic
      - CORE_LEDGER_STATE_STATEDATABASE=CouchDB
      - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984
      # The CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME and CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD
      # provide the credentials for ledger to connect to CouchDB.  The username and password must
      # match the username and password set for the associated CouchDB.
      - CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin
      - CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=passw0rd
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric
    command: peer node start
    # command: peer node start --peer-chaincodedev=true
    ports:
      - 7051:7051
      - 7053:7053
    volumes:
        - /var/run/:/host/var/run/
        - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/msp/peer
        - ./crypto-config/peerOrganizations/org1.example.com/users:/etc/hyperledger/msp/users
        - ./config:/etc/hyperledger/configtx
    #depends_on:
    #  - orderer.example.com
    #  - couchdb
    networks:
      - basic

```

Peer 需要连接到 CouchDB 注意配置项 CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=172.16.0.17:5984

同时连接 CouchDB 的用户与密码要正确

### 7.3. 启动 Peer 节点

```

[root@localhost netkiller]# docker-compose -f docker-compose-peer.yaml up -d

```

### 7.4. 创建 Channel

进入 Peer 容器

```

docker-compose -f docker-compose-peer.yaml exec peer0.org1.example.com bash

```

添加 Orderer 节点并创建 Channel

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp
peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx

peer channel create -o 172.16.0.17:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx

```

加入到 mychannel

```

CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp
peer channel join -b mychannel.block

```

查看通道

```

st t@f39764f58ff7:/opt/gopath/src/github.com/hyperledger/fabric# peer channel list
2018-02-09 08:12:46.454 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-09 08:12:46.454 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-09 08:12:46.456 UTC [channelCmd] InitCmdFactory -> INFO 003 Endorser and orderer connections initialized
2018-02-09 08:12:46.457 UTC [msp/identity] Sign -> DEBU 004 Sign: plaintext: 0A8A070A5C08031A0C08FEAFF5D30510...631A0D0A0B4765744368616E6E656C73 
2018-02-09 08:12:46.458 UTC [msp/identity] Sign -> DEBU 005 Sign: digest: E27446498819AA4FE8EE835ADEF16195489975377A3C18D89C36D37AA24E5CA2 
2018-02-09 08:12:46.469 UTC [channelCmd] list -> INFO 006 Channels peers has joined to: 
2018-02-09 08:12:46.469 UTC [channelCmd] list -> INFO 007 mychannel 
2018-02-09 08:12:46.469 UTC [main] main -> INFO 008 Exiting.....			

```

## 8. 验收与测试

### 8.1. 准备合约文件

```

[root@localhost netkiller]# cat chaincode/fabcar/fabcar.go 
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * The sample smart contract for documentation topic:
 * Writing Your First Blockchain Application
 */

package main

/* Imports
 * 4 utility libraries for formatting, handling bytes, reading and writing JSON, and string manipulation
 * 2 specific Hyperledger Fabric specific libraries for Smart Contracts
 */
import (
	"bytes"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	sc "github.com/hyperledger/fabric/protos/peer"
)

// Define the Smart Contract structure
type SmartContract struct {
}

// Define the car structure, with 4 properties.  Structure tags are used by encoding/json library
type Car struct {
	Make   string `json:"make"`
	Model  string `json:"model"`
	Colour string `json:"colour"`
	Owner  string `json:"owner"`
}

/*
 * The Init method is called when the Smart Contract "fabcar" is instantiated by the blockchain network
 * Best practice is to have any Ledger initialization in separate function -- see initLedger()
 */
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
	return shim.Success(nil)
}

/*
 * The Invoke method is called as a result of an application request to run the Smart Contract "fabcar"
 * The calling application program has also specified the particular smart contract function to be called, with arguments
 */
func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "queryCar" {
		return s.queryCar(APIstub, args)
	} else if function == "initLedger" {
		return s.initLedger(APIstub)
	} else if function == "createCar" {
		return s.createCar(APIstub, args)
	} else if function == "queryAllCars" {
		return s.queryAllCars(APIstub)
	} else if function == "changeCarOwner" {
		return s.changeCarOwner(APIstub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}

func (s *SmartContract) queryCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	carAsBytes, _ := APIstub.GetState(args[0])
	return shim.Success(carAsBytes)
}

func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response {
	cars := []Car{
		Car{Make: "Toyota", Model: "Prius", Colour: "blue", Owner: "Tomoko"},
		Car{Make: "Ford", Model: "Mustang", Colour: "red", Owner: "Brad"},
		Car{Make: "Hyundai", Model: "Tucson", Colour: "green", Owner: "Jin Soo"},
		Car{Make: "Volkswagen", Model: "Passat", Colour: "yellow", Owner: "Max"},
		Car{Make: "Tesla", Model: "S", Colour: "black", Owner: "Adriana"},
		Car{Make: "Peugeot", Model: "205", Colour: "purple", Owner: "Michel"},
		Car{Make: "Chery", Model: "S22L", Colour: "white", Owner: "Aarav"},
		Car{Make: "Fiat", Model: "Punto", Colour: "violet", Owner: "Pari"},
		Car{Make: "Tata", Model: "Nano", Colour: "indigo", Owner: "Valeria"},
		Car{Make: "Holden", Model: "Barina", Colour: "brown", Owner: "Shotaro"},
	}

	i := 0
	for i < len(cars) {
		fmt.Println("i is ", i)
		carAsBytes, _ := json.Marshal(cars[i])
		APIstub.PutState("CAR"+strconv.Itoa(i), carAsBytes)
		fmt.Println("Added", cars[i])
		i = i + 1
	}

	return shim.Success(nil)
}

func (s *SmartContract) createCar(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 5 {
		return shim.Error("Incorrect number of arguments. Expecting 5")
	}

	var car = Car{Make: args[1], Model: args[2], Colour: args[3], Owner: args[4]}

	carAsBytes, _ := json.Marshal(car)
	APIstub.PutState(args[0], carAsBytes)

	return shim.Success(nil)
}

func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "CAR0"
	endKey := "CAR999"

	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return shim.Error(err.Error())
		}
		// Add a comma before array members, suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- queryAllCars:\n%s\n", buffer.String())

	return shim.Success(buffer.Bytes())
}

func (s *SmartContract) changeCarOwner(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	carAsBytes, _ := APIstub.GetState(args[0])
	car := Car{}

	json.Unmarshal(carAsBytes, &car)
	car.Owner = args[1]

	carAsBytes, _ = json.Marshal(car)
	APIstub.PutState(args[0], carAsBytes)

	return shim.Success(nil)
}

// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}

```

### 8.2. 安装 chaincode

安装合约在 tools 节点上进行。

```

docker-compose -f docker-compose-cli.yaml exec cli bash

CORE_PEER_ADDRESS=172.16.0.17:7051
CORE_PEER_LOCALMSPID=Org1MSP
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp

peer chaincode install -n fabcar -v 1.0 -p github.com/fabcar	
peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n fabcar -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"
peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n fabcar -c '{"function":"initLedger","Args":[""]}'

```

```

root@a90d0d869dd3:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n fabcar -v 1.0 -p github.com/fabcar	
2018-02-09 11:26:28.025 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-09 11:26:28.025 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-09 11:26:28.025 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-09 11:26:28.025 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-09 11:26:28.139 UTC [golang-platform] getCodeFromFS -> DEBU 005 getCodeFromFS github.com/fabcar
2018-02-09 11:26:29.394 UTC [golang-platform] func1 -> DEBU 006 Discarding GOROOT package bytes
2018-02-09 11:26:29.395 UTC [golang-platform] func1 -> DEBU 007 Discarding GOROOT package encoding/json
2018-02-09 11:26:29.395 UTC [golang-platform] func1 -> DEBU 008 Discarding GOROOT package fmt
2018-02-09 11:26:29.395 UTC [golang-platform] func1 -> DEBU 009 Discarding provided package github.com/hyperledger/fabric/core/chaincode/shim
2018-02-09 11:26:29.395 UTC [golang-platform] func1 -> DEBU 00a Discarding provided package github.com/hyperledger/fabric/protos/peer
2018-02-09 11:26:29.395 UTC [golang-platform] func1 -> DEBU 00b Discarding GOROOT package strconv
2018-02-09 11:26:29.396 UTC [golang-platform] GetDeploymentPayload -> DEBU 00c done
2018-02-09 11:26:29.406 UTC [msp/identity] Sign -> DEBU 00d Sign: plaintext: 0A8A070A5C08031A0C08E58AF6D30510...939FFF060000FFFF9C08DC0700200000 
2018-02-09 11:26:29.406 UTC [msp/identity] Sign -> DEBU 00e Sign: digest: A504EE8048EEE8C77F9E1C39827124474638110FD3980017BCA6D644E3E7EC98 
2018-02-09 11:26:29.426 UTC [chaincodeCmd] install -> DEBU 00f Installed remotely response:<status:200 payload:"OK" > 
2018-02-09 11:26:29.427 UTC [main] main -> INFO 010 Exiting.....			

```

```

peer chaincode instantiate -o 172.16.0.17:7050 -C mychannel -n fabcar -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"			

```

## 9. 总结

## 第 26 章 Chaincode 链码（智能合约）

## 1. 链码开发与测试

### 1.1. Docker 开发环境

环境安装

安装 fabric-samples

```

git clone https://github.com/hyperledger/fabric-samples.git
cd fabric-samples

```

```

[root@localhost ~]# cd fabric-samples/chaincode-docker-devmode/
[root@localhost chaincode-docker-devmode]# mkdir chaincode
[root@localhost chaincode-docker-devmode]# cp docker-compose-simple.yaml docker-compose.yaml
[root@localhost chaincode-docker-devmode]# sed -i "s|./../chaincode|./chaincode|g" docker-compose.yaml

```

chaincode 目录是开发目录

清理镜像和容器

```

docker rm -f $(docker ps -q -a)
docker rmi -f $(docker images -q)

```

安装所需镜像

```

[root@localhost chaincode-docker-devmode]# curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/hyperledger/fabric/1.1.0/all-in-one.sh | bash		

[root@localhost chaincode-docker-devmode]# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
hyperledger/fabric-tools     latest              6a8993b718c8        2 months ago        1.33GB
hyperledger/fabric-tools     x86_64-1.1.0        6a8993b718c8        2 months ago        1.33GB
hyperledger/fabric-couchdb   latest              9a58db2d2723        2 months ago        1.5GB
hyperledger/fabric-couchdb   x86_64-1.1.0        9a58db2d2723        2 months ago        1.5GB
hyperledger/fabric-orderer   latest              368c78b6f03b        2 months ago        151MB
hyperledger/fabric-orderer   x86_64-1.1.0        368c78b6f03b        2 months ago        151MB
hyperledger/fabric-peer      latest              c2ab022f0bdb        2 months ago        154MB
hyperledger/fabric-peer      x86_64-1.1.0        c2ab022f0bdb        2 months ago        154MB
hyperledger/fabric-ccenv     latest              33feadb8f7a6        2 months ago        1.28GB
hyperledger/fabric-ccenv     x86_64-1.1.0        33feadb8f7a6        2 months ago        1.28GB
hyperledger/fabric-ca        latest              002c9089e464        2 months ago        238MB
hyperledger/fabric-ca        x86_64-1.1.0        002c9089e464        2 months ago        238MB		

```

### 1.2. chaincode 代码

```

[root@localhost chaincode-docker-devmode]# cat chaincode/chaincode_example02.go 
/*
Copyright IBM Corp. 2016 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

//WARNING - this chaincode's ID is hard-coded in chaincode_example04 to illustrate one way of
//calling chaincode from a chaincode. If this example is modified, chaincode_example04.go has
//to be modified as well with the new ID of chaincode_example02.
//chaincode_example05 show's how chaincode ID can be passed in as a parameter instead of
//hard-coding.

import (
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

// SimpleChaincode example simple Chaincode implementation
type SimpleChaincode struct {
}

func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
	fmt.Println("ex02 Init")
	_, args := stub.GetFunctionAndParameters()
	var A, B string    // Entities
	var Aval, Bval int // Asset holdings
	var err error

	if len(args) != 4 {
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}

	// Initialize the chaincode
	A = args[0]
	Aval, err = strconv.Atoi(args[1])
	if err != nil {
		return shim.Error("Expecting integer value for asset holding")
	}
	B = args[2]
	Bval, err = strconv.Atoi(args[3])
	if err != nil {
		return shim.Error("Expecting integer value for asset holding")
	}
	fmt.Printf("Aval = %d, Bval = %d\n", Aval, Bval)

	// Write the state to the ledger
	err = stub.PutState(A, []byte(strconv.Itoa(Aval)))
	if err != nil {
		return shim.Error(err.Error())
	}

	err = stub.PutState(B, []byte(strconv.Itoa(Bval)))
	if err != nil {
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
	fmt.Println("ex02 Invoke")
	function, args := stub.GetFunctionAndParameters()
	if function == "invoke" {
		// Make payment of X units from A to B
		return t.invoke(stub, args)
	} else if function == "delete" {
		// Deletes an entity from its state
		return t.delete(stub, args)
	} else if function == "query" {
		// the old "Query" is now implemtned in invoke
		return t.query(stub, args)
	}

	return shim.Error("Invalid invoke function name. Expecting \"invoke\" \"delete\" \"query\"")
}

// Transaction makes payment of X units from A to B
func (t *SimpleChaincode) invoke(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var A, B string    // Entities
	var Aval, Bval int // Asset holdings
	var X int          // Transaction value
	var err error

	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}

	A = args[0]
	B = args[1]

	// Get the state from the ledger
	// TODO: will be nice to have a GetAllState call to ledger
	Avalbytes, err := stub.GetState(A)
	if err != nil {
		return shim.Error("Failed to get state")
	}
	if Avalbytes == nil {
		return shim.Error("Entity not found")
	}
	Aval, _ = strconv.Atoi(string(Avalbytes))

	Bvalbytes, err := stub.GetState(B)
	if err != nil {
		return shim.Error("Failed to get state")
	}
	if Bvalbytes == nil {
		return shim.Error("Entity not found")
	}
	Bval, _ = strconv.Atoi(string(Bvalbytes))

	// Perform the execution
	X, err = strconv.Atoi(args[2])
	if err != nil {
		return shim.Error("Invalid transaction amount, expecting a integer value")
	}
	Aval = Aval - X
	Bval = Bval + X
	fmt.Printf("Aval = %d, Bval = %d\n", Aval, Bval)

	// Write the state back to the ledger
	err = stub.PutState(A, []byte(strconv.Itoa(Aval)))
	if err != nil {
		return shim.Error(err.Error())
	}

	err = stub.PutState(B, []byte(strconv.Itoa(Bval)))
	if err != nil {
		return shim.Error(err.Error())
	}

	return shim.Success(nil)
}

// Deletes an entity from state
func (t *SimpleChaincode) delete(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	A := args[0]

	// Delete the key from the state in ledger
	err := stub.DelState(A)
	if err != nil {
		return shim.Error("Failed to delete state")
	}

	return shim.Success(nil)
}

// query callback representing the query of a chaincode
func (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	var A string // Entities
	var err error

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting name of the person to query")
	}

	A = args[0]

	// Get the state from the ledger
	Avalbytes, err := stub.GetState(A)
	if err != nil {
		jsonResp := "{\"Error\":\"Failed to get state for " + A + "\"}"
		return shim.Error(jsonResp)
	}

	if Avalbytes == nil {
		jsonResp := "{\"Error\":\"Nil amount for " + A + "\"}"
		return shim.Error(jsonResp)
	}

	jsonResp := "{\"Name\":\"" + A + "\",\"Amount\":\"" + string(Avalbytes) + "\"}"
	fmt.Printf("Query Response:%s\n", jsonResp)
	return shim.Success(Avalbytes)
}

func main() {
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Printf("Error starting Simple chaincode: %s", err)
	}
}

```

### 1.3. 启动容器部署 chaincode

```

[root@localhost chaincode-docker-devmode]# docker-compose up -d

```

进入容器

```

[root@localhost ~]# docker exec -it chaincode bash
root@78d23b3b2b37:/opt/gopath/src/chaincode# 		

```

编译并部署 chaincode

```

root@78d23b3b2b37:/opt/gopath/src/chaincode# ls
chaincode_example02.go
root@78d23b3b2b37:/opt/gopath/src/chaincode# go build chaincode_example02.go 
root@78d23b3b2b37:/opt/gopath/src/chaincode# 		

```

进入 chaincode 容器启动 chaincode 程序。

```

[root@localhost ~]# docker exec -it chaincode bash
root@78d23b3b2b37:/opt/gopath/src/chaincode# ls
chaincode_example02.go
root@78d23b3b2b37:/opt/gopath/src/chaincode# go build chaincode_example02.go 
root@78d23b3b2b37:/opt/gopath/src/chaincode# CORE_PEER_ADDRESS=peer:7051 CORE_CHAINCODE_ID_NAME=chaincode_example02:1.0 ./chaincode_example02 
2018-02-17 04:07:31.156 UTC [shim] SetupChaincodeLogging -> INFO 001 Chaincode log level not provided; defaulting to: INFO
2018-02-17 04:07:31.156 UTC [shim] SetupChaincodeLogging -> INFO 002 Chaincode (build level: ) starting up ...		

```

CORE_CHAINCODE_ID_NAME=chaincode_example02:1.0 记住这里的配置，下面会用到

### 1.4. 手工测试

进入 cli 容器

```

[root@localhost ~]# docker exec -it cli bash
root@33dcacfb6f81:/opt/gopath/src/chaincodedev#		

```

```

root@33dcacfb6f81:/opt/gopath/src/chaincodedev# peer chaincode install -v 1.0 -n chaincode_example02 -p chaincodedev/chaincode	
2018-02-17 04:46:23.871 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-17 04:46:23.871 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-17 04:46:23.872 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-17 04:46:23.872 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-17 04:46:23.986 UTC [golang-platform] getCodeFromFS -> DEBU 005 getCodeFromFS chaincodedev/chaincode
2018-02-17 04:46:24.280 UTC [golang-platform] func1 -> DEBU 006 Discarding GOROOT package fmt
2018-02-17 04:46:24.281 UTC [golang-platform] func1 -> DEBU 007 Discarding provided package github.com/hyperledger/fabric/core/chaincode/shim
2018-02-17 04:46:24.281 UTC [golang-platform] func1 -> DEBU 008 Discarding provided package github.com/hyperledger/fabric/protos/peer
2018-02-17 04:46:24.281 UTC [golang-platform] func1 -> DEBU 009 Discarding GOROOT package strconv
2018-02-17 04:46:24.281 UTC [golang-platform] GetDeploymentPayload -> DEBU 00a done
2018-02-17 04:46:24.287 UTC [msp/identity] Sign -> DEBU 00b Sign: plaintext: 0AA4080A5C08031A0C08A0E79ED40510...0F19FF0E0000FFFFBA10C104001C0000 
2018-02-17 04:46:24.287 UTC [msp/identity] Sign -> DEBU 00c Sign: digest: BE51F2BBE156552DDF4CCBA3E01F890921FB965463683B0B636DAC53BAF2E7C4 
2018-02-17 04:46:24.299 UTC [chaincodeCmd] install -> DEBU 00d Installed remotely response:<status:200 payload:"OK" > 
2018-02-17 04:46:24.299 UTC [main] main -> INFO 00e Exiting.....		

```

```

root@33dcacfb6f81:/opt/gopath/src/chaincodedev# peer chaincode instantiate -C myc -n chaincode_example02 -v 1.0 -c '{"Args":["init","a","100","b","200"]}'  
2018-02-17 04:52:42.395 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-17 04:52:42.396 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-17 04:52:42.396 UTC [msp/identity] Sign -> DEBU 003 Sign: plaintext: 0AA4080A5C08011A0C089AEA9ED40510...436F6E666967426C6F636B0A036D7963 
2018-02-17 04:52:42.396 UTC [msp/identity] Sign -> DEBU 004 Sign: digest: B2BE9C220FB3313901DBAAE578F428FB98B950ACB5E7519DBC5150D2D21562CB 
2018-02-17 04:52:42.413 UTC [common/config] NewStandardValues -> DEBU 005 Initializing protos for *config.ChannelProtos
2018-02-17 04:52:42.414 UTC [common/config] initializeProtosStruct -> DEBU 006 Processing field: HashingAlgorithm
2018-02-17 04:52:42.414 UTC [common/config] initializeProtosStruct -> DEBU 007 Processing field: BlockDataHashingStructure
2018-02-17 04:52:42.414 UTC [common/config] initializeProtosStruct -> DEBU 008 Processing field: OrdererAddresses
2018-02-17 04:52:42.414 UTC [common/config] initializeProtosStruct -> DEBU 009 Processing field: Consortium
2018-02-17 04:52:42.415 UTC [common/configtx] addToMap -> DEBU 00a Adding to config map: [Groups] /Channel
2018-02-17 04:52:42.415 UTC [common/configtx] addToMap -> DEBU 00b Adding to config map: [Groups] /Channel/Orderer
2018-02-17 04:52:42.415 UTC [common/configtx] addToMap -> DEBU 00c Adding to config map: [Groups] /Channel/Orderer/SampleOrg
2018-02-17 04:52:42.415 UTC [common/configtx] addToMap -> DEBU 00d Adding to config map: [Values] /Channel/Orderer/SampleOrg/MSP
2018-02-17 04:52:42.415 UTC [common/configtx] addToMap -> DEBU 00e Adding to config map: [Policy] /Channel/Orderer/SampleOrg/Admins
2018-02-17 04:52:42.416 UTC [common/configtx] addToMap -> DEBU 00f Adding to config map: [Policy] /Channel/Orderer/SampleOrg/Readers
2018-02-17 04:52:42.416 UTC [common/configtx] addToMap -> DEBU 010 Adding to config map: [Policy] /Channel/Orderer/SampleOrg/Writers
2018-02-17 04:52:42.416 UTC [common/configtx] addToMap -> DEBU 011 Adding to config map: [Values] /Channel/Orderer/BatchSize
2018-02-17 04:52:42.416 UTC [common/configtx] addToMap -> DEBU 012 Adding to config map: [Values] /Channel/Orderer/BatchTimeout
2018-02-17 04:52:42.416 UTC [common/configtx] addToMap -> DEBU 013 Adding to config map: [Values] /Channel/Orderer/ChannelRestrictions
2018-02-17 04:52:42.417 UTC [common/configtx] addToMap -> DEBU 014 Adding to config map: [Values] /Channel/Orderer/ConsensusType
2018-02-17 04:52:42.418 UTC [common/configtx] addToMap -> DEBU 015 Adding to config map: [Policy] /Channel/Orderer/Admins
2018-02-17 04:52:42.419 UTC [common/configtx] addToMap -> DEBU 016 Adding to config map: [Policy] /Channel/Orderer/BlockValidation
2018-02-17 04:52:42.419 UTC [common/configtx] addToMap -> DEBU 017 Adding to config map: [Policy] /Channel/Orderer/Readers
2018-02-17 04:52:42.419 UTC [common/configtx] addToMap -> DEBU 018 Adding to config map: [Policy] /Channel/Orderer/Writers
2018-02-17 04:52:42.419 UTC [common/configtx] addToMap -> DEBU 019 Adding to config map: [Groups] /Channel/Application
2018-02-17 04:52:42.420 UTC [common/configtx] addToMap -> DEBU 01a Adding to config map: [Groups] /Channel/Application/SampleOrg
2018-02-17 04:52:42.420 UTC [common/configtx] addToMap -> DEBU 01b Adding to config map: [Values] /Channel/Application/SampleOrg/MSP
2018-02-17 04:52:42.422 UTC [common/configtx] addToMap -> DEBU 01c Adding to config map: [Policy] /Channel/Application/SampleOrg/Readers
2018-02-17 04:52:42.422 UTC [common/configtx] addToMap -> DEBU 01d Adding to config map: [Policy] /Channel/Application/SampleOrg/Writers
2018-02-17 04:52:42.422 UTC [common/configtx] addToMap -> DEBU 01e Adding to config map: [Policy] /Channel/Application/SampleOrg/Admins
2018-02-17 04:52:42.422 UTC [common/configtx] addToMap -> DEBU 01f Adding to config map: [Policy] /Channel/Application/Writers
2018-02-17 04:52:42.423 UTC [common/configtx] addToMap -> DEBU 020 Adding to config map: [Policy] /Channel/Application/Readers
2018-02-17 04:52:42.423 UTC [common/configtx] addToMap -> DEBU 021 Adding to config map: [Policy] /Channel/Application/Admins
2018-02-17 04:52:42.423 UTC [common/configtx] addToMap -> DEBU 022 Adding to config map: [Values] /Channel/Consortium
2018-02-17 04:52:42.423 UTC [common/configtx] addToMap -> DEBU 023 Adding to config map: [Values] /Channel/OrdererAddresses
2018-02-17 04:52:42.423 UTC [common/configtx] addToMap -> DEBU 024 Adding to config map: [Values] /Channel/HashingAlgorithm
2018-02-17 04:52:42.424 UTC [common/configtx] addToMap -> DEBU 025 Adding to config map: [Values] /Channel/BlockDataHashingStructure
2018-02-17 04:52:42.424 UTC [common/configtx] addToMap -> DEBU 026 Adding to config map: [Policy] /Channel/Readers
2018-02-17 04:52:42.424 UTC [common/configtx] addToMap -> DEBU 027 Adding to config map: [Policy] /Channel/Writers
2018-02-17 04:52:42.424 UTC [common/configtx] addToMap -> DEBU 028 Adding to config map: [Policy] /Channel/Admins
2018-02-17 04:52:42.424 UTC [common/configtx] processConfig -> DEBU 029 Beginning new config for channel myc
2018-02-17 04:52:42.425 UTC [common/config] NewStandardValues -> DEBU 02a Initializing protos for *config.ChannelProtos
2018-02-17 04:52:42.425 UTC [common/config] initializeProtosStruct -> DEBU 02b Processing field: HashingAlgorithm
2018-02-17 04:52:42.425 UTC [common/config] initializeProtosStruct -> DEBU 02c Processing field: BlockDataHashingStructure
2018-02-17 04:52:42.425 UTC [common/config] initializeProtosStruct -> DEBU 02d Processing field: OrdererAddresses
2018-02-17 04:52:42.425 UTC [common/config] initializeProtosStruct -> DEBU 02e Processing field: Consortium
2018-02-17 04:52:42.425 UTC [policies] ProposePolicy -> DEBU 02f Proposed new policy Readers for Channel
2018-02-17 04:52:42.425 UTC [policies] ProposePolicy -> DEBU 030 Proposed new policy Writers for Channel
2018-02-17 04:52:42.426 UTC [policies] ProposePolicy -> DEBU 031 Proposed new policy Admins for Channel
2018-02-17 04:52:42.426 UTC [common/config] NewStandardValues -> DEBU 032 Initializing protos for *config.OrdererProtos
2018-02-17 04:52:42.426 UTC [common/config] initializeProtosStruct -> DEBU 033 Processing field: ConsensusType
2018-02-17 04:52:42.426 UTC [common/config] initializeProtosStruct -> DEBU 034 Processing field: BatchSize
2018-02-17 04:52:42.426 UTC [common/config] initializeProtosStruct -> DEBU 035 Processing field: BatchTimeout
2018-02-17 04:52:42.426 UTC [common/config] initializeProtosStruct -> DEBU 036 Processing field: KafkaBrokers
2018-02-17 04:52:42.426 UTC [common/config] initializeProtosStruct -> DEBU 037 Processing field: ChannelRestrictions
2018-02-17 04:52:42.426 UTC [policies] ProposePolicy -> DEBU 038 Proposed new policy Readers for Orderer
2018-02-17 04:52:42.426 UTC [policies] ProposePolicy -> DEBU 039 Proposed new policy Writers for Orderer
2018-02-17 04:52:42.426 UTC [policies] ProposePolicy -> DEBU 03a Proposed new policy Admins for Orderer
2018-02-17 04:52:42.426 UTC [policies] ProposePolicy -> DEBU 03b Proposed new policy BlockValidation for Orderer
2018-02-17 04:52:42.426 UTC [common/config] NewStandardValues -> DEBU 03c Initializing protos for *config.OrganizationProtos
2018-02-17 04:52:42.426 UTC [common/config] initializeProtosStruct -> DEBU 03d Processing field: MSP
2018-02-17 04:52:42.427 UTC [policies] ProposePolicy -> DEBU 03e Proposed new policy Admins for SampleOrg
2018-02-17 04:52:42.427 UTC [policies] ProposePolicy -> DEBU 03f Proposed new policy Readers for SampleOrg
2018-02-17 04:52:42.427 UTC [policies] ProposePolicy -> DEBU 040 Proposed new policy Writers for SampleOrg
2018-02-17 04:52:42.427 UTC [common/config] NewStandardValues -> DEBU 041 Initializing protos for *struct {}
2018-02-17 04:52:42.427 UTC [policies] ProposePolicy -> DEBU 042 Proposed new policy Admins for Application
2018-02-17 04:52:42.427 UTC [policies] ProposePolicy -> DEBU 043 Proposed new policy Writers for Application
2018-02-17 04:52:42.427 UTC [policies] ProposePolicy -> DEBU 044 Proposed new policy Readers for Application
2018-02-17 04:52:42.427 UTC [common/config] NewStandardValues -> DEBU 045 Initializing protos for *config.OrganizationProtos
2018-02-17 04:52:42.427 UTC [common/config] initializeProtosStruct -> DEBU 046 Processing field: MSP
2018-02-17 04:52:42.427 UTC [common/config] NewStandardValues -> DEBU 047 Initializing protos for *config.ApplicationOrgProtos
2018-02-17 04:52:42.427 UTC [common/config] initializeProtosStruct -> DEBU 048 Processing field: AnchorPeers
2018-02-17 04:52:42.427 UTC [common/config] NewStandardValues -> DEBU 049 Initializing protos for *config.OrganizationProtos
2018-02-17 04:52:42.428 UTC [common/config] initializeProtosStruct -> DEBU 04a Processing field: MSP
2018-02-17 04:52:42.428 UTC [policies] ProposePolicy -> DEBU 04b Proposed new policy Readers for SampleOrg
2018-02-17 04:52:42.428 UTC [policies] ProposePolicy -> DEBU 04c Proposed new policy Writers for SampleOrg
2018-02-17 04:52:42.428 UTC [policies] ProposePolicy -> DEBU 04d Proposed new policy Admins for SampleOrg
2018-02-17 04:52:42.428 UTC [common/config] validateMSP -> DEBU 04e Setting up MSP for org SampleOrg
2018-02-17 04:52:42.428 UTC [msp] NewBccspMsp -> DEBU 04f Creating BCCSP-based MSP instance
2018-02-17 04:52:42.428 UTC [msp] Setup -> DEBU 050 Setting up MSP instance DEFAULT
2018-02-17 04:52:42.429 UTC [msp/identity] newIdentity -> DEBU 051 Creating identity instance for ID -----BEGIN CERTIFICATE-----
MIICYjCCAgmgAwIBAgIUB3CTDOU47sUC5K4kn/Caqnh114YwCgYIKoZIzj0EAwIw
fzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xHzAdBgNVBAoTFkludGVybmV0IFdpZGdldHMsIEluYy4xDDAK
BgNVBAsTA1dXVzEUMBIGA1UEAxMLZXhhbXBsZS5jb20wHhcNMTYxMDEyMTkzMTAw
WhcNMjExMDExMTkzMTAwWjB/MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZv
cm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEfMB0GA1UEChMWSW50ZXJuZXQg
V2lkZ2V0cywgSW5jLjEMMAoGA1UECxMDV1dXMRQwEgYDVQQDEwtleGFtcGxlLmNv
bTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABKIH5b2JaSmqiQXHyqC+cmknICcF
i5AddVjsQizDV6uZ4v6s+PWiJyzfA/rTtMvYAPq/yeEHpBUB1j053mxnpMujYzBh
MA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQXZ0I9
qp6CP8TFHZ9bw5nRtZxIEDAfBgNVHSMEGDAWgBQXZ0I9qp6CP8TFHZ9bw5nRtZxI
EDAKBggqhkjOPQQDAgNHADBEAiAHp5Rbp9Em1G/UmKn8WsCbqDfWecVbZPQj3RK4
oG5kQQIgQAe4OOKYhJdh3f7URaKfGTf492/nmRmtK+ySKjpHSrU=
-----END CERTIFICATE-----
2018-02-17 04:52:42.430 UTC [msp/identity] newIdentity -> DEBU 052 Creating identity instance for ID -----BEGIN CERTIFICATE-----
MIICjDCCAjKgAwIBAgIUBEVwsSx0TmqdbzNwleNBBzoIT0wwCgYIKoZIzj0EAwIw
fzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xHzAdBgNVBAoTFkludGVybmV0IFdpZGdldHMsIEluYy4xDDAK
BgNVBAsTA1dXVzEUMBIGA1UEAxMLZXhhbXBsZS5jb20wHhcNMTYxMTExMTcwNzAw
WhcNMTcxMTExMTcwNzAwWjBjMQswCQYDVQQGEwJVUzEXMBUGA1UECBMOTm9ydGgg
Q2Fyb2xpbmExEDAOBgNVBAcTB1JhbGVpZ2gxGzAZBgNVBAoTEkh5cGVybGVkZ2Vy
IEZhYnJpYzEMMAoGA1UECxMDQ09QMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
HBuKsAO43hs4JGpFfiGMkB/xsILTsOvmN2WmwpsPHZNL6w8HWe3xCPQtdG/XJJvZ
+C756KEsUBM3yw5PTfku8qOBpzCBpDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYw
FAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFOFC
dcUZ4es3ltiCgAVDoyLfVpPIMB8GA1UdIwQYMBaAFBdnQj2qnoI/xMUdn1vDmdG1
nEgQMCUGA1UdEQQeMByCCm15aG9zdC5jb22CDnd3dy5teWhvc3QuY29tMAoGCCqG
SM49BAMCA0gAMEUCIDf9Hbl4xn3z4EwNKmilM9lX2Fq4jWpAaRVB97OmVEeyAiEA
25aDPQHGGq2AvhKT0wvt08cX1GTGCIbfmuLpMwKQj38=
-----END CERTIFICATE-----
2018-02-17 04:52:42.432 UTC [msp/identity] newIdentity -> DEBU 053 Creating identity instance for ID -----BEGIN CERTIFICATE-----
MIICjDCCAjKgAwIBAgIUBEVwsSx0TmqdbzNwleNBBzoIT0wwCgYIKoZIzj0EAwIw
fzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xHzAdBgNVBAoTFkludGVybmV0IFdpZGdldHMsIEluYy4xDDAK
BgNVBAsTA1dXVzEUMBIGA1UEAxMLZXhhbXBsZS5jb20wHhcNMTYxMTExMTcwNzAw
WhcNMTcxMTExMTcwNzAwWjBjMQswCQYDVQQGEwJVUzEXMBUGA1UECBMOTm9ydGgg
Q2Fyb2xpbmExEDAOBgNVBAcTB1JhbGVpZ2gxGzAZBgNVBAoTEkh5cGVybGVkZ2Vy
IEZhYnJpYzEMMAoGA1UECxMDQ09QMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
HBuKsAO43hs4JGpFfiGMkB/xsILTsOvmN2WmwpsPHZNL6w8HWe3xCPQtdG/XJJvZ
+C756KEsUBM3yw5PTfku8qOBpzCBpDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYw
FAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFOFC
dcUZ4es3ltiCgAVDoyLfVpPIMB8GA1UdIwQYMBaAFBdnQj2qnoI/xMUdn1vDmdG1
nEgQMCUGA1UdEQQeMByCCm15aG9zdC5jb22CDnd3dy5teWhvc3QuY29tMAoGCCqG
SM49BAMCA0gAMEUCIDf9Hbl4xn3z4EwNKmilM9lX2Fq4jWpAaRVB97OmVEeyAiEA
25aDPQHGGq2AvhKT0wvt08cX1GTGCIbfmuLpMwKQj38=
-----END CERTIFICATE-----
2018-02-17 04:52:42.435 UTC [msp] Validate -> DEBU 054 MSP DEFAULT validating identity
2018-02-17 04:52:42.435 UTC [msp] getCertificationChain -> DEBU 055 MSP DEFAULT getting certification chain
2018-02-17 04:52:42.436 UTC [common/config] Validate -> DEBU 056 Anchor peers for org SampleOrg are 
2018-02-17 04:52:42.436 UTC [common/config] validateMSP -> DEBU 057 Setting up MSP for org SampleOrg
2018-02-17 04:52:42.436 UTC [msp] NewBccspMsp -> DEBU 058 Creating BCCSP-based MSP instance
2018-02-17 04:52:42.436 UTC [msp] Setup -> DEBU 059 Setting up MSP instance DEFAULT
2018-02-17 04:52:42.437 UTC [msp/identity] newIdentity -> DEBU 05a Creating identity instance for ID -----BEGIN CERTIFICATE-----
MIICYjCCAgmgAwIBAgIUB3CTDOU47sUC5K4kn/Caqnh114YwCgYIKoZIzj0EAwIw
fzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xHzAdBgNVBAoTFkludGVybmV0IFdpZGdldHMsIEluYy4xDDAK
BgNVBAsTA1dXVzEUMBIGA1UEAxMLZXhhbXBsZS5jb20wHhcNMTYxMDEyMTkzMTAw
WhcNMjExMDExMTkzMTAwWjB/MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZv
cm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEfMB0GA1UEChMWSW50ZXJuZXQg
V2lkZ2V0cywgSW5jLjEMMAoGA1UECxMDV1dXMRQwEgYDVQQDEwtleGFtcGxlLmNv
bTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABKIH5b2JaSmqiQXHyqC+cmknICcF
i5AddVjsQizDV6uZ4v6s+PWiJyzfA/rTtMvYAPq/yeEHpBUB1j053mxnpMujYzBh
MA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQXZ0I9
qp6CP8TFHZ9bw5nRtZxIEDAfBgNVHSMEGDAWgBQXZ0I9qp6CP8TFHZ9bw5nRtZxI
EDAKBggqhkjOPQQDAgNHADBEAiAHp5Rbp9Em1G/UmKn8WsCbqDfWecVbZPQj3RK4
oG5kQQIgQAe4OOKYhJdh3f7URaKfGTf492/nmRmtK+ySKjpHSrU=
-----END CERTIFICATE-----
2018-02-17 04:52:42.438 UTC [msp/identity] newIdentity -> DEBU 05b Creating identity instance for ID -----BEGIN CERTIFICATE-----
MIICjDCCAjKgAwIBAgIUBEVwsSx0TmqdbzNwleNBBzoIT0wwCgYIKoZIzj0EAwIw
fzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xHzAdBgNVBAoTFkludGVybmV0IFdpZGdldHMsIEluYy4xDDAK
BgNVBAsTA1dXVzEUMBIGA1UEAxMLZXhhbXBsZS5jb20wHhcNMTYxMTExMTcwNzAw
WhcNMTcxMTExMTcwNzAwWjBjMQswCQYDVQQGEwJVUzEXMBUGA1UECBMOTm9ydGgg
Q2Fyb2xpbmExEDAOBgNVBAcTB1JhbGVpZ2gxGzAZBgNVBAoTEkh5cGVybGVkZ2Vy
IEZhYnJpYzEMMAoGA1UECxMDQ09QMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
HBuKsAO43hs4JGpFfiGMkB/xsILTsOvmN2WmwpsPHZNL6w8HWe3xCPQtdG/XJJvZ
+C756KEsUBM3yw5PTfku8qOBpzCBpDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYw
FAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFOFC
dcUZ4es3ltiCgAVDoyLfVpPIMB8GA1UdIwQYMBaAFBdnQj2qnoI/xMUdn1vDmdG1
nEgQMCUGA1UdEQQeMByCCm15aG9zdC5jb22CDnd3dy5teWhvc3QuY29tMAoGCCqG
SM49BAMCA0gAMEUCIDf9Hbl4xn3z4EwNKmilM9lX2Fq4jWpAaRVB97OmVEeyAiEA
25aDPQHGGq2AvhKT0wvt08cX1GTGCIbfmuLpMwKQj38=
-----END CERTIFICATE-----
2018-02-17 04:52:42.439 UTC [msp/identity] newIdentity -> DEBU 05c Creating identity instance for ID -----BEGIN CERTIFICATE-----
MIICjDCCAjKgAwIBAgIUBEVwsSx0TmqdbzNwleNBBzoIT0wwCgYIKoZIzj0EAwIw
fzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh
biBGcmFuY2lzY28xHzAdBgNVBAoTFkludGVybmV0IFdpZGdldHMsIEluYy4xDDAK
BgNVBAsTA1dXVzEUMBIGA1UEAxMLZXhhbXBsZS5jb20wHhcNMTYxMTExMTcwNzAw
WhcNMTcxMTExMTcwNzAwWjBjMQswCQYDVQQGEwJVUzEXMBUGA1UECBMOTm9ydGgg
Q2Fyb2xpbmExEDAOBgNVBAcTB1JhbGVpZ2gxGzAZBgNVBAoTEkh5cGVybGVkZ2Vy
IEZhYnJpYzEMMAoGA1UECxMDQ09QMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE
HBuKsAO43hs4JGpFfiGMkB/xsILTsOvmN2WmwpsPHZNL6w8HWe3xCPQtdG/XJJvZ
+C756KEsUBM3yw5PTfku8qOBpzCBpDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYw
FAYIKwYBBQUHAwEGCCsGAQUFBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFOFC
dcUZ4es3ltiCgAVDoyLfVpPIMB8GA1UdIwQYMBaAFBdnQj2qnoI/xMUdn1vDmdG1
nEgQMCUGA1UdEQQeMByCCm15aG9zdC5jb22CDnd3dy5teWhvc3QuY29tMAoGCCqG
SM49BAMCA0gAMEUCIDf9Hbl4xn3z4EwNKmilM9lX2Fq4jWpAaRVB97OmVEeyAiEA
25aDPQHGGq2AvhKT0wvt08cX1GTGCIbfmuLpMwKQj38=
-----END CERTIFICATE-----
2018-02-17 04:52:42.442 UTC [msp] Validate -> DEBU 05d MSP DEFAULT validating identity
2018-02-17 04:52:42.443 UTC [msp] getCertificationChain -> DEBU 05e MSP DEFAULT getting certification chain
2018-02-17 04:52:42.444 UTC [msp] Setup -> DEBU 05f Setting up the MSP manager (1 msps)
2018-02-17 04:52:42.444 UTC [msp] Setup -> DEBU 060 MSP manager setup complete, setup 1 msps
2018-02-17 04:52:42.444 UTC [policies] GetPolicy -> DEBU 061 Returning policy Admins for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 062 In commit adding relative sub-policy SampleOrg/Admins to Orderer
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 063 Returning policy Readers for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 064 In commit adding relative sub-policy SampleOrg/Readers to Orderer
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 065 Returning policy Writers for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 066 In commit adding relative sub-policy SampleOrg/Writers to Orderer
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 067 Returning policy Readers for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 068 Returning policy Writers for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 069 Returning policy Admins for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 06a Returning policy Writers for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 06b Returning policy Writers for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 06c In commit adding relative sub-policy SampleOrg/Writers to Application
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 06d Returning policy Admins for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 06e In commit adding relative sub-policy SampleOrg/Admins to Application
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 06f Returning policy Readers for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 070 In commit adding relative sub-policy SampleOrg/Readers to Application
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 071 Returning policy Admins for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 072 Returning policy Writers for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 073 Returning policy Readers for evaluation
2018-02-17 04:52:42.445 UTC [policies] GetPolicy -> DEBU 074 Returning policy SampleOrg/Writers for evaluation
2018-02-17 04:52:42.445 UTC [policies] CommitProposals -> DEBU 075 In commit adding relative sub-policy Orderer/SampleOrg/Writers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 076 Returning policy Readers for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 077 In commit adding relative sub-policy Orderer/Readers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 078 Returning policy Writers for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 079 In commit adding relative sub-policy Orderer/Writers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 07a Returning policy Admins for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 07b In commit adding relative sub-policy Orderer/Admins to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 07c Returning policy BlockValidation for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 07d In commit adding relative sub-policy Orderer/BlockValidation to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 07e Returning policy SampleOrg/Admins for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 07f In commit adding relative sub-policy Orderer/SampleOrg/Admins to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 080 Returning policy SampleOrg/Readers for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 081 In commit adding relative sub-policy Orderer/SampleOrg/Readers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 082 Returning policy Admins for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 083 In commit adding relative sub-policy Application/Admins to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 084 Returning policy Writers for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 085 In commit adding relative sub-policy Application/Writers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 086 Returning policy Readers for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 087 In commit adding relative sub-policy Application/Readers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 088 Returning policy SampleOrg/Writers for evaluation
2018-02-17 04:52:42.446 UTC [policies] CommitProposals -> DEBU 089 In commit adding relative sub-policy Application/SampleOrg/Writers to Channel
2018-02-17 04:52:42.446 UTC [policies] GetPolicy -> DEBU 08a Returning policy SampleOrg/Admins for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 08b In commit adding relative sub-policy Application/SampleOrg/Admins to Channel
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 08c Returning policy SampleOrg/Readers for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 08d In commit adding relative sub-policy Application/SampleOrg/Readers to Channel
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 08e Returning policy Readers for evaluation
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 08f Returning policy Readers for evaluation
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 090 Returning policy Writers for evaluation
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 091 Returning policy Writers for evaluation
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 092 Returning policy Admins for evaluation
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 093 Returning policy Admins for evaluation
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 094 Returning policy Readers for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 095 As expected, current configuration has policy '/Channel/Readers'
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 096 Returning policy Writers for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 097 As expected, current configuration has policy '/Channel/Writers'
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 098 Returning policy Application/Readers for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 099 As expected, current configuration has policy '/Channel/Application/Readers'
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 09a Returning policy Application/Writers for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 09b As expected, current configuration has policy '/Channel/Application/Writers'
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 09c Returning policy Application/Admins for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 09d As expected, current configuration has policy '/Channel/Application/Admins'
2018-02-17 04:52:42.447 UTC [policies] GetPolicy -> DEBU 09e Returning policy Orderer/BlockValidation for evaluation
2018-02-17 04:52:42.447 UTC [policies] CommitProposals -> DEBU 09f As expected, current configuration has policy '/Channel/Orderer/BlockValidation'
2018-02-17 04:52:42.448 UTC [chaincodeCmd] InitCmdFactory -> INFO 0a0 Get chain(myc) orderer endpoint: orderer:7050
2018-02-17 04:52:42.450 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 0a1 Using default escc
2018-02-17 04:52:42.450 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 0a2 Using default vscc
2018-02-17 04:52:42.450 UTC [msp/identity] Sign -> DEBU 0a3 Sign: plaintext: 0AA9080A6108031A0C089AEA9ED40510...30300A000A04657363630A0476736363 
2018-02-17 04:52:42.451 UTC [msp/identity] Sign -> DEBU 0a4 Sign: digest: 53C69F4D3E17BDC5F77DED0D002584A4ED9CE44A89C49F6CABBB03DED7E49A68 
2018-02-17 04:52:42.477 UTC [msp/identity] Sign -> DEBU 0a5 Sign: plaintext: 0AA9080A6108031A0C089AEA9ED40510...8E2320C661BDAC91644166CF7155568D 
2018-02-17 04:52:42.477 UTC [msp/identity] Sign -> DEBU 0a6 Sign: digest: 17F14535D40E75D42A20AAD7A3BA9C93796FCB89AA50F80ADCDFAC77BECA0F65 
2018-02-17 04:52:42.483 UTC [main] main -> INFO 0a7 Exiting.....

```

查看 a,b 两个账号的余额

```

peer chaincode query -C myc -n chaincode_example02 -c '{"Args":["query","a"]}'
peer chaincode query -C myc -n chaincode_example02 -c '{"Args":["query","b"]}'		

```

a 向 b 转账 50

```

peer chaincode invoke -C myc -n chaincode_example02 -c '{"Args":["invoke","a","b","50"]}'
peer chaincode query -C myc -n chaincode_example02 -c '{"Args":["query","a"]}'
peer chaincode query -C myc -n chaincode_example02 -c '{"Args":["query","b"]}'

```

这是再查看 a, b 两个掌控的余额应该是 a: 50 , B: 250

```

root@33dcacfb6f81:/opt/gopath/src/chaincodedev# peer chaincode query -C myc -n chaincode_example02 -c '{"Args":["query","a"]}'
2018-02-17 04:56:46.870 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-17 04:56:46.870 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-17 04:56:46.870 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-17 04:56:46.870 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-17 04:56:46.871 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0AB8080A7008031A0C088EEC9ED40510...6C6530321A0A0A0571756572790A0161 
2018-02-17 04:56:46.871 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: 1F0EB0AD273AE083C5673CE73877AE3F09324BDCB6968E2477D3F947B37EF4C5 
Query Result: 50
2018-02-17 04:56:46.903 UTC [main] main -> INFO 007 Exiting.....				

root@33dcacfb6f81:/opt/gopath/src/chaincodedev# peer chaincode query -C myc -n chaincode_example02 -c '{"Args":["query","b"]}'
2018-02-17 04:55:29.791 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-02-17 04:55:29.792 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-02-17 04:55:29.792 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-02-17 04:55:29.792 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-02-17 04:55:29.793 UTC [msp/identity] Sign -> DEBU 005 Sign: plaintext: 0AB8080A7008031A0C08C1EB9ED40510...6C6530321A0A0A0571756572790A0162 
2018-02-17 04:55:29.793 UTC [msp/identity] Sign -> DEBU 006 Sign: digest: 36BED07CE9664E26478A993392B2869F10533506CA9BD5F0A9D48D02EDB1F1D0 
Query Result: 250
2018-02-17 04:55:29.823 UTC [main] main -> INFO 007 Exiting.....

```

chaincode 终端也会显示下面内容。

```

root@78d23b3b2b37:/opt/gopath/src/chaincode# CORE_PEER_ADDRESS=peer:7051 CORE_CHAINCODE_ID_NAME=chaincode_example02:1.0 ./chaincode_example02 
2018-02-17 04:51:25.481 UTC [shim] SetupChaincodeLogging -> INFO 001 Chaincode log level not provided; defaulting to: INFO
2018-02-17 04:51:25.482 UTC [shim] SetupChaincodeLogging -> INFO 002 Chaincode (build level: ) starting up ...
ex02 Init
Aval = 100, Bval = 200
ex02 Invoke
Query Response:{"Name":"a","Amount":"100"}
ex02 Invoke
Query Response:{"Name":"b","Amount":"200"}
ex02 Invoke
Aval = 50, Bval = 250
ex02 Invoke
Query Response:{"Name":"b","Amount":"250"}
ex02 Invoke
Query Response:{"Name":"a","Amount":"50"}		

```

### 1.5. 代码测试

```

/*
Copyright IBM Corp. All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/

package example02

import (
	"fmt"
	"testing"

	"github.com/hyperledger/fabric/core/chaincode/shim"
)

func checkInit(t *testing.T, stub *shim.MockStub, args [][]byte) {
	res := stub.MockInit("1", args)
	if res.Status != shim.OK {
		fmt.Println("Init failed", string(res.Message))
		t.FailNow()
	}
}

func checkState(t *testing.T, stub *shim.MockStub, name string, value string) {
	bytes := stub.State[name]
	if bytes == nil {
		fmt.Println("State", name, "failed to get value")
		t.FailNow()
	}
	if string(bytes) != value {
		fmt.Println("State value", name, "was not", value, "as expected")
		t.FailNow()
	}
}

func checkQuery(t *testing.T, stub *shim.MockStub, name string, value string) {
	res := stub.MockInvoke("1", [][]byte{[]byte("query"), []byte(name)})
	if res.Status != shim.OK {
		fmt.Println("Query", name, "failed", string(res.Message))
		t.FailNow()
	}
	if res.Payload == nil {
		fmt.Println("Query", name, "failed to get value")
		t.FailNow()
	}
	if string(res.Payload) != value {
		fmt.Println("Query value", name, "was not", value, "as expected")
		t.FailNow()
	}
}

func checkInvoke(t *testing.T, stub *shim.MockStub, args [][]byte) {
	res := stub.MockInvoke("1", args)
	if res.Status != shim.OK {
		fmt.Println("Invoke", args, "failed", string(res.Message))
		t.FailNow()
	}
}

func TestExample02_Init(t *testing.T) {
	scc := new(SimpleChaincode)
	stub := shim.NewMockStub("ex02", scc)

	// Init A=123 B=234
	checkInit(t, stub, [][]byte{[]byte("init"), []byte("A"), []byte("123"), []byte("B"), []byte("234")})

	checkState(t, stub, "A", "123")
	checkState(t, stub, "B", "234")
}

func TestExample02_Query(t *testing.T) {
	scc := new(SimpleChaincode)
	stub := shim.NewMockStub("ex02", scc)

	// Init A=345 B=456
	checkInit(t, stub, [][]byte{[]byte("init"), []byte("A"), []byte("345"), []byte("B"), []byte("456")})

	// Query A
	checkQuery(t, stub, "A", "345")

	// Query B
	checkQuery(t, stub, "B", "456")
}

func TestExample02_Invoke(t *testing.T) {
	scc := new(SimpleChaincode)
	stub := shim.NewMockStub("ex02", scc)

	// Init A=567 B=678
	checkInit(t, stub, [][]byte{[]byte("init"), []byte("A"), []byte("567"), []byte("B"), []byte("678")})

	// Invoke A->B for 123
	checkInvoke(t, stub, [][]byte{[]byte("invoke"), []byte("A"), []byte("B"), []byte("123")})
	checkQuery(t, stub, "A", "444")
	checkQuery(t, stub, "B", "801")

	// Invoke B->A for 234
	checkInvoke(t, stub, [][]byte{[]byte("invoke"), []byte("B"), []byte("A"), []byte("234")})
	checkQuery(t, stub, "A", "678")
	checkQuery(t, stub, "B", "567")
	checkQuery(t, stub, "A", "678")
	checkQuery(t, stub, "B", "567")
}			

```

### 1.6. 在宿主主机上编译合约

编译 chaincode 可以在 docker 容器中进行，也可以在 docker 外面进行。方法如下：

安装依赖的库文件

```

yum install libtool-ltdl-devel
go get github.com/hyperledger/fabric		

```

编译合约文件

```

[root@localhost ~]# cd ~/netkiller/chaincode/chaincode_example02/
[root@localhost chaincode_example02]#

[root@localhost chaincode_example02]# go build chaincode_example02.go 

[root@localhost chaincode_example02]# ls
chaincode_example02  chaincode_example02.go  chaincode_example02_test.go 

```

### 提示

由于 docker 容器中没有 vim/nano 命令，无法编译 .go 文件，所以在宿主主机编译更为方便。

### 1.7. 链码升级

已经实例化的链码如果需要更新，可以通过 upgrade 升级。

```

peer chaincode upgrade -o orderer.example.com:7050 -C mychannel -n token4 -v 1.1 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

```

操作演示

```

[root@localhost token]# docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode upgrade -o orderer.example.com:7050 -C mychannel -n token4 -v 1.1 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"
2018-03-21 05:45:57.825 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-03-21 05:45:57.825 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-03-21 05:45:57.827 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 003 Using default escc
2018-03-21 05:45:57.828 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 004 Using default vscc
2018-03-21 05:45:57.829 UTC [chaincodeCmd] upgrade -> DEBU 005 Get upgrade proposal for chaincode <name:"token4" version:"1.1" >
2018-03-21 05:45:57.829 UTC [msp/identity] Sign -> DEBU 006 Sign: plaintext: 0A91070A6708031A0C0895E3C7D50510...324D53500A04657363630A0476736363 
2018-03-21 05:45:57.830 UTC [msp/identity] Sign -> DEBU 007 Sign: digest: D74025895DC08535F47FACF5AB3BE1ECFBCC30BA569E60C3DD45655BF5B89F89 
2018-03-21 05:46:43.134 UTC [chaincodeCmd] upgrade -> DEBU 008 endorse upgrade proposal, get response <status:200 message:"OK" payload:"\n\006token4\022\0031.1\032\004escc\"\004vscc*(\022\014\022\n\010\001\022\002\010\000\022\002\010\001\032\013\022\t\n\007Org1MSP\032\013\022\t\n\007Org2MSP2D\n \260\010<\325\376\335\274W\266N\236N\221\241NP\257&\330\220\232\355\022OB\334cE\021\374\343\222\022 r\2150\010R\nQ=\3135\314\312\334\312f\373\363\2646*hUT\362\227<Q\356*\007\204f: \362\366k\2363\033\314\177\226v\020\\KT\216\376\032\347\252\034L\274\224G+\003GE\2673G\222B\031\022\010\022\006\010\001\022\002\010\000\032\r\022\013\n\007Org1MSP\020\001" >
2018-03-21 05:46:43.166 UTC [msp/identity] Sign -> DEBU 009 Sign: plaintext: 0A91070A6708031A0C0895E3C7D50510...B547273E6CEACD8482A8F632F2681093 
2018-03-21 05:46:43.167 UTC [msp/identity] Sign -> DEBU 00a Sign: digest: D2F66B1F91AE4A6C138672975FBFC3D5D2A551419F74950B4129F5D4CA8B244D 
2018-03-21 05:46:43.167 UTC [chaincodeCmd] upgrade -> DEBU 00b Get Signed envelope
2018-03-21 05:46:43.167 UTC [chaincodeCmd] chaincodeUpgrade -> DEBU 00c Send signed envelope to orderer
2018-03-21 05:46:43.179 UTC [main] main -> INFO 00d Exiting.....

```

## 2. Chaincode 结构

Chaincode 实现 shim.ChaincodeStubInterface 接口，有三个方法，分别是：Init、Query 和 Invoke

[`github.com/hyperledger-archives/fabric/blob/master/core/chaincode/shim/chaincode.go`](https://github.com/hyperledger-archives/fabric/blob/master/core/chaincode/shim/chaincode.go)

### 2.1. 包

由于需要编译为可执行文件，所以需要 main 包

```

package main		

```

### 2.2. 导入库

这里需要导入两个包 "github.com/hyperledger/fabric/core/chaincode/shim" 和 "github.com/hyperledger/fabric/protos/peer" 其他包，根据实际需要而定。

```

import (
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

```

### 2.3. 定义类

```

type SimpleChaincode struct {
}		

```

### 2.4. Init 方法

负责初始化工作，链码首次部署到区块链网络时调用，将由部署自己的链代码实例的每个对等节点执行。此方法可用于任何与初始化、引导或设置相关的任务。

```

func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response {
}		

```

### 2.5. Query

只要在区块链状态上执行任何读取/获取/查询操作，就需要调用 Query 方法。如果尝试在 Query 方法内修改区块链的状态，将会抛出异常。

### 2.6. Invoke

此方法主要是做修改操作，但是很多例子中一些用户也在 Invoke 做查询。

put, get, del 等操作都在可以在 Invoke 中运行

```

func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
}		

```

参考例子

```

func (s *SmartContract) Invoke(stub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := stub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "balanceToken" {
		return s.balanceToken(stub, args)
	} else if function == "initLedger" {
		return s.initLedger(stub)
	} else if function == "transferToken" {
		return s.transferToken(stub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}		

```

在 Invoke 函数中，首先使用 stub.GetFunctionAndParameters() 获取合约函数
function, args := stub.GetFunctionAndParameters()

然后判断函数名称，实现对应的逻辑关系。

if function == "balanceToken" {
return s.balanceToken(stub, args)
} else if function == "initLedger" {
return s.initLedger(stub)
} else if function == "transferToken" {
return s.transferToken(stub, args)
}

### 2.7. func main()

任何 Go 程序的都需要 main 函数，他是程序的入口，因此该函数被用于引导/启动链代码。当对 peer 节点部署 chaincode 并实例化时，就会执行 main 函数。

```

func main() {
	err := shim.Start(new(SimpleChaincode))
	if err != nil {
		fmt.Printf("Error starting Simple chaincode: %s", err)
	}
}		

```

shim.Start(new(SampleChaincode)) 启动链代码并注册到 peer 节点。

## 3. shim.ChaincodeStubInterface 接口

Hyperledger 提供基于 key/value 的数据存储，其中 key 是字符串，value 则是二进制字节数组，Hyperledger 的 Go API 提供了三个方法用于数据存取：PutState（key, value）用于向 Hyperledger 中存储数据， GetState(key)用于从 Hyperledger 中提取数据，而 DelState(key)则从 Hyperledger 中删除数据。

写入数据如果是 struct 结构体，需要序列化，通常使用 json,其他形式的序列化也可以，只要能反序列化即可。

### 3.1. State 数据库曾，删，查 操作

#### 3.1.1. PutState（key, value）写入区块

写入区块联系

```

func (s *SmartContract) initLedger(stub shim.ChaincodeStubInterface) sc.Response {

	token := &Token{
		Owner: "netkiller",
		TotalSupply: 10000,
		TokenName: "代币通正",
		TokenSymbol: "COIN",
		BalanceOf: map[string]uint{}}

	token.initialSupply()

	tokenAsBytes, _ := json.Marshal(token)
	stub.PutState("Token", tokenAsBytes)
	fmt.Println("Added", tokenAsBytes)

	return shim.Success(nil)
}		

```

#### 3.1.2. GetState(key) 读取区块

通过 key 获取区块信息

```

func (s *SmartContract) balanceToken(stub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	tokenAsBytes, _ := stub.GetState(args[0])
	token := Token{}

	json.Unmarshal(tokenAsBytes, &token)
	amount := token.balance(args[1])

	return shim.Success(amount)
}

```

#### 3.1.3. DelState(key) 删除区块

删除区块信息

```

func (s *SmartContract) deleteData(stub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	err= stub.DelState(args[0])
	if err != nil {
	   return shim.Error("Failed to delete Student from DB, key is: "+key)
	}
	return shim.Success(nil)
}

```

#### 3.1.4. 修改数据

State 数据库并没有提供修改功能，修改数据可以先读取，再修改，最后写入

```

func (s *SmartContract) transferToken(stub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	tokenAsBytes, _ := stub.GetState(args[0])
	token := Token{}

	json.Unmarshal(tokenAsBytes, &token)
	token.transfer(args[1],args[2],args[3])

	tokenAsBytes, _ = json.Marshal(token)
	stub.PutState(args[0], tokenAsBytes)

	return shim.Success(nil)
}

```

#### 3.1.5. GetStateByRange(startKey, endKey) 范围查找

区块链是一个线性的数据结构，只要知道开始位置，结束位置，就能够取出中间部分的数据。

```

func (s *SmartContract) queryAllCars(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "CAR0"
	endKey := "CAR999"

	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return shim.Error(err.Error())
		}
		// Add a comma before array members, suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- queryAllCars:\n%s\n", buffer.String())

	return shim.Success(buffer.Bytes())
}

```

#### 3.1.6. GetQueryResult(query string) CouchDB 查询

GetQueryResult 能查询 json 里面的数据

下面例子是 Name = Neo Chen 的所有数据。

```

func (t *SimpleChaincode) getQueryResult(stub shim.ChaincodeStubInterface, args []string) pb.Response{
   name:="Neo Chen"	//需要查询的名字
   queryString := fmt.Sprintf("{\"selector\":{\"Name\":\"%s\"}}", name)
   resultsIterator,err:= stub.GetQueryResult(queryString)//必须是 CouchDB 才行
   if err!=nil{
      return shim.Error("query failed")
   }
   person,err:=getListResult(resultsIterator)
   if err!=nil{
      return shim.Error("query failed")
   }
   return shim.Success(person)
}

```

#### 3.1.7. stub.GetHistoryForKey

通过 key 获取历史数据

```

func (t *SimpleChaincode) historyQuery(stub shim.ChaincodeStubInterface, args []string) pb.Response{

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

   it,err:= stub.GetHistoryForKey(args[0])
   if err!=nil{
      return shim.Error(err.Error())
   }
   var result,_= getHistoryListResult(it)
   return shim.Success(result)
}			

```

#### 3.1.8. shim.HistoryQueryIteratorInterface 接口

```

func getHistoryListResult(resultsIterator shim.HistoryQueryIteratorInterface) ([]byte,error){

   defer resultsIterator.Close()
   // buffer is a JSON array containing QueryRecords
   var buffer bytes.Buffer
   buffer.WriteString("[")

   bArrayMemberAlreadyWritten := false
   for resultsIterator.HasNext() {
      queryResponse, err := resultsIterator.Next()
      if err != nil {
         return nil, err
      }
      // Add a comma before array members, suppress it for the first array member
      if bArrayMemberAlreadyWritten == true {
         buffer.WriteString(",")
      }
      item,_:= json.Marshal( queryResponse)
      buffer.Write(item)
      bArrayMemberAlreadyWritten = true
   }
   buffer.WriteString("]")
   fmt.Printf("queryResult:\n%s\n", buffer.String())
   return buffer.Bytes(), nil
}	

```

### 3.2. 复合键

#### 3.2.1. 创建复合键

```

	// maintain the index
	indexName := "color~name"
	colorNameIndexKey, err := stub.CreateCompositeKey(indexName, []string{marbleJSON.Color, marbleJSON.Name})
	if err != nil {
		return shim.Error(err.Error())
	}

	//  Delete index entry to state.
	err = stub.DelState(colorNameIndexKey)
	if err != nil {
		return shim.Error("Failed to delete state:" + err.Error())
	}	

```

#### 3.2.2. 分解复合键

```

		// get the color and name from color~name composite key
		objectType, compositeKeyParts, err := stub.SplitCompositeKey(responseRange.Key)
		if err != nil {
			return shim.Error(err.Error())
		}
		returnedColor := compositeKeyParts[0]
		returnedMarbleName := compositeKeyParts[1]			

```

### 3.3. stub.SetEvent(key, value) 事件

Hyperledger Fabic 事件实现了发布/订阅消息队列。您可以自由地在链码中创建和发出自定义事件。例如，区块链的状态发生改变，就会生成一个事件。通过向区块链上的事件中心注册一个事件适配器，客户端应用程序可以订阅和使用这些事件。

```

func (t *SimpleChaincode) testEvent(stub shim.ChaincodeStubInterface, args []string) pb.Response{
   message := "Event send data is here!"
   err := stub.SetEvent("evtsender", []byte(message))
   if err != nil {
      return shim.Error(err.Error())
   }
   return shim.Success(nil)
}		

func (t *SimpleChaincode) testEvent(stub shim.ChaincodeStubInterface, args []string) pb.Response{
	event := &Token{
		Owner: "netkiller",
		TotalSupply: 10000,
		TokenName: "代币通正",
		TokenSymbol: "COIN",
		BalanceOf: map[string]uint{}}

    eventBytes, err ;= json.Marshal(&event)
    if err != nil {
            return nil, err
    }
    err := stub.SetEvent("evtSender", eventBytes)
    if err != nil {
        fmt.Println("Could not set event for loan application creation", err)
    }
}

```

### 3.4. 调用其他链码

在当前连码中调用另一个连码，调用连码需要提供连码名和通道名 stub.InvokeChaincode("连码名",调用函数,"通道")

```

func (t *SimpleChaincode) testInvokeChainCode(stub shim.ChaincodeStubInterface, args []string) pb.Response{
   trans:=[][]byte{[]byte("invoke"),[]byte("transfer"),[]byte("netkiller"),[]byte("neo"),[]byte("100")}
   response:= stub.InvokeChaincode("token",trans,"mychannel")
   fmt.Println(response.Message)
   return shim.Success([]byte( response.Message))
}		

```

```

parms1 := []string{"query","a"}
queryArgs := make([][]byte, len(parms1))
for i, arg := range parms1 {
   queryArgs[i] = []byte(arg)
}

response := stub.InvokeChaincode("cc_endfinlshed",queryArgs,"roberttestchannel12")

if response.Status != shim.OK {
   errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", response.Payload)
   fmt.Printf(errStr)
return shim.Error(errStr)
}

result := string(response.Payload)

fmt.Printf(" invoke chaincode  %s " ,result)

return shim.Success([]byte("success InvokeChaincode  and Not opter !!!!!!!! " + result))

```

```

import (

	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"

)

// Invoke
func (am *accountManagement) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
    actionName, params := stub.GetFunctionAndParameters()

    if actionName == "callAnotherCC" {
        chainCodeArgs := util.ToChaincodeArgs("anotherCCFunc", "paramA")
        response := stub.InvokeChaincode("anotherCCName", chainCodeArgs, "channelName")

        if response.Status != shim.OK {
           return shim.Error(response.Message)
        }
        return shim.Success(nil)
    }

    // NOTE: This is an example, hence assuming only valid call is to call another chaincode
    return shim.Error(fmt.Sprintf("[ERROR] No <%s> action defined", actionName))
}

```

### 3.5. stub.GetCreator() 获得证书资料

```

func (t *SimpleChaincode) certificate(stub shim.ChaincodeStubInterface, args []string) pb.Response{
   creatorByte,_:= stub.GetCreator()
   certStart := bytes.IndexAny(creatorByte, "-----BEGIN")
   if certStart == -1 {
      fmt.Errorf("No certificate found")
   }
   certText := creatorByte[certStart:]
   bl, _ := pem.Decode(certText)
   if bl == nil {
      fmt.Errorf("Could not decode the PEM structure")
   }

   cert, err := x509.ParseCertificate(bl.Bytes)
   if err != nil {
      fmt.Errorf("ParseCertificate failed")
   }
   uname:=cert.Subject.CommonName
   fmt.Println("Name:"+uname)
   return shim.Success([]byte("Called testCertificate "+uname))
}

```

## 4. 链码案例

### 4.1. 模仿以太坊 ERC20 规范的 Hyperledger Fabric 实现 Token 通证

借用以太坊思维，将以太坊代币合约搬到 hyperledger 上，一样可以实现代币的功能，这个代币除了不能上交易所，基本满足我们替代积分系统的需求，下面是我写了这样一个合约，在超级账本上实现类似以太坊的代币转账功能。

合约实现代币转账，额度查询，增发代币，冻结账号，锁仓等等服务器，功能与 ERC20 Token 相仿。

合约实例化所有代币打入了 coinbase 账号，分发代币需要使用转账功能从 coinbase 想普通账号转账

普通账号消费可以在将代币转到 coinbase 账号中，这样就完成了代币流通，形成一个闭环。

```

package main 

import (
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	sc "github.com/hyperledger/fabric/protos/peer"
)

// Define the Smart Contract structure
type SmartContract struct {
}

type Token struct {
	Owner		string	`json:"Owner"`
	TotalSupply 	int	`json:"TotalSupply"`
	TokenName 	string	`json:"TokenName"`
	TokenSymbol 	string	`json:"TokenSymbol"`
	BalanceOf	map[string]int	`json:"BalanceOf"`
}

func (token *Token) initialSupply(){
	token.BalanceOf[token.Owner] = token.TotalSupply;
}

func (token *Token) transfer (_from string, _to string, _value int){
	if(token.BalanceOf[_from] >= _value){
		token.BalanceOf[_from] -= _value;
		token.BalanceOf[_to] += _value;
	}
}

func (token *Token) balance (_from string) int{
	return token.BalanceOf[_from]
}

func (token *Token) burn(_value int) {
	if(token.BalanceOf[token.Owner] >= _value){
		token.BalanceOf[token.Owner] -= _value;
		token.TotalSupply -= _value;
	}
}

func (token *Token) burnFrom(_from string, _value int) {
	if(token.BalanceOf[_from] >= _value){
		token.BalanceOf[_from] -= _value;
		token.TotalSupply -= _value;
	}
}

func (token *Token) mint(_value int) {

	token.BalanceOf[token.Owner] += _value;
	token.TotalSupply += _value;

}

func (s *SmartContract) Init(stub shim.ChaincodeStubInterface) sc.Response {
	return shim.Success(nil)
}

func (s *SmartContract) initLedger(stub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 3 {
                return shim.Error("Incorrect number of arguments. Expecting 2")
        }

	symbol:= args[0]
	name  := args[1]
	supply,_:= strconv.Atoi(args[2])

	token := &Token{
		Owner: "coinbase",
		TotalSupply: supply,
		TokenName: name,
		TokenSymbol: symbol,
		BalanceOf: map[string]int{}}

	token.initialSupply()

	tokenAsBytes, _ := json.Marshal(token)
	err := stub.PutState(symbol, tokenAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("Init %s \n", string(tokenAsBytes))

	return shim.Success(nil)
}

func (s *SmartContract) transferToken(stub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 4 {
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}
	_from 	:= args[1]
	_to	:= args[2]
	_amount,_	:= strconv.Atoi(args[3])
	if(_amount <= 0){
		return shim.Error("Incorrect number of amount")
	}

	tokenAsBytes,err := stub.GetState(args[0])
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("transferToken - begin %s \n", string(tokenAsBytes))

	token := Token{}

	json.Unmarshal(tokenAsBytes, &token)
	token.transfer(_from, _to, _amount)

	tokenAsBytes, err = json.Marshal(token)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutState(args[0], tokenAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("transferToken - end %s \n", string(tokenAsBytes))

	return shim.Success(nil)
}

func (s *SmartContract) balanceToken(stub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	tokenAsBytes,err := stub.GetState(args[0])
	if err != nil {
		return shim.Error(err.Error())
	}
	token := Token{}

	json.Unmarshal(tokenAsBytes, &token)
	amount := token.balance(args[1])
	value := strconv.Itoa(amount)
	fmt.Printf("%s balance is %s \n", args[1], value)	
	//jsonVal, _ := json.Marshal(string(value))

	return shim.Success([]byte(value))
}

func (s *SmartContract) Invoke(stub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := stub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "balanceToken" {
		return s.balanceToken(stub, args)
	} else if function == "initLedger" {
		return s.initLedger(stub, args)
	} else if function == "transferToken" {
		return s.transferToken(stub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}

// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}

```

这个合约用户可以创建多套代币，Args":["Token" 的第一参数 Token 就是代币名称

```

peer chaincode invoke -C myc -n token -c '{"function":"initLedger","Args":["Apple","水果币","1000000"]}'
peer chaincode invoke -C myc -n token -c '{"function":"initLedger","Args":["Token","蔬菜币","1000000"]}'
peer chaincode invoke -C myc -n token -c '{"function":"initLedger","Args":["Oil","粮油币","1000000"]}'

```

这个方案仍有不足之处，作者还不清楚如果用户上线是多少，达到临界值后，Hyperledger Fabric 无法在提供服务。

可能 chaincode_example02 做法更靠谱，就是不用 map 保存数据，将每个用户存储在 State 数据上。这里需要创建多套代币，所以使用了一个 key 来存储所有账号。如果像 chaincode_example02 那样就需要部署多个 chaincode 在 channel 中。管理起来比较复杂。

```

[root@localhost fabric-samples]# cd chaincode-docker-devmode/
[root@localhost chaincode-docker-devmode]# docker-compose up -d
[root@localhost chaincode-docker-devmode]# docker exec -it cli bash
root@765cbcd51fd7:/opt/gopath/src/chaincode#		

CORE_PEER_ADDRESS=peer:7051 CORE_CHAINCODE_ID_NAME=token:1.0 ./chaincode/chaincode/token/token 

peer chaincode install -n token -v 1.0 -p chaincodedev/chaincode/chaincode/token
peer chaincode instantiate -C myc -n token -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"
peer chaincode instantiate -C myc -n token -v 1.0 -c '{"Args":["init"]}' 
sleep 10
peer chaincode invoke -C myc -n token -c '{"function":"initLedger","Args":["Token","Netkiller Coin","1000000"]}'

peer chaincode invoke -C myc -n token -c '{"function":"transferToken","Args":["Token","coinbase","netkiller","100"]}'		
peer chaincode invoke -C myc -n token -c '{"function":"balanceToken","Args":["Token","netkiller"]}'

peer chaincode invoke -C myc -n token -c '{"function":"transferToken","Args":["Token","netkiller","jerry","100"]}'

peer chaincode query -C myc -n token -c '{"function":"balanceToken","Args":["Token","netkiller"]}'

```

测试不存在账号转账

```

peer chaincode invoke -C myc -n token -c '{"function":"transferToken","Args":["Token","neo","netkiller","100"]}'			

```

以太坊和超级账本各有优势，虽然超级账本的 Token 功能无法和以太坊相比，但是使用超级账本实现的 Token 交易不用矿工费。同事超级账本还有一个优势，就是可以在合约中调用另一个合约，这样一来可以做出很多复杂的需求

例如我们在订票的合约中，就可以直接从 Token 合约中直接扣款。

### 4.2. 万能的通用合约

我们一般会在合约中定义结构体，然后序列化后存入 state 数据库中。一旦数据结构变化，就需要升级 chaincode。

下面我们只实现了 create, find, update, delete 四个方法，没有数据结构，用户自行提交 json 格式或者其他序列化后的字符串数据。

```

package main

import (
	"fmt"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

type SmartContract struct {}

func (s *SmartContract) Init(stub shim.ChaincodeStubInterface) pb.Response {
	return shim.Success(nil)
}

func (s *SmartContract) Query(stub shim.ChaincodeStubInterface) pb.Response {
	return shim.Success(nil)
}

func (s *SmartContract) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := stub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "create" {
		return s.create(stub, args)
	} else if function == "find" {
		return s.find(stub, args)
	} else if function == "update" {
		return s.update(stub, args)
	} else if function == "delete" {
		return s.delete(stub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}

func (s *SmartContract) create(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	_key  	:= args[0]
	_data	:= args[1]

	if(_data == ""){
		return shim.Error("Incorrect string of data")
	}

	existAsBytes,err := stub.GetState(_key)
	if string(existAsBytes) != "" {
		fmt.Println("Failed to create account, Duplicate key.")
		return shim.Error("Failed to create account, Duplicate key.")
	}

	err = stub.PutState(_key, []byte(_data))
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("create %s %s \n", _key, string(_data))

	return shim.Success([]byte(_data))
}

func (s *SmartContract) find(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	_key  	:= args[0]
	_data, err := stub.GetState(_key)
	if err != nil {
		return shim.Error(err.Error())
	}
	if string(_data) == "" {
		return shim.Error("The key isn't exist.")
	}else{
		fmt.Printf("query %s %s \n", _key, string(_data))
	}

	return shim.Success(_data)
}

func (s *SmartContract) update(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	_key  	:= args[0]
	_data	:= args[1]

	if(_data == ""){
		return shim.Error("Incorrect string of data")
	}

	err := stub.PutState(_key, []byte(_data))
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("update %s %s \n", _key, string(_data))
	}

	return shim.Success([]byte(_data))
}

// Deletes an entity from state
func (t *SmartContract) delete(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	_key := args[0]

	// Delete the key from the state in ledger
	err := stub.DelState(_key)
	if err != nil {
		return shim.Error("Failed to delete state")
	}

	return shim.Success(nil)
}

func main() {

	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}

```

测试环境 Hyperledger Fabric v1.2.0

```

[root@localhost ~]# docker exec -it cli bash

root@8cb899359aec:/opt/gopath/src/chaincodedev# peer chaincode install -v 1.0 -n art -p chaincodedev/chaincode/art
root@8cb899359aec:/opt/gopath/src/chaincodedev# peer chaincode instantiate -C myc -n art -v 1.0 -c '{"Args":["init",""]}'

root@8cb899359aec:/opt/gopath/src/chaincodedev# peer chaincode instantiate -C myc -n art -v 1.0 -c '{"Args":[]}'

```

操作演示

```

root@8cb899359aec:/opt/gopath/src/chaincodedev# peer chaincode install -v 1.0 -n art -p chaincodedev/chaincode/art
2018-07-20 02:39:48.091 UTC [viperutil] getKeysRecursively -> DEBU 001 Found map[string]interface{} value for peer.BCCSP
2018-07-20 02:39:48.092 UTC [viperutil] unmarshalJSON -> DEBU 002 Unmarshal JSON: value cannot be unmarshalled: invalid character 'S' looking for beginning of value
2018-07-20 02:39:48.092 UTC [viperutil] getKeysRecursively -> DEBU 003 Found real value for peer.BCCSP.Default setting to string SW
2018-07-20 02:39:48.093 UTC [viperutil] getKeysRecursively -> DEBU 004 Found map[string]interface{} value for peer.BCCSP.SW
2018-07-20 02:39:48.093 UTC [viperutil] unmarshalJSON -> DEBU 005 Unmarshal JSON: value cannot be unmarshalled: invalid character 'S' looking for beginning of value
2018-07-20 02:39:48.093 UTC [viperutil] getKeysRecursively -> DEBU 006 Found real value for peer.BCCSP.SW.Hash setting to string SHA2
2018-07-20 02:39:48.094 UTC [viperutil] unmarshalJSON -> DEBU 007 Unmarshal JSON: value is not a string: 256
2018-07-20 02:39:48.094 UTC [viperutil] getKeysRecursively -> DEBU 008 Found real value for peer.BCCSP.SW.Security setting to int 256
2018-07-20 02:39:48.095 UTC [viperutil] getKeysRecursively -> DEBU 009 Found map[string]interface{} value for peer.BCCSP.SW.FileKeyStore
2018-07-20 02:39:48.095 UTC [viperutil] unmarshalJSON -> DEBU 00a Unmarshal JSON: value cannot be unmarshalled: unexpected end of JSON input
2018-07-20 02:39:48.095 UTC [viperutil] getKeysRecursively -> DEBU 00b Found real value for peer.BCCSP.SW.FileKeyStore.KeyStore setting to string 
2018-07-20 02:39:48.096 UTC [viperutil] getKeysRecursively -> DEBU 00c Found map[string]interface{} value for peer.BCCSP.PKCS11
2018-07-20 02:39:48.096 UTC [viperutil] getKeysRecursively -> DEBU 00d Found map[string]interface{} value for peer.BCCSP.PKCS11.FileKeyStore
2018-07-20 02:39:48.097 UTC [viperutil] unmarshalJSON -> DEBU 00e Unmarshal JSON: value is not a string: <nil>
2018-07-20 02:39:48.098 UTC [viperutil] getKeysRecursively -> DEBU 00f Found real value for peer.BCCSP.PKCS11.FileKeyStore.KeyStore setting to <nil> <nil>
2018-07-20 02:39:48.098 UTC [viperutil] unmarshalJSON -> DEBU 010 Unmarshal JSON: value is not a string: <nil>
2018-07-20 02:39:48.099 UTC [viperutil] getKeysRecursively -> DEBU 011 Found real value for peer.BCCSP.PKCS11.Library setting to <nil> <nil>
2018-07-20 02:39:48.099 UTC [viperutil] unmarshalJSON -> DEBU 012 Unmarshal JSON: value is not a string: <nil>
2018-07-20 02:39:48.100 UTC [viperutil] getKeysRecursively -> DEBU 013 Found real value for peer.BCCSP.PKCS11.Label setting to <nil> <nil>
2018-07-20 02:39:48.101 UTC [viperutil] unmarshalJSON -> DEBU 014 Unmarshal JSON: value is not a string: <nil>
2018-07-20 02:39:48.101 UTC [viperutil] getKeysRecursively -> DEBU 015 Found real value for peer.BCCSP.PKCS11.Pin setting to <nil> <nil>
2018-07-20 02:39:48.102 UTC [viperutil] unmarshalJSON -> DEBU 016 Unmarshal JSON: value is not a string: <nil>
2018-07-20 02:39:48.103 UTC [viperutil] getKeysRecursively -> DEBU 017 Found real value for peer.BCCSP.PKCS11.Hash setting to <nil> <nil>
2018-07-20 02:39:48.103 UTC [viperutil] unmarshalJSON -> DEBU 018 Unmarshal JSON: value is not a string: <nil>
2018-07-20 02:39:48.104 UTC [viperutil] getKeysRecursively -> DEBU 019 Found real value for peer.BCCSP.PKCS11.Security setting to <nil> <nil>
2018-07-20 02:39:48.104 UTC [viperutil] EnhancedExactUnmarshalKey -> DEBU 01a map[peer.BCCSP:map[Default:SW SW:map[Security:256 FileKeyStore:map[KeyStore:] Hash:SHA2] PKCS11:map[Pin:<nil> Hash:<nil> Security:<nil> FileKeyStore:map[KeyStore:<nil>] Library:<nil> Label:<nil>]]]
2018-07-20 02:39:48.105 UTC [bccsp_sw] openKeyStore -> DEBU 01b KeyStore opened at [/etc/hyperledger/msp/keystore]...done
2018-07-20 02:39:48.105 UTC [bccsp] initBCCSP -> DEBU 01c Initialize BCCSP [SW]
2018-07-20 02:39:48.106 UTC [msp] getPemMaterialFromDir -> DEBU 01d Reading directory /etc/hyperledger/msp/signcerts
2018-07-20 02:39:48.106 UTC [msp] getPemMaterialFromDir -> DEBU 01e Inspecting file /etc/hyperledger/msp/signcerts/peer.pem
2018-07-20 02:39:48.106 UTC [msp] getPemMaterialFromDir -> DEBU 01f Reading directory /etc/hyperledger/msp/cacerts
2018-07-20 02:39:48.106 UTC [msp] getPemMaterialFromDir -> DEBU 020 Inspecting file /etc/hyperledger/msp/cacerts/cacert.pem
2018-07-20 02:39:48.107 UTC [msp] getPemMaterialFromDir -> DEBU 021 Reading directory /etc/hyperledger/msp/admincerts
2018-07-20 02:39:48.107 UTC [msp] getPemMaterialFromDir -> DEBU 022 Inspecting file /etc/hyperledger/msp/admincerts/admincert.pem
2018-07-20 02:39:48.107 UTC [msp] getPemMaterialFromDir -> DEBU 023 Reading directory /etc/hyperledger/msp/intermediatecerts
2018-07-20 02:39:48.107 UTC [msp] getMspConfig -> DEBU 024 Intermediate certs folder not found at [/etc/hyperledger/msp/intermediatecerts]. Skipping. [stat /etc/hyperledger/msp/intermediatecerts: no such file or directory]
2018-07-20 02:39:48.107 UTC [msp] getPemMaterialFromDir -> DEBU 025 Reading directory /etc/hyperledger/msp/tlscacerts
2018-07-20 02:39:48.107 UTC [msp] getPemMaterialFromDir -> DEBU 026 Inspecting file /etc/hyperledger/msp/tlscacerts/tlsroot.pem
2018-07-20 02:39:48.107 UTC [msp] getPemMaterialFromDir -> DEBU 027 Reading directory /etc/hyperledger/msp/tlsintermediatecerts
2018-07-20 02:39:48.108 UTC [msp] getPemMaterialFromDir -> DEBU 028 Inspecting file /etc/hyperledger/msp/tlsintermediatecerts/tlsintermediate.pem
2018-07-20 02:39:48.108 UTC [msp] getPemMaterialFromDir -> DEBU 029 Reading directory /etc/hyperledger/msp/crls
2018-07-20 02:39:48.108 UTC [msp] getMspConfig -> DEBU 02a crls folder not found at [/etc/hyperledger/msp/crls]. Skipping. [stat /etc/hyperledger/msp/crls: no such file or directory]
2018-07-20 02:39:48.108 UTC [msp] getMspConfig -> DEBU 02b MSP configuration file not found at [/etc/hyperledger/msp/config.yaml]: [stat /etc/hyperledger/msp/config.yaml: no such file or directory]
2018-07-20 02:39:48.109 UTC [msp] newBccspMsp -> DEBU 02c Creating BCCSP-based MSP instance
2018-07-20 02:39:48.109 UTC [msp] New -> DEBU 02d Creating Cache-MSP instance
2018-07-20 02:39:48.109 UTC [msp] loadLocaMSP -> DEBU 02e Created new local MSP
2018-07-20 02:39:48.110 UTC [msp] Setup -> DEBU 02f Setting up MSP instance DEFAULT
2018-07-20 02:39:48.111 UTC [msp/identity] newIdentity -> DEBU 030 Creating identity instance for cert -----BEGIN CERTIFICATE-----
MIICYjCCAgigAwIBAgIRAL1fEAnz5zp4moJ8MdSb/lYwCgYIKoZIzj0EAwIwgYEx
CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4g
RnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMQwwCgYDVQQLEwND
T1AxHDAaBgNVBAMTE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcxMTEyMTM0MTEx
WhcNMjcxMTEwMTM0MTExWjCBgTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlm
b3JuaWExFjAUBgNVBAcTDVNhbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhh
bXBsZS5jb20xDDAKBgNVBAsTA0NPUDEcMBoGA1UEAxMTY2Eub3JnMS5leGFtcGxl
LmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGrsQ6oJpk6hDWf63HU3OSNd
bou9KNw/VIee1IngPDI4YJU7O+Xa/XLJuwnFv7BpR8Ytl3f+njC8i/RZP2/svO+j
XzBdMA4GA1UdDwEB/wQEAwIBpjAPBgNVHSUECDAGBgRVHSUAMA8GA1UdEwEB/wQF
MAMBAf8wKQYDVR0OBCIEIIpzkSIZzxBWVIV5unlgZJuyu2XPEeP8+y1uB6LLA5Qr
MAoGCCqGSM49BAMCA0gAMEUCIQDUh/+CC2dAICnYtACXspwUaaEbiyZxYIx+XDvW
o8VVcgIgGz5S4iC5+xkxgeaISPfxKTTVy6yzTdYGzCw1vPppjzo=
-----END CERTIFICATE-----
2018-07-20 02:39:48.112 UTC [msp/identity] newIdentity -> DEBU 031 Creating identity instance for cert -----BEGIN CERTIFICATE-----
MIICNjCCAd2gAwIBAgIRAMnf9/dmV9RvCCVw9pZQUfUwCgYIKoZIzj0EAwIwgYEx
CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4g
RnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMQwwCgYDVQQLEwND
T1AxHDAaBgNVBAMTE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcxMTEyMTM0MTEx
WhcNMjcxMTEwMTM0MTExWjBpMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZv
cm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEMMAoGA1UECxMDQ09QMR8wHQYD
VQQDExZwZWVyMC5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D
AQcDQgAEZ8S4V71OBJpyMIVZdwYdFXAckItrpvSrCf0HQg40WW9XSoOOO76I+Umf
EkmTlIJXP7/AyRRSRU38oI8Ivtu4M6NNMEswDgYDVR0PAQH/BAQDAgeAMAwGA1Ud
EwEB/wQCMAAwKwYDVR0jBCQwIoAginORIhnPEFZUhXm6eWBkm7K7Zc8R4/z7LW4H
ossDlCswCgYIKoZIzj0EAwIDRwAwRAIgVikIUZzgfuFsGLQHWJUVJCU7pDaETkaz
PzFgsCiLxUACICgzJYlW7nvZxP7b6tbeu3t8mrhMXQs956mD4+BoKuNI
-----END CERTIFICATE-----
2018-07-20 02:39:48.181 UTC [msp/identity] newIdentity -> DEBU 032 Creating identity instance for cert -----BEGIN CERTIFICATE-----
MIICNjCCAd2gAwIBAgIRAMnf9/dmV9RvCCVw9pZQUfUwCgYIKoZIzj0EAwIwgYEx
CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4g
RnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMQwwCgYDVQQLEwND
T1AxHDAaBgNVBAMTE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcxMTEyMTM0MTEx
WhcNMjcxMTEwMTM0MTExWjBpMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZv
cm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEMMAoGA1UECxMDQ09QMR8wHQYD
VQQDExZwZWVyMC5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D
AQcDQgAEZ8S4V71OBJpyMIVZdwYdFXAckItrpvSrCf0HQg40WW9XSoOOO76I+Umf
EkmTlIJXP7/AyRRSRU38oI8Ivtu4M6NNMEswDgYDVR0PAQH/BAQDAgeAMAwGA1Ud
EwEB/wQCMAAwKwYDVR0jBCQwIoAginORIhnPEFZUhXm6eWBkm7K7Zc8R4/z7LW4H
ossDlCswCgYIKoZIzj0EAwIDRwAwRAIgVikIUZzgfuFsGLQHWJUVJCU7pDaETkaz
PzFgsCiLxUACICgzJYlW7nvZxP7b6tbeu3t8mrhMXQs956mD4+BoKuNI
-----END CERTIFICATE-----
2018-07-20 02:39:48.183 UTC [msp/identity] newIdentity -> DEBU 033 Creating identity instance for cert -----BEGIN CERTIFICATE-----
MIICNjCCAd2gAwIBAgIRAMnf9/dmV9RvCCVw9pZQUfUwCgYIKoZIzj0EAwIwgYEx
CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4g
RnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMQwwCgYDVQQLEwND
T1AxHDAaBgNVBAMTE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTcxMTEyMTM0MTEx
WhcNMjcxMTEwMTM0MTExWjBpMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZv
cm5pYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEMMAoGA1UECxMDQ09QMR8wHQYD
VQQDExZwZWVyMC5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D
AQcDQgAEZ8S4V71OBJpyMIVZdwYdFXAckItrpvSrCf0HQg40WW9XSoOOO76I+Umf
EkmTlIJXP7/AyRRSRU38oI8Ivtu4M6NNMEswDgYDVR0PAQH/BAQDAgeAMAwGA1Ud
EwEB/wQCMAAwKwYDVR0jBCQwIoAginORIhnPEFZUhXm6eWBkm7K7Zc8R4/z7LW4H
ossDlCswCgYIKoZIzj0EAwIDRwAwRAIgVikIUZzgfuFsGLQHWJUVJCU7pDaETkaz
PzFgsCiLxUACICgzJYlW7nvZxP7b6tbeu3t8mrhMXQs956mD4+BoKuNI
-----END CERTIFICATE-----
2018-07-20 02:39:48.183 UTC [msp] setupSigningIdentity -> DEBU 034 Signing identity expires at 2027-11-10 13:41:11 +0000 UTC
2018-07-20 02:39:48.185 UTC [msp] Validate -> DEBU 035 MSP DEFAULT validating identity
2018-07-20 02:39:48.187 UTC [grpc] Printf -> DEBU 036 parsed scheme: ""
2018-07-20 02:39:48.188 UTC [grpc] Printf -> DEBU 037 scheme "" not registered, fallback to default scheme
2018-07-20 02:39:48.188 UTC [grpc] Printf -> DEBU 038 ccResolverWrapper: sending new addresses to cc: [{peer:7051 0  <nil>}]
2018-07-20 02:39:48.188 UTC [grpc] Printf -> DEBU 039 ClientConn switching balancer to "pick_first"
2018-07-20 02:39:48.188 UTC [grpc] Printf -> DEBU 03a pickfirstBalancer: HandleSubConnStateChange: 0xc4203d7c40, CONNECTING
2018-07-20 02:39:48.190 UTC [grpc] Printf -> DEBU 03b pickfirstBalancer: HandleSubConnStateChange: 0xc4203d7c40, READY
2018-07-20 02:39:48.192 UTC [grpc] Printf -> DEBU 03c parsed scheme: ""
2018-07-20 02:39:48.192 UTC [grpc] Printf -> DEBU 03d scheme "" not registered, fallback to default scheme
2018-07-20 02:39:48.192 UTC [grpc] Printf -> DEBU 03e ccResolverWrapper: sending new addresses to cc: [{peer:7051 0  <nil>}]
2018-07-20 02:39:48.192 UTC [grpc] Printf -> DEBU 03f ClientConn switching balancer to "pick_first"
2018-07-20 02:39:48.192 UTC [grpc] Printf -> DEBU 040 pickfirstBalancer: HandleSubConnStateChange: 0xc420452130, CONNECTING
2018-07-20 02:39:48.194 UTC [grpc] Printf -> DEBU 041 pickfirstBalancer: HandleSubConnStateChange: 0xc420452130, READY
2018-07-20 02:39:48.197 UTC [msp] GetDefaultSigningIdentity -> DEBU 042 Obtaining default signing identity
2018-07-20 02:39:48.197 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 043 Using default escc
2018-07-20 02:39:48.198 UTC [chaincodeCmd] checkChaincodeCmdParams -> INFO 044 Using default vscc
2018-07-20 02:39:48.198 UTC [chaincodeCmd] getChaincodeSpec -> DEBU 045 java chaincode disabled
2018-07-20 02:39:48.266 UTC [golang-platform] getCodeFromFS -> DEBU 046 getCodeFromFS chaincodedev/chaincode/art
2018-07-20 02:39:49.372 UTC [golang-platform] func1 -> DEBU 047 Discarding GOROOT package fmt
2018-07-20 02:39:49.372 UTC [golang-platform] func1 -> DEBU 048 Discarding provided package github.com/hyperledger/fabric/core/chaincode/shim
2018-07-20 02:39:49.372 UTC [golang-platform] func1 -> DEBU 049 Discarding provided package github.com/hyperledger/fabric/protos/peer
2018-07-20 02:39:49.373 UTC [golang-platform] GetDeploymentPayload -> DEBU 04a done
2018-07-20 02:39:49.373 UTC [container] WriteFileToPackage -> DEBU 04b Writing file to tarball: src/chaincodedev/chaincode/art/art.go
2018-07-20 02:39:49.378 UTC [msp/identity] Sign -> DEBU 04c Sign: plaintext: 0AC4070A5C08031A0C08F596C5DA0510...97DB3F010000FFFFD8DB7F9600140000 
2018-07-20 02:39:49.379 UTC [msp/identity] Sign -> DEBU 04d Sign: digest: EFE78D9C254C9A5795FAC35A6AC5A543AAD70322E6F756D1822E9BBEC11AD7E0 
2018-07-20 02:39:49.459 UTC [chaincodeCmd] install -> INFO 04e Installed remotely response:<status:200 payload:"OK" > 

```

## 第 27 章 Hyperledger Fabric Client SDK for Node.js

## 1. package.json

```

[root@localhost chaincode-docker-devmode]# mkdir token
[root@localhost chaincode-docker-devmode]# cd token/
[root@localhost devel]#		

```

```

[root@localhost token]# cat package.json 
{
    "name": "token",
    "version": "1.0.0",
    "description": "Hyperledger Fabric 'token' Sample Application by netkiller<netkiller@msn.com>",
    "main": "token.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "dependencies": {
        "fabric-ca-client": "¹.0.2",
        "fabric-client": "¹.0.2",
        "grpc": "¹.6.0"
    },
    "author": "netkiller <netkiller@msn.com>",
    "license": "Apache-2.0",
    "keywords": [
        "Hyperledger",
        "Fabric",
        "token"
    ]
}

```

```

[root@localhost token]# npm install			

```

## 2. Node.js 测试程序

```

package main 

/* 
--------------------------------------------------
Author: netkiller <netkiller@msn.com>
Home: http://www.netkiller.cn
Data: 2018-03-20 11:00 PM
--------------------------------------------------

CORE_PEER_ADDRESS=peer:7051 CORE_CHAINCODE_ID_NAME=token3:1.0 chaincode/token/token3

peer chaincode install -n token3 -v 1.0 -p chaincodedev/chaincode/token
peer chaincode instantiate -C myc -n token3 -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"

peer chaincode invoke -C myc -n token3 -c '{"function":"createAccount","Args":["coinbase"]}'
peer chaincode invoke -C myc -n token3 -v 1.0 -c '{"function":"showAccount","Args":["coinbase"]}'
peer chaincode invoke -C myc -n token3 -c '{"function":"balanceAll","Args":["coinbase"]}'

peer chaincode invoke -C myc -n token3 -c '{"function":"initCurrency","Args":["Netkiller Token","NKC","1000000","coinbase"]}'
peer chaincode invoke -C myc -n token3 -c '{"function":"initCurrency","Args":["NEO Token","NEC","1000000","coinbase"]}'

peer chaincode invoke -C myc -n token3 -c '{"function":"setLock","Args":["true"]}'
peer chaincode invoke -C myc -n token3 -c '{"function":"setLock","Args":["false"]}'

peer chaincode invoke -C myc -n token3 -c '{"function":"mintToken","Args":["NKC","5000","coinbase"]}'

peer chaincode invoke -C myc -n token3 -c '{"function":"createAccount","Args":["netkiller"]}'
peer chaincode invoke -C myc -n token3 -c '{"function":"transferToken","Args":["coinbase","netkiller","NKC","100"]}'		
peer chaincode invoke -C myc -n token3 -c '{"function":"balance","Args":["netkiller","NKC"]}'

peer chaincode invoke -C myc -n token3 -c '{"function":"frozenAccount","Args":["netkiller","true"]}'

--------------------------------------------------

*/

import (
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

type Msg struct{
	Status 	bool	`json:"Status"`
	Code 	int		`json:"Code"`
	Message string	`json:"Message"`
}

type Currency struct{
	TokenName 		string	`json:"TokenName"`
	TokenSymbol 	string	`json:"TokenSymbol"`
	TotalSupply 	float64	`json:"TotalSupply"`
}

type Token struct {
	Lock		bool	`json:"Lock"`
	Currency	map[string]Currency	`json:"Currency"`
}

func (token *Token) transfer (_from *Account, _to *Account, _currency string, _value float64) []byte{

	var rev []byte
	if (token.Lock){
		msg := &Msg{Status: false, Code: 0, Message: "锁仓状态，停止一切转账活动"}
		rev, _ = json.Marshal(msg)
		return rev
	}
	if(_from.Frozen ) {
		msg := &Msg{Status: false, Code: 0, Message: "From 账号冻结"}
		rev, _ = json.Marshal(msg)
		return rev
	}
	if( _to.Frozen) {
		msg := &Msg{Status: false, Code: 0, Message: "To 账号冻结"}
		rev, _ = json.Marshal(msg)
		return rev
	}
	if(!token.isCurrency(_currency)){
		msg := &Msg{Status: false, Code: 0, Message: "货币符号不存在"}
		rev, _ = json.Marshal(msg)
		return rev
	}
	if(_from.BalanceOf[_currency] >= _value){
		_from.BalanceOf[_currency] -= _value;
		_to.BalanceOf[_currency] += _value;

		msg := &Msg{Status: true, Code: 0, Message: "转账成功"}
		rev, _ = json.Marshal(msg)
		return rev
	}else{
		msg := &Msg{Status: false, Code: 0, Message: "余额不足"}
		rev, _ = json.Marshal(msg)
		return rev
	}

}
func (token *Token) initialSupply(_name string, _symbol string, _supply float64, _account *Account) []byte{
	if _,ok := token.Currency[_symbol]; ok {
		msg := &Msg{Status: false, Code: 0, Message: "代币已经存在"}
		rev, _ := json.Marshal(msg)
		return rev
	}

	if _account.BalanceOf[_symbol] > 0 {
		msg := &Msg{Status: false, Code: 0, Message: "账号中存在代币"}
		rev, _ := json.Marshal(msg)
		return rev
	}else{
		token.Currency[_symbol] = Currency{TokenName: _name, TokenSymbol: _symbol, TotalSupply: _supply}
		_account.BalanceOf[_symbol] = _supply

		msg := &Msg{Status: true, Code: 0, Message: "代币初始化成功"}
		rev, _ := json.Marshal(msg)
		return rev
	}

}

func (token *Token) mint(_currency string, _amount float64, _account *Account) []byte{
	if(!token.isCurrency(_currency)){
		msg := &Msg{Status: false, Code: 0, Message: "货币符号不存在"}
		rev, _ := json.Marshal(msg)
		return rev
	}
	cur := token.Currency[_currency]
	cur.TotalSupply += _amount;
	token.Currency[_currency] = cur
	_account.BalanceOf[_currency] += _amount;

	msg := &Msg{Status: true, Code: 0, Message: "代币增发成功"}
	rev, _ := json.Marshal(msg)
	return rev

}
func (token *Token) burn(_currency string, _amount float64, _account *Account) []byte{
	if(!token.isCurrency(_currency)){
		msg := &Msg{Status: false, Code: 0, Message: "货币符号不存在"}
		rev, _ := json.Marshal(msg)
		return rev
	}
	if(token.Currency[_currency].TotalSupply >= _amount){
		cur := token.Currency[_currency]
		cur.TotalSupply -= _amount;
		token.Currency[_currency] = cur
		_account.BalanceOf[_currency] -= _amount;

		msg := &Msg{Status: false, Code: 0, Message: "代币回收成功"}
		rev, _ := json.Marshal(msg)
		return rev
	}else{
		msg := &Msg{Status: false, Code: 0, Message: "代币回收失败，回收额度不足"}
		rev, _ := json.Marshal(msg)
		return rev
	}

}
func (token *Token) isCurrency(_currency string) bool {
	if _, ok := token.Currency[_currency]; ok {
		return true
	}else{
		return false
	}
}
func (token *Token) setLock(_look bool) bool {
	token.Lock = _look
	return token.Lock
}
type Account struct {
	Name			string	`json:"Name"`
	Frozen			bool	`json:"Frozen"`
	BalanceOf		map[string]float64	`json:"BalanceOf"`
}
func (account *Account) balance (_currency string) map[string]float64{
	bal	:= map[string]float64{_currency:account.BalanceOf[_currency]}
	return bal
}

func (account *Account) balanceAll() map[string]float64{
	return account.BalanceOf
}

// -----------
const TokenKey = "Token"

// Define the Smart Contract structure
type SmartContract struct {

}

func (s *SmartContract) Init(stub shim.ChaincodeStubInterface) pb.Response {

	token := &Token{Currency: map[string]Currency{}}

	tokenAsBytes, err := json.Marshal(token)
	err = stub.PutState(TokenKey, tokenAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Init Token %s \n", string(tokenAsBytes))
	}
	return shim.Success(nil)
}

func (s *SmartContract) Query(stub shim.ChaincodeStubInterface) pb.Response {
	function, args := stub.GetFunctionAndParameters()
	if function == "balance" {
		return s.balance(stub, args)
	} else if function == "balanceAll" {
		return s.balanceAll(stub, args)
	} else if function == "showAccount" {
		return s.showAccount(stub, args)
	}
	return shim.Error("Invalid Smart Contract function name.")
}

func (s *SmartContract) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := stub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger appropriately
	if function == "initLedger" {
		return s.initLedger(stub, args)
	} else if function == "createAccount" {
		return s.createAccount(stub, args)
	} else if function == "initCurrency" {
		return s.initCurrency(stub, args)
	} else if function == "setLock" {
		return s.setLock(stub, args)
	} else if function == "transferToken" {
		return s.transferToken(stub, args)
	} else if function == "frozenAccount" {
		return s.frozenAccount(stub, args)
	} else if function == "mintToken" {
		return s.mintToken(stub, args)
	} else if function == "balance" {
		return s.balance(stub, args)
	} else if function == "balanceAll" {
		return s.balanceAll(stub, args)
	} else if function == "showAccount" {
		return s.showAccount(stub, args)
	} else if function == "showToken" {
		return s.showToken(stub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}

func (s *SmartContract) createAccount(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	key  := args[0]
	name  := args[0]
	existAsBytes,err := stub.GetState(key)
	fmt.Printf("GetState(%s) %s \n", key, string(existAsBytes))
	if string(existAsBytes) != "" {
		fmt.Println("Failed to create account, Duplicate key.")
		return shim.Error("Failed to create account, Duplicate key.")
	}

	account := Account{
		Name: name,
		Frozen: false,
		BalanceOf: map[string]float64{}}

	accountAsBytes, _ := json.Marshal(account)
	err = stub.PutState(key, accountAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("createAccount %s \n", string(accountAsBytes))

	return shim.Success(accountAsBytes)
}
func (s *SmartContract) initLedger(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	return shim.Success(nil)
}
func (s *SmartContract) showToken(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	tokenAsBytes,err := stub.GetState(TokenKey)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("GetState(%s)) %s \n", TokenKey, string(tokenAsBytes))
	}
	return shim.Success(tokenAsBytes)
}

func (s *SmartContract) initCurrency(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	if len(args) != 4 {
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}

	_name  := args[0]
	_symbol:= args[1]
	_supply,_:= strconv.ParseFloat(args[2], 64)
	_account := args[3]

	coinbaseAsBytes,err := stub.GetState(_account)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("Coinbase before %s \n", string(coinbaseAsBytes))

	coinbase := &Account{}

	json.Unmarshal(coinbaseAsBytes, &coinbase)

	token := Token{}
	existAsBytes,err := stub.GetState(TokenKey)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("GetState(%s)) %s \n", TokenKey, string(existAsBytes))
	}
	json.Unmarshal(existAsBytes, &token)

	result := token.initialSupply(_name,_symbol,_supply, coinbase)

	tokenAsBytes, _ := json.Marshal(token)
	err = stub.PutState(TokenKey, tokenAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Init Token %s \n", string(tokenAsBytes))
	}

	coinbaseAsBytes, _ = json.Marshal(coinbase)
	err = stub.PutState(_account, coinbaseAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("Coinbase after %s \n", string(coinbaseAsBytes))

	return shim.Success(result)
}

func (s *SmartContract) transferToken(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 4 {
		return shim.Error("Incorrect number of arguments. Expecting 4")
	}
	_from 		:= args[0]
	_to			:= args[1]
	_currency 	:= args[2]
	_amount,_	:= strconv.ParseFloat(args[3], 32)

	if(_amount <= 0){
		return shim.Error("Incorrect number of amount")
	}

	fromAsBytes,err := stub.GetState(_from)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("fromAccount %s \n", string(fromAsBytes))
	fromAccount := &Account{}
	json.Unmarshal(fromAsBytes, &fromAccount)

	toAsBytes,err := stub.GetState(_to)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("toAccount %s \n", string(toAsBytes))
	toAccount := &Account{}
	json.Unmarshal(toAsBytes, &toAccount)

	tokenAsBytes,err := stub.GetState(TokenKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("Token %s \n", string(toAsBytes))
	token := Token{Currency: map[string]Currency{}}
	json.Unmarshal(tokenAsBytes, &token)

	result := token.transfer(fromAccount, toAccount, _currency, _amount)
	fmt.Printf("Result %s \n", string(result))

	fromAsBytes, err = json.Marshal(fromAccount)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutState(_from, fromAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("fromAccount %s \n", string(fromAsBytes))
	}

	toAsBytes, err = json.Marshal(toAccount)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutState(_to, toAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("toAccount %s \n", string(toAsBytes))
	}

	return shim.Success(result)
}
func (s *SmartContract) mintToken(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}
	_currency 	:= args[0]
	_amount,_	:= strconv.ParseFloat(args[1], 32)
	_account	:= args[2]

	coinbaseAsBytes,err := stub.GetState(_account)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Coinbase before %s \n", string(coinbaseAsBytes))
	}

	coinbase := &Account{}
	json.Unmarshal(coinbaseAsBytes, &coinbase)

	tokenAsBytes,err := stub.GetState(TokenKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("Token before %s \n", string(tokenAsBytes))

	token := Token{}

	json.Unmarshal(tokenAsBytes, &token)

	result := token.mint(_currency, _amount, coinbase)

	tokenAsBytes, err = json.Marshal(token)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutState(TokenKey, tokenAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("Token after %s \n", string(tokenAsBytes))

	coinbaseAsBytes, _ = json.Marshal(coinbase)
	err = stub.PutState(_account, coinbaseAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Coinbase after %s \n", string(coinbaseAsBytes))
	}

	fmt.Printf("mintToken %s \n", string(tokenAsBytes))

	return shim.Success(result)
}

func (s *SmartContract) setLock(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	_look := args[0]

	tokenAsBytes,err := stub.GetState(TokenKey)
	if err != nil {
		return shim.Error(err.Error())
	}
	// fmt.Printf("setLock - begin %s \n", string(tokenAsBytes))

	token := Token{}

	json.Unmarshal(tokenAsBytes, &token)

	if(_look == "true"){
		token.setLock(true)
	}else{
		token.setLock(false)
	}

	tokenAsBytes, err = json.Marshal(token)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutState(TokenKey, tokenAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}
	fmt.Printf("setLock - end %s \n", string(tokenAsBytes))

	return shim.Success(nil)
}
func (s *SmartContract) frozenAccount(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	_account	:= args[0]
	_status		:= args[1]

	accountAsBytes,err := stub.GetState(_account)
	if err != nil {
		return shim.Error(err.Error())
	}
	// fmt.Printf("setLock - begin %s \n", string(tokenAsBytes))

	account := Account{}

	json.Unmarshal(accountAsBytes, &account)

	var status bool
	if(_status == "true"){
		status = true;
	}else{
		status = false
	}

	account.Frozen = status

	accountAsBytes, err = json.Marshal(account)
	if err != nil {
		return shim.Error(err.Error())
	}
	err = stub.PutState(_account, accountAsBytes)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("frozenAccount - end %s \n", string(accountAsBytes))
	}

	return shim.Success(nil)
}

func (s *SmartContract) showAccount(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	_account 	:= args[0]

	accountAsBytes,err := stub.GetState(_account)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Account balance %s \n", string(accountAsBytes))
	}
	return shim.Success(accountAsBytes)
}

func (s *SmartContract) balance(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	_account 	:= args[0]
	_currency 	:= args[1]

	accountAsBytes,err := stub.GetState(_account)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Account balance %s \n", string(accountAsBytes))
	}

	account := Account{}
	json.Unmarshal(accountAsBytes, &account)
	result := account.balance(_currency)

	resultAsBytes, _ := json.Marshal(result)
	fmt.Printf("%s balance is %s \n", _account, string(resultAsBytes))	

	return shim.Success(resultAsBytes)
}

func (s *SmartContract) balanceAll(stub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	_account 	:= args[0]

	accountAsBytes,err := stub.GetState(_account)
	if err != nil {
		return shim.Error(err.Error())
	}else{
		fmt.Printf("Account balance %s \n", string(accountAsBytes))
	}

	account := Account{}
	json.Unmarshal(accountAsBytes, &account)
	result := account.balanceAll()
	resultAsBytes, _ := json.Marshal(result)
	fmt.Printf("%s balance is %s \n", _account, string(resultAsBytes))	

	return shim.Success(resultAsBytes)
}

// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}

```

## 3. 创建 package.json 文件

```

docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode install -n token3 -v 1.0 -p github.com/token
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n token3 -v 1.0 -c '{"Args":[""]}' -P "OR ('Org1MSP.member','Org2MSP.member')"
sleep 10
docker exec -e "CORE_PEER_LOCALMSPID=Org1MSP" -e "CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp" cli peer chaincode invoke -o orderer.example.com:7050 -C mychannel -n token3 -c '{"function":"createAccount","Args":["coinbase"]}'

```

## 4. 查询操作

```

[root@localhost token]# cat queryToken.js 
'use strict';

var Fabric_Client = require('fabric-client');
var path = require('path');
var util = require('util');
var os = require('os');

//
var fabric_client = new Fabric_Client();

// setup the fabric network
var channel = fabric_client.newChannel('mychannel');
var peer = fabric_client.newPeer('grpc://localhost:7051');
channel.addPeer(peer);

var member_user = null;
var store_path = path.join(__dirname, 'hfc-key-store');
console.log('Store path:'+store_path);
var tx_id = null;

Fabric_Client.newDefaultKeyValueStore({ path: store_path
}).then((state_store) => {

	fabric_client.setStateStore(state_store);
	var crypto_suite = Fabric_Client.newCryptoSuite();

	var crypto_store = Fabric_Client.newCryptoKeyStore({path: store_path});
	crypto_suite.setCryptoKeyStore(crypto_store);
	fabric_client.setCryptoSuite(crypto_suite);

	return fabric_client.getUserContext('user1', true);
}).then((user_from_store) => {
	if (user_from_store && user_from_store.isEnrolled()) {
		console.log('Successfully loaded user1 from persistence');
		member_user = user_from_store;
	} else {
		throw new Error('Failed to get user1.... run registerUser.js');
	}

	const request = {
		chaincodeId: 'token3',
		fcn: 'showAccount',
		args: ['coinbase']
	};

	// send the query proposal to the peer
	return channel.queryByChaincode(request);
}).then((query_responses) => {
	console.log("Query has completed, checking results");
	if (query_responses && query_responses.length == 1) {
		if (query_responses[0] instanceof Error) {
			console.error("error from query = ", query_responses[0]);
		} else {
			console.log("Response is ", query_responses[0].toString());
		}
	} else {
		console.log("No payloads were returned from query");
	}
}).catch((err) => {
	console.error('Failed to query successfully :: ' + err);
});		

```

核心代码

```

	const request = {
		chaincodeId: 'token3',	// 链码名称	
		fcn: 'showAccount',	//调用方法
		args: ['coinbase']	// 传递参数
	};

```

运行结果

```

[root@localhost token]# node queryToken.js 
Store path:/root/fabric-samples/fabcar/hfc-key-store
Successfully loaded user1 from persistence
Query has completed, checking results
Response is  {"BalanceOf":{},"Frozen":false,"Name":"coinbase"}

```

## 5. Event

```

chain.eventHubConnect(peerEventHosts[0],{pem:pem});
setupEvents();

/**
 * Sample method to showcase how to subscribe and consume events emitted from blockchain
 */
function setupEvents(){
    try{
	    var eh = chain.getEventHub();
	    var cid = config['chaincode']['id'];
	    var regid = eh.registerChaincodeEvent(cid, "^eventSender$", function(event) {
	        console.log(event);
	        var buffer = new Buffer(event.payload);
	        console.log(buffer.toString());
	    });
	    console.log("EVENT SETUP DONE");
	}
	catch(err){
	    console.log(err);
	    console.log("Could not setup events");
	}
}

process.on('exit', function (){
    console.log('exit called');
    chain.eventHubDisconnect();
});

```

## 6. 

## 第 28 章 fabric-sdk-java

## 1. Maven

```

<project  
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>cn.netkiller</groupId>
	<artifactId>fabric-sdk-java</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<dependencies>
		<!-- https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java -->
		<dependency>
			<groupId>org.hyperledger.fabric-sdk-java</groupId>
			<artifactId>fabric-sdk-java</artifactId>
			<version>1.0.1</version>
		</dependency>

	</dependencies>
</project>			

```

## 第 29 章 Hyperledger Explorer

克隆代码

```

git clone https://github.com/hyperledger/blockchain-explorer.git
cd blockchain-explorer

```

将 fabricexplorer.sql 导入到数据中

```

mysql -u<username> -p < db/fabricexplorer.sql	

```

设置 channel 和 数据库连接

```

 "channel": "mychannel",
 "mysql":{
      "host":"127.0.0.1",
      "database":"fabricexplorer",
      "username":"root",
      "passwd":"123456"
   }	

```

启动

```

npm install
./start.sh

```

进入 Hyperledger Explorer http://localhost:8080/

## 第 30 章 已知 Hyperledger 落地案例

## 1. 莱茨狗

莱茨狗是山寨版以太猫，底层采用 Hyperledger

[`pet-chain.baidu.com`](http://pet-chain.baidu.com)

## 第 31 章 Fabric Command

## 1. peer

### 1.1. channel

#### 1.1.1. list

列出当前 Channel

```

root@61814b46e7ee:/opt/gopath/src/github.com/chaincode/token# peer channel list
2018-03-19 08:41:25.289 UTC [msp] GetLocalMSP -> DEBU 001 Returning existing local MSP
2018-03-19 08:41:25.290 UTC [msp] GetDefaultSigningIdentity -> DEBU 002 Obtaining default signing identity
2018-03-19 08:41:25.293 UTC [channelCmd] InitCmdFactory -> INFO 003 Endorser and orderer connections initialized
2018-03-19 08:41:25.294 UTC [msp/identity] Sign -> DEBU 004 Sign: plaintext: 0A86070A5C08031A0C08B5EFBDD50510...631A0D0A0B4765744368616E6E656C73 
2018-03-19 08:41:25.294 UTC [msp/identity] Sign -> DEBU 005 Sign: digest: E4E3AB1CFD295AA881EA2AB08781EF8989CA4271FC3E2A0E6DFDDB991ECEE7F6 
2018-03-19 08:41:25.305 UTC [channelCmd] list -> INFO 006 Channels peers has joined to: 
2018-03-19 08:41:25.305 UTC [channelCmd] list -> INFO 007 mychannel 
2018-03-19 08:41:25.305 UTC [main] main -> INFO 008 Exiting.....				

```

## 第 32 章 Fabric FAQ

## 1. ERROR: manifest for hyperledger/fabric-ca:latest not found

```

ERROR: manifest for hyperledger/fabric-orderer:latest not found
ERROR: manifest for hyperledger/fabric-couchdb:latest not found
ERROR: manifest for hyperledger/fabric-ca:latest not found	
ERROR: manifest for hyperledger/fabric-tools:latest not found		

```

解决方案

```

docker pull hyperledger/fabric-membersrvc:latest \
&& docker pull hyperledger/fabric-peer:x86_64-1.0.5 \
&& docker pull hyperledger/fabric-orderer:x86_64-1.0.5 \
&& docker pull hyperledger/fabric-couchdb:x86_64-1.0.5 \
&& docker pull hyperledger/fabric-ca:x86_64-1.0.5 \
&& docker pull hyperledger/fabric-tools:x86_64-1.0.5

docker tag hyperledger/fabric-peer:x86_64-1.0.5 hyperledger/fabric-peer \
&& docker tag hyperledger/fabric-orderer:x86_64-1.0.5 hyperledger/fabric-orderer \
&& docker tag hyperledger/fabric-couchdb:x86_64-1.0.5 hyperledger/fabric-couchdb \
&& docker tag hyperledger/fabric-ca:x86_64-1.0.5 hyperledger/fabric-ca \
&& docker tag hyperledger/fabric-tools:x86_64-1.0.5 hyperledger/fabric-tools

```

## 2. 卸载 hyperledger 环境

```

docker rmi -f $(docker images -q)			

```

## 3. dseasb33srnrn.cloudfront.net 无法连接

```

error pulling image configuration: Get https://dseasb33srnrn.cloudfront.net/registry-v2/docker/registry/v2/blobs/sha256/72/72617b4fa9b4be7a5946275048f9468320220cf7bd316f0ab77946d68d24e970/data?Expires=1521480730&Signature=GKdv-Qc-hU1QLjsw5h7DrHCp11oWGZ3paa17L4CvMHx0893u-hk-klBKn7DWHnoEf4d3k9zp~OszcbVjsJsq87KlVFqWam17l7V3YvmXTPIpXEG5j4wheS5CxKRKIw8vChnm6vRwCQ3FoTEkiugXfTfLpxLOUIpB7yca3VRDbbw_&Key-Pair-Id=APKAJECH5M7VWIS5YZ6Q: dial tcp: lookup dseasb33srnrn.cloudfront.net on 211.162.77.77:53: read udp 172.16.0.17:61941->211.162.77.77:53: i/o timeout
Error response from daemon: No such image: hyperledger/fabric-ca:x86_64-1.1.0		

```

解决方案，设置 docker mirror 站点

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/virtualization/docker/registry-mirror.sh | bash

```

## 4. 超级账本的硬伤

在使用超级账本的过程中我发现一个问题，超级账本无法并发操作一个 key，stub.PutState 是异步执行，我们无法确认它是否执行完成，在没有执行完成之前再发起操作，就会产生覆盖。这个问题限制了超级账本的很多场景应用，这是超级账本的硬伤。

下面举一个例子来说明超级账本的问题

```

func (s *SmartContract) counter(stub shim.ChaincodeStubInterface, args []string) pb.Response {
	key  := "counter"
	count,err = stub.GetState(key)
	count = count + 1
	stub.PutState(key,count)
	return shim.Success(count)
}

```

使用多线程请求 chaincode 中的 counter 函数 100 次。你会发现最终 count 并不等于 100。学习过多线程的朋友一定很清楚出了什么问题。

问题出在 stub.PutState 函数 count 还没有被写入，其他线程就开始读取 stub.GetState(key)，导致读取旧数据，最终计数器数字混乱。

很多场景需要更新区块中的数据，如果频繁操作，就会产生覆盖，目前 Hyperledger Fabirc 并没有提供解决方案。

1\. 我们不知道 stub.PutState 是否执行完成，因为存储过程需要共识排序。

2\. 超级账本没有提供事物处理或者互斥锁。

golang 提供的 mutex 也无法解决上面的问题，因为 mutex 锁只能工作在一个进程中。Peer / Orderer 节点不止一个。

使用 redis 实现分布式锁或许能实现，但思考过后决定放弃，转为传统数据库。

总结，超级账本只适合一次写，多次读的场景，和极低频修改的场景