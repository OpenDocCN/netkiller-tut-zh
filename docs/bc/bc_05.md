# 部分 II. Ethereum 以太坊

## 第 9 章 以太坊

## 1. 名词解释

DAPP 去中心化应用

离线的钱包就是冷钱包，
在线的钱包就是热钱包，

从安全性角度看：冷钱包>热钱包>平台
从便捷性看：平台>热钱包>冷钱包

bip32 = hd wallets, what they are how they work
bip39 = specific type of mnemonic, and the process for turning it into a bip32 seed
bip44 = a specific format of a bip32 wallet

## 2. IBAN (International Bank Account Number)

以太坊官网的说明： [`github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol`](https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol)

### 2.1. iban：国际银行账号

iban 其英文全称为 International Bank Account Number， 即国际银行帐号。iban 的作用是为全球任意一家银行中的任意一个账户 生成一个全球唯一的账号，以便进行跨行交易。一个 iban 账号看起来像这样：

```

XE039RBH0XKV9FZMTH2701Q37FLX10NTWXU		

```

iban 地址最多可以包含 34 个字母和数字，其中的字母大小写不敏感。

iban 中包含以下信息

1.  国别码，用来标识国家，遵循 ISO3166-1 alpha-2 标准
2.  错误识别码，用来对地址进行校验，采用 mod-97-10 校验和协议，即 ISO/IEC 7064:2003 标准
3.  基本银行账号，即 BBAN（Basic Bank Account Number），用来标识银行机构、网点及 客户在该机构内的账号，这三部分信息的编码方案依赖于前面提及的国别码

### 2.2. 以太坊 iban：新的国别码和 BBAN 编码方案

以太坊引入了一个新的 IBAN 国别码：XE，其中 E 代表 Ethereum，X 代表非法币（non-jurisdictional currencies）。同时，以太坊提出了三种 BBAN 的编码格式：direct、basic 和 indirect。

direct 编码方案中的 BBAN 为 30 个字母/数字，只有一个字段：账户编号。例如，以太坊 地址 00c5496aee77c1ba1f0854206a26dda82a81d6d8 转换为 direct 方案的 BBAN 账号，就 得到 XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS。

可以使用 web3.js 中的 web3.eth.Iban.toIban() 方法来执行这一转换：

```

var Web3 = require('web3');
var web3 = new Web3();
web3.eth.Iban.toIban("0x00c5496aEe77C1bA1f0854206A26DdA82a81D6D8");

'XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS'

```

basic 编码方案与 direct 方案的唯一区别在于，其 BBAN 长度为 31 个字母/数字，因此该方案 不兼容 IBAN。

indrect 编码方案中的 BBAN 长度为 16 个字母/数字，包含三个字段

1.  资产编号，由 3 个字母/数字组成
2.  机构编号，由 4 个字母/数字组成
3.  机构内客户编号，由 9 个字母/数字组成

例如，一个采用 indrect 编码方案的以太坊 iban 账号，看起来是这样：

```

XE81ETHXREGGAVOFYORK

```

XE81ETHXREGGAVOFYORK

1.  ETH：在本例中，表示客户账户内的资产编号。目前 ETH 是唯一有效的资产编号
2.  XREG：机构编号，XREG 表示以太坊基本注册合约
3.  GAVOFYORK：机构内客户的编号

### 2.3. iban 账号与以太坊地址的转换

如前所述，使用 web3.eth.Iban.toIban()方法，可以将一个以太坊地址 转换为 direct 编码方案的 iban 账号。与之对应的，可以使用 web3.eth.Iban.toAddress()方法， 将一个采用 direct 编码方案的 iban 账号，转换回以太坊地址。例如：

```

var Web3 = require('web3');
var web3 = new Web3();
web3.eth.Iban.toAddress("XE7338O073KYGTWWZN0F2WZ0R8PX5ZPPZS");

'0x00c5496aEe77C1bA1f0854206A26DdA82a81D6D8'

```

### 2.4. 检查 iban 账号的有效性

iban 账号中的校验和用来帮助核验一个给定字符串是否为有效的 iban 账号。可以使用 web3.js 中的 web3.eth.Iban.isValid() 来进行执行校验。例如：

```

> web3.eth.Iban.isValid("XE81ETHXREGGAVOFYORK");
true

> var iban = new web3.eth.Iban("XE81ETHXREGGAVOFYORK");
undefined
> iban.isValid();
true

> web3.eth.Iban.isValid("XE82ETHXREGGAVOFYORK");
false

```

## 3. 如何计算 Gas 手续费

下面我们用实例讲解怎样计算以太坊在执行交易时花费的 gas 费用。

```

> miner.start(1)
null

```

准备两个账号

```

> eth.getBalance(eth.accounts[3])
1000000000000000000
> eth.getBalance(eth.accounts[5])
0

```

开始计算 gas 费用

```

> var estimateGas = eth.estimateGas({from:eth.accounts[1], to: eth.accounts[2], value: web3.toWei(1)})
undefined
> console.log(estimateGas)
21000
undefined
> 
> var cost = estimateGas * gasPrice
undefined
> console.log(cost)
378000000000000
undefined
> web3.fromWei(cost)
"0.000378"

```

gas 花费 0.000378 ETH

## 4. 转出账号中所有 ETH，Ethereum Wallet 中的 Send everything 实现方法

```

> personal.unlockAccount(eth.accounts[3], "12345678")
true

> eth.sendTransaction({from: eth.accounts[3], to: eth.accounts[5], value: eth.getBalance(eth.accounts[3]) - cost, gas: estimateGas})
"0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d"

```

查看交易细节

```

> web3.eth.getTransaction("0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d")
{
  blockHash: "0x59a9905831e7ae3cb9e7c6f125cf48e2688ef4b39317838f6f6b6c8837d01404",
  blockNumber: 4367,
  from: "0x8efb99ec55bcfbe2cfe47918f2d9e55fa732111f",
  gas: 21000,
  gasPrice: 18000000000,
  hash: "0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d",
  input: "0x",
  nonce: 15,
  r: "0xa297401df3a1fb0298cbc1dd609deebe9ded319fadc55934ecef4d525198215",
  s: "0x780d8c46bc8d1bb89ae9d78055307d9d68a4f89ba699ef86d3f8ba88383139a6",
  to: "0xf0688330101d53bd0c6ede2ef04d33c2010e9a5d",
  transactionIndex: 0,
  v: "0x42",
  value: 999622000000000000
}

```

现在查看 from 账号，余额已经清零。

```

> eth.getBalance(eth.accounts[3])
0		

```

## 5. （0/12 block confirmations)

```

web3.eth.blockNumber-web3.eth.getTransaction(<txhash>).blockNumber		

```

## 6. 太坊账户管理 keystore 文件

Post author: Martin Wang
Post link: http://stevenocean.github.io/2018/04/02/about-ethereum-keystore.html
Copyright Notice: All articles in this blog are licensed under CC BY-NC-SA 4.0 unless stating additionally.

### 6.1. 什么是 keystore 文件

以太坊的每个外部账户都是由一对密钥（一个公钥和一个私钥）定义的。账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20 个字节。每对私钥 /地址都编码在一个钥匙文件里，也就是我们说的 keystore 文件。该文件是 JSON 文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分，账户私钥，通常用你创建帐户时设置的密码进行加密。也就是说 keystore 文件，就是你独有的、用于签署交易的以太坊私钥的加密文件。如果你丢失了这个文件，你就丢失了私钥，意味着你失去了签署交易的能力，意味着你的资金被永久的锁定在了你的账户里。

### 6.2. keystore 文件的内容

我们先看一下 keystore 文件都包含哪些数据:

```

neo@MacBook-Pro ~/Library/Ethereum/testnet/keystore % cat UTC--2018-04-01T09-30-44.943874000Z--d5eeae04932dbc2e65b948a76a6cdfd44323a5dd
{	"address":"d5eeae04932dbc2e65b948a76a6cdfd44323a5dd",
	"crypto":{
		"cipher":"aes-128-ctr",
		"ciphertext":"16715298517abb35cb44e9a32d1f81f21ead63006c57eb0ff434318a6ea3ed3f",
		"cipherparams":{
			"iv":"1ff6fea34e682158e7660ae67960ff76"
		},
		"kdf":"scrypt",
		"kdfparams":{
			"dklen":32,
			"n":262144,
			"p":1,
			"r":8,
			"salt":"a99af42dac2363db631ef7c57a25705c7efdee73b19c11b27f9a91d41cd32d1c"
		},
		"mac":"dcd248fb996604dfcb69a86604af3992b4a9b8d20cc05e0c7608189dbbe66eda"
	},
	"id":"55edb869-1c86-4c68-924e-8247575a158b",
	"version":3
}			

```

我们可以看到大部分内容都在 crypto 字段中，这里包括：

cipher：对称 AES 算法的名称;
cipherparams：上述 cipher 算法需要的参数;
ciphertext：你的以太坊私钥使用上述 cipher 算法进行加密;
kdf：密钥生成函数，用于让你用密码加密 keystore 文件;
kdfparams：上述 kdf 算法需要的参数;
Mac：用于验证密码的代码。

### 6.3. keystore 文件如何工作的？

#### 6.3.1. 加密你的私钥

就像之前提到的，一个以太坊账户就是用于加密签署交易的一个私钥-公钥对。为了确保你的私钥没有在文件中明文存储（即任何人只要能得到这个文件就能读），使用强对称算法（cipher）对其加密至关重要。

这些对称算法使用密钥来加密数据。加密后的数据可以使用相同的方法和同样的密钥来解密，因此算法命名为对称算法。在本文中，我们称这个对称密钥为解密密钥，因为它将用于对我们的以太坊私钥进行解密。

加密过程，如下图：

| ![](img/keystore-1.png) |

以下是 cipher，cipherparams 和 ciphertext 对应的概念：

1.  cipher: 是用于加密以太坊私钥的对称加密算法。此处 cipher 用的是 aes-128-ctr 加密模式。

2.  cipherparams: 是 aes-128-ctr 加密算法需要的参数。在这里，用到的唯一的参数 iv，是 aes-128-ctr 加密算法需要的初始化向量。

3.  ciphertext: 密文是 aes-128-ctr 函数的加密输入。

在这里，你已经有了进行解密以太坊私钥计算所需要的一切。但是我们首先要取回解密密钥。

#### 6.3.2. 用你的密码来保护它

要确保解锁你的账户很容易，你不需要记住你的每一个又长又非用户友好型的用于解密 ciphertext 密文解密密钥。相反，以太坊开发者选择了基于密码的保护，也就是说你只需要输入密码就能拿回解密密钥。

为了能做到这一点，以太坊用了一个密钥生成函数，输入密码和一系列参数就能计算解密密钥。

这就是 kdf 和 kdfparams 的用途：

1.  kdf: 是一个密钥生成函数，根据你的密码计算（或者取回）解密密钥。在这里，kdf 用的是 scrypt 算法。

2.  kdfparams: 是 scrypt 函数需要的参数。在这里，简单来说，dklen、n、r、p 和 salt 是 kdf 函数的参数。

在这里，用 kdfparams 参数对 scrypt 函数进行调整，反馈到我们的密码中，你就会得到解密密钥也就是密钥生成函数的输出。

| ![](img/keystore-2.png) |

#### 6.3.3. 确认输入的密码是正确的

这就是 keystore 文件中 mac 值起作用的地方。在密钥生成函数执行之后，它的输出（解密密钥）和 ciphertext 密文就被处理，并且和 mac（就像一种认可的印章）作比较。如果结果和 mac 相同，那么密码就是正确的，并且解密就可以开始了。

| ![](img/keystore-3.png) |

#### 6.3.4. 将这三步结合起来

首先，你输入了密码，这个密码作为 kdf 密钥生成函数的输入，来计算解密密钥。然后，刚刚计算出的解密密钥和 ciphertext 密文连接并进行处理，和 mac 比较来确保密码是正确的。最后，通过 cipher 对称函数用解密密钥对 ciphertext 密文解密。

| ![](img/keystore-4.png) |

就像你从图中可以看到的，整个过程可以看做一个黑盒（不过，图中是个灰盒），你的密码是惟一的输入，你的以太坊私钥是惟一的输出。所需的其他信息都可以在你的以太坊账户创建时生成的 keystore 文件中获得。

## 7. 批量转账遇到的问题与解决方案

有时我们需要将 Token 发送到多个地址上去。通常的做法就是使用 web.js 写一个循环程序，但是实际使用过程中发现这种做法存在很多问题，常会发生转账失败情况。

经过分析造成发送失败原因是，频率太高，因为 web.js 是异步操作，当前程序还未完成交易，交易尚未确认的情况下第二笔交易发送出去，这时就会出错。

```

web3.eth.getTransactionCount(from).then(function(nonce){
	// 问题就出在 nonce ， nonce 如同数据库中的序列主键，如果上一个交易没有完成，下一个交易取得 nonce + 1 后与上一个 pending 的交易相同，产生冲突
}		

```

最好的解方案是在合约中实现批量转账功能，这样需要一个交易 txhash 完成多比交易。

如果你的 Token 已经在使用了，且没有批量转账的功能怎么解决呢？我们可以在写一个 Token 继承原来的 Token，在新的 Token 中实现批量转账功能

```

Function: batchTransfer(address[] _to, uint256[] _value)

MethodID: 0x88d695b2
[0]:  0000000000000000000000000000000000000000000000000000000000000040
[1]:  00000000000000000000000000000000000000000000000000000000000000a0
[2]:  0000000000000000000000000000000000000000000000000000000000000002
[3]:  000000000000000000000000372967130b1a7cd386348bc59de905e628e36f3a
[4]:  000000000000000000000000372967130b1a7cd386348bc59de905e628e36f3b
[5]:  0000000000000000000000000000000000000000000000000000000000000002
[6]:  000000000000000000000000000000000000000000000000000000000000000c
[7]:  0000000000000000000000000000000000000000000000000000000000000022		

```

## 8. 代币兑换

兑换代币通常是指使用 ETH 或者其他币兑换 Token，我是这样实现的，使用智能合约，将 ETH 达到指定合约地址，合约会打回代币给用户。

```

User --> Wallet --> transfer ETH --> contract Address 
           ^                              |
           |                              |
           +----------- Token ------------+	

```

这种方式不用人工参与，也不用开发程序。缺点不能时时汇率，需要人工设置汇率。

## 第 10 章 以太坊私链入门

本文所用软件版本

*   geth v.1.8.13

*   truffle v4.0.6

*   web3.js v1.0.0

*   Solidity Version: 0.4.24

## 1. 软件安装与配置

### 1.1. Ubuntu

#### 1.1.1. 安装 geth

安装环境

Ubuntu 17.10

```

sudo apt upgrade -y
sudo apt install software-properties-common
sudo add-apt-repository -y ppa:ethereum/ethereum
sudo apt update
sudo apt install ethereum			

```

```

neo@netkiller ~ % geth version
Geth
Version: 1.8.10-stable
Git Commit: 4bb3c89d44e372e6a9ab85a8be0c9345265c763a
Architecture: amd64
Protocol Versions: [63 62]
Network Id: 1
Go Version: go1.9.5
Operating System: linux
GOPATH=
GOROOT=/usr/lib/go-1.9

```

#### 1.1.2. 安装 solc

```

sudo apt install solc -y

```

```

neo@netkiller ~ % solc --version
solc, the solidity compiler commandline interface
Version: 0.4.19+commit.c4cbbb05.Linux.g++				

```

#### 1.1.3. Node.js

```

curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
sudo apt-get install -y nodejs				

```

### 1.2. CentOS 7

```

yum update -y
yum install git wget bzip2 -y	
yum install golang -y

cd /usr/local/src
git clone https://github.com/ethereum/go-ethereum.git
cd go-ethereum/
gmake all
mv build /srv/go-ethereum

echo "export PATH=$PATH:$PWD/build/bin" >> /etc/profile
source /etc/profile		

```

上面安装版本是 unstable 版本，如果是生产环境请使用 Release 版本 [`github.com/ethereum/go-ethereum/tags`](https://github.com/ethereum/go-ethereum/tags)

```

wget https://github.com/ethereum/go-ethereum/archive/v1.8.10.tar.gz
tar zxvf v1.8.10.tar.gz
cd go-ethereum-1.8.10/
gmake all

mv build /srv/go-ethereum-1.8.10

```

### 1.3. Windows

```

访问 https://geth.ethereum.org/downloads/
下载并安装 Geth for Windows				

```

### 1.4. Mac OS

```

brew update
brew upgrade				
brew tap ethereum/ethereum
brew install ethereum
brew install solidity

```

#### 1.4.1. 安装 Node

```

brew install node
brew install npm
npm config set registry https://registry.npm.taobao.org

```

#### 1.4.2. Ethereum Wallet

下载安装以太坊钱包（大陆网络可能下载有问题，需要翻墙）

[`github.com/ethereum/mist/releases/download/v0.9.3/Ethereum-Wallet-macosx-0-9-3.dmg`](https://github.com/ethereum/mist/releases/download/v0.9.3/Ethereum-Wallet-macosx-0-9-3.dmg)

### 1.5. 编译安装

```

git clone https://github.com/ethereum/go-ethereum
sudo apt-get install -y build-essential golang
cd go-ethereum
make geth

```

### 1.6. Netkiller OSCM 一键安装

Netkiller OSCM 是由 Netkiller 制作的一套自动化安装脚本。

适用于 CentOS 7

#### 1.6.1. 1.8.10

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/centos/go-ethereum-1.8.10.sh | bash			

```

安装完成后使用下面命令进入控制台

```

[root@localhost ~]# su - ethereum
Last login: Sat Feb  3 00:23:52 EST 2018 on pts/0

[ethereum@localhost ~]$ geth attach
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.10-stable/linux-amd64/go1.8.10
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> 

```

#### 1.6.2. 1.8.1

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/centos/go-ethereum-1.8.1.sh | bash

```

#### 1.6.3. 1.8.10

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/gcc/gcc.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/golang/golang-1.10.2.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/centos/go-ethereum-1.8.10.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/systemd/private.sh | bash

curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/node.js/binrary/node-v10.1.0.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/node.js/binrary/profile.d.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/truffle/truffle.sh | bash

```

### 1.7. 防止 geth 异常退出

在同步主网的过程中，我们发现经常出现 geth 崩溃退出，为了防止异常退出，我们写了这个脚本。

```

[ethereum@netkiller ~]$ cat run.sh 
#!/bin/bash
for (( ; ; ))
do
	#geth --syncmode light --cache 2048 --maxpeers 200
	# geth --syncmode light --cache 2048 --maxpeers 200 --rpc --rpcaddr 0.0.0.0 --rpcport 7545 --rpcapi web3,admin,eth,personal --port 30303 2> /tmp/geth.log
	geth --datadir private --networkid 44444 --port 30302 --mine --rpc
	#geth --testnet --syncmode light --cache 2048 --maxpeers 200 --rpc 2> /tmp/geth.log
	sleep 10

done &

```

## 2. 创世区块

```

cd ~
mkdir -p ethereum
cd ethereum		

```

### 2.1. 初始化创世区块

创建文件 genesis.json

```

{
  "nonce": "0x0000000000000042",
  "difficulty": "0x020000",
  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "timestamp": "0x00",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  "gasLimit": "0x4c4b40",
  "config": {
      "chainId": 15,
      "homesteadBlock": 0,
      "eip155Block": 0,
      "eip158Block": 0
  },
  "alloc": { }
}

```

mixhash: 与 nonce 配合用于挖矿，由上一个区块的一部分生成的 hash。注意他和 nonce 的设置需要满足以太坊的 Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。.

nonce: nonce 就是一个 64 位随机数，用于挖矿，注意他和 mixhash 的设置需要满足以太坊的 Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。

difficulty: 设置当前区块的难度，如果难度过大，cpu 挖矿就很难，这里设置较小难度

alloc: 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。

coinbase: 矿工的账号，随便填

timestamp: 设置创世块的时间戳

parentHash: 上一个区块的 hash 值，因为是创世块，所以这个值是 0

extraData: 附加信息，随便填，可以填你的个性信息

gasLimit: 该值设置对 GAS 的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。

初始化创世区块

```

neo@netkiller ~/ethereum % geth init genesis.json 
WARN [01-19|17:35:17] No etherbase set and no accounts found as default 
INFO [01-19|17:35:17] Allocated cache and file handles         database=/home/neo/.ethereum/geth/chaindata cache=16 handles=16
INFO [01-19|17:35:17] Writing custom genesis block 
INFO [01-19|17:35:17] Successfully wrote genesis state         database=chaindata                          hash=611596…424d04
INFO [01-19|17:35:17] Allocated cache and file handles         database=/home/neo/.ethereum/geth/lightchaindata cache=16 handles=16
INFO [01-19|17:35:18] Writing custom genesis block 
INFO [01-19|17:35:18] Successfully wrote genesis state         database=lightchaindata                          hash=611596…424d04		

```

默认目录是 /home/neo/.ethereum/ 你可以通过 --datadir 参数指定目录

```

neo@netkiller ~/ethereum % geth --datadir data init genesis.json
WARN [01-19|17:38:16] No etherbase set and no accounts found as default 
INFO [01-19|17:38:16] Allocated cache and file handles         database=/home/neo/ethereum/data/geth/chaindata cache=16 handles=16
INFO [01-19|17:38:17] Writing custom genesis block 
INFO [01-19|17:38:17] Successfully wrote genesis state         database=chaindata                              hash=611596…424d04
INFO [01-19|17:38:17] Allocated cache and file handles         database=/home/neo/ethereum/data/geth/lightchaindata cache=16 handles=16
INFO [01-19|17:38:17] Writing custom genesis block 
INFO [01-19|17:38:17] Successfully wrote genesis state         database=lightchaindata                              hash=611596…424d04		

neo@netkiller ~/ethereum % find data 
data
data/keystore
data/geth
data/geth/chaindata
data/geth/chaindata/LOCK
data/geth/chaindata/LOG
data/geth/chaindata/MANIFEST-000000
data/geth/chaindata/CURRENT
data/geth/chaindata/000001.log
data/geth/lightchaindata
data/geth/lightchaindata/LOCK
data/geth/lightchaindata/LOG
data/geth/lightchaindata/MANIFEST-000000
data/geth/lightchaindata/CURRENT
data/geth/lightchaindata/000001.log		

```

目录结构

```

data
├── geth
│  ├── chaindata
│  │  ├── 000001.log
│  │  ├── CURRENT
│  │  ├── LOCK
│  │  ├── LOG
│  │  └── MANIFEST-000000
│  └── lightchaindata
│      ├── 000001.log
│      ├── CURRENT
│      ├── LOCK
│      ├── LOG
│      └── MANIFEST-000000
└── keystore		

```

### 2.2. 创建主账号

```

neo@netkiller ~/ethereum % geth account new
Your new account is locked with a password. Please give a password. Do not forget this password.
Passphrase: 
Repeat passphrase: 
Address: {39211a30bfe33d4b12fcbd786472c8a552b93389}			

```

### 提示

密码可以直接回车，但是后面 Ethereum Wallet 遇到了麻烦， Ethereum Wallet 要求密码必须是 8 为数

### 2.3. 启动节点

```

neo@netkiller ~/ethereum % geth --networkid 123456 --rpc --rpccorsdomain "*" --nodiscover console 
WARN [01-19|17:47:06] No etherbase set and no accounts found as default 
INFO [01-19|17:47:06] Starting peer-to-peer node               instance=Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5
INFO [01-19|17:47:06] Allocated cache and file handles         database=/home/neo/.ethereum/geth/chaindata cache=128 handles=1024
INFO [01-19|17:47:06] Initialised chain configuration          config="{ChainID: 15 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: <nil> EIP155: 0 EIP158: 0 Byzantium: <nil> Engine: unknown}"
INFO [01-19|17:47:06] Disk storage enabled for ethash caches   dir=/home/neo/.ethereum/geth/ethash count=3
INFO [01-19|17:47:06] Disk storage enabled for ethash DAGs     dir=/home/neo/.ethash               count=2
INFO [01-19|17:47:06] Initialising Ethereum protocol           versions="[63 62]" network=123456
INFO [01-19|17:47:06] Loaded most recent local header          number=0 hash=611596…424d04 td=131072
INFO [01-19|17:47:06] Loaded most recent local full block      number=0 hash=611596…424d04 td=131072
INFO [01-19|17:47:06] Loaded most recent local fast block      number=0 hash=611596…424d04 td=131072
INFO [01-19|17:47:06] Loaded local transaction journal         transactions=0 dropped=0
INFO [01-19|17:47:06] Regenerated local transaction journal    transactions=0 accounts=0
INFO [01-19|17:47:06] Starting P2P networking 
INFO [01-19|17:47:06] RLPx listener up                         self="enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@[::]:30303?discport=0"
INFO [01-19|17:47:06] IPC endpoint opened: /home/neo/.ethereum/geth.ipc 
INFO [01-19|17:47:06] HTTP endpoint opened: http://127.0.0.1:8545 
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> INFO [01-19|17:47:09] Mapped network port                      proto=tcp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"			

```

identity: 区块链的标示，随便填写，用于标示目前网络的名字

init: 指定创世块文件的位置，并创建初始块

datadir: 设置当前区块链网络数据存放的位置

port: 网络监听端口

rpc: 启动 rpc 通信，可以进行智能合约的部署和调试

rpcapi: 设置允许连接的 rpc 的客户端，一般为 db,eth,net,web3

networkid: 设置当前区块链的网络 ID，用于区分不同的网络，是一个数字

console: 启动命令行模式，可以在 Geth 中执行命令

### 2.4. 使用节点进行挖矿

#### 2.4.1. 启动矿工开始挖矿

```

> miner.start(1)		

```

这里的 1 表示只使用一个线程运行,第一次运行时将开始创建 DAG 文件，只需等待进度条到 100，则将开始挖矿。 实际你看到的挖矿速度很快，这是因为我们已经在初始化创世区块时配置为:"nonce": "0x0000000000000042"。 “0x42”难度能让你在私有测试网链上快速挖以太币。

### 提示

挖矿时必然有矿工账户，而系统默认使用创建的第一个账号。

```

> miner.start(1)
INFO [01-19|21:06:43] Updated mining threads                   threads=1
INFO [01-19|21:06:43] Transaction pool price threshold updated price=18000000000
INFO [01-19|21:06:43] Starting mining operation 
null
> INFO [01-19|21:06:43] Commit new mining work                   number=1 txs=0 uncles=0 elapsed=717.552µs
INFO [01-19|21:06:46] Generating ethash verification cache     epoch=0 percentage=91 elapsed=3.000s
INFO [01-19|21:06:46] Generated ethash verification cache      epoch=0 elapsed=3.273s
INFO [01-19|21:06:51] Generating DAG in progress               epoch=0 percentage=0  elapsed=5.056s
INFO [01-19|21:06:56] Generating DAG in progress               epoch=0 percentage=1  elapsed=10.140s
INFO [01-19|21:07:01] Generating DAG in progress               epoch=0 percentage=2  elapsed=15.119s
INFO [01-19|21:07:06] Generating DAG in progress               epoch=0 percentage=3  elapsed=19.924s
INFO [01-19|21:07:11] Generating DAG in progress               epoch=0 percentage=4  elapsed=24.739s
INFO [01-19|21:07:16] Generating DAG in progress               epoch=0 percentage=5  elapsed=29.473s
INFO [01-19|21:07:22] Generating DAG in progress               epoch=0 percentage=6  elapsed=35.641s
INFO [01-19|21:07:26] Generating DAG in progress               epoch=0 percentage=7  elapsed=40.374s
INFO [01-19|21:07:31] Generating DAG in progress               epoch=0 percentage=8  elapsed=45.134s
INFO [01-19|21:07:36] Generating DAG in progress               epoch=0 percentage=9  elapsed=49.908s
INFO [01-19|21:07:41] Generating DAG in progress               epoch=0 percentage=10 elapsed=54.633s	
......
......
......
INFO [01-19|21:22:43] Generated ethash verification cache      epoch=0 elapsed=15m57.328s
INFO [01-19|21:22:47] Generating ethash verification cache     epoch=1 percentage=17 elapsed=3.031s
INFO [01-19|21:22:50] Generating ethash verification cache     epoch=1 percentage=34 elapsed=6.056s
INFO [01-19|21:22:53] Generating ethash verification cache     epoch=1 percentage=49 elapsed=9.562s
INFO [01-19|21:22:57] Generating ethash verification cache     epoch=1 percentage=70 elapsed=13.115s
INFO [01-19|21:23:00] Generating ethash verification cache     epoch=1 percentage=90 elapsed=16.123s
INFO [01-19|21:23:01] Generated ethash verification cache      epoch=1 elapsed=17.576s
INFO [01-19|21:23:19] Generating DAG in progress               epoch=1 percentage=0  elapsed=18.198s
INFO [01-19|21:23:32] Successfully sealed new block            number=1 hash=e2b5b9…9b1bfe
INFO [01-19|21:23:32] 🔨 mined potential block                  number=1 hash=e2b5b9…9b1bfe
INFO [01-19|21:23:32] Commit new mining work                   number=2 txs=0 uncles=0 elapsed=1.188ms
INFO [01-19|21:23:37] Generating DAG in progress               epoch=1 percentage=1  elapsed=35.913s
INFO [01-19|21:23:41] Successfully sealed new block            number=2 hash=62db3f…e27b50
INFO [01-19|21:23:41] 🔨 mined potential block                  number=2 hash=62db3f…e27b50
INFO [01-19|21:23:41] Commit new mining work                   number=3 txs=0 uncles=0 elapsed=772.239µs
INFO [01-19|21:23:43] Successfully sealed new block            number=3 hash=34384b…c387f2
INFO [01-19|21:23:43] 🔨 mined potential block                  number=3 hash=34384b…c387f2
INFO [01-19|21:23:43] Commit new mining work                   number=4 txs=0 uncles=0 elapsed=1.002ms
INFO [01-19|21:23:55] Generating DAG in progress               epoch=1 percentage=2  elapsed=53.757s
INFO [01-19|21:24:13] Generating DAG in progress               epoch=1 percentage=3  elapsed=1m11.561s
INFO [01-19|21:24:30] Generating DAG in progress               epoch=1 percentage=4  elapsed=1m28.986s
INFO [01-19|21:24:30] Successfully sealed new block            number=4 hash=681970…462135
INFO [01-19|21:24:30] 🔨 mined potential block                  number=4 hash=681970…462135
INFO [01-19|21:24:30] Commit new mining work                   number=5 txs=0 uncles=0 elapsed=833.629µs
INFO [01-19|21:24:36] Successfully sealed new block            number=5 hash=7b058b…d2f07a
INFO [01-19|21:24:36] 🔨 mined potential block                  number=5 hash=7b058b…d2f07a
INFO [01-19|21:24:36] Commit new mining work                   number=6 txs=0 uncles=0 elapsed=897.815µs
INFO [01-19|21:24:43] Successfully sealed new block            number=6 hash=a5fc3d…b1221e
INFO [01-19|21:24:43] 🔗 block reached canonical chain          number=1 hash=e2b5b9…9b1bfe
INFO [01-19|21:24:43] 🔨 mined potential block                  number=6 hash=a5fc3d…b1221e
INFO [01-19|21:24:43] Commit new mining work                   number=7 txs=0 uncles=0 elapsed=758.061µs
INFO [01-19|21:24:47] Successfully sealed new block            number=7 hash=003b02…e886fd
INFO [01-19|21:24:47] 🔗 block reached canonical chain          number=2 hash=62db3f…e27b50
INFO [01-19|21:24:47] 🔨 mined potential block                  number=7 hash=003b02…e886fd
INFO [01-19|21:24:47] Commit new mining work                   number=8 txs=0 uncles=0 elapsed=920.862µs
INFO [01-19|21:24:48] Generating DAG in progress               epoch=1 percentage=5  elapsed=1m46.827s
INFO [01-19|21:25:06] Generating DAG in progress               epoch=1 percentage=6  elapsed=2m4.338s
INFO [01-19|21:25:23] Successfully sealed new block            number=8 hash=fd23c9…361c65
INFO [01-19|21:25:23] 🔗 block reached canonical chain          number=3 hash=34384b…c387f2
INFO [01-19|21:25:23] 🔨 mined potential block                  number=8 hash=fd23c9…361c65
INFO [01-19|21:25:23] Commit new mining work                   number=9 txs=0 uncles=0 elapsed=825.737µs
INFO [01-19|21:25:23] Generating DAG in progress               epoch=1 percentage=7  elapsed=2m22.061s

```

#### 2.4.2. 停止挖矿

```

> miner.stop()
true
>

```

#### 2.4.3. 查看所挖金额

```

> eth.getBalance(eth.accounts[0])
70000000000000000000				

```

### 2.5. 在创世链中制定矿工账号并为它充值

```

  "alloc": {
    "0xe8abf98484325fd6afc59b804ac15804b978e607": {
      "balance": "300000"
    },
    "0x013b5e735e1b48421dd3de3b931d6f03e769e22b": {
      "balance": "400000"
    }
  }		

```

## 3. Blockchain explorer (区块链浏览器)

[`github.com/ethereumproject/explorer`](https://github.com/ethereumproject/explorer)

## 4. 单机多实例演示

在没有条件安装虚拟机也没有多台服务器的情况下我们可以使用一台服务器运行多个实例的方法也可以实现多个节点运行环境。

```

cd ~
mkdir -p ethereum
cd ethereum
mkdir data{1,2}

```

创建文件 genesis.json

```

{
  "nonce": "0x0000000000000042",
  "difficulty": "0x020000",
  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "timestamp": "0x00",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  "gasLimit": "0x4c4b40",
  "config": {
      "chainId": 15,
      "homesteadBlock": 0,
      "eip155Block": 0,
      "eip158Block": 0
  },
  "alloc": { }
}			

```

### 4.1. 实例一

```

geth --datadir ~/ethereum/data1 init genesis.json
geth --datadir="~/ethereum/data1" --networkid 123456 --port 30301 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --rpcport 8541		

```

启动后终端输出

```

neo@netkiller ~/ethereum % geth --datadir ~/ethereum/data1 init genesis.json
WARN [02-02|22:09:56] No etherbase set and no accounts found as default 
INFO [02-02|22:09:56] Allocated cache and file handles         database=/home/neo/ethereum/data1/geth/chaindata cache=16 handles=16
INFO [02-02|22:09:56] Writing custom genesis block 
INFO [02-02|22:09:56] Successfully wrote genesis state         database=chaindata                               hash=611596…424d04
INFO [02-02|22:09:56] Allocated cache and file handles         database=/home/neo/ethereum/data1/geth/lightchaindata cache=16 handles=16
INFO [02-02|22:09:57] Writing custom genesis block 
INFO [02-02|22:09:57] Successfully wrote genesis state         database=lightchaindata                               hash=611596…424d04

neo@netkiller ~ % geth --datadir="~/ethereum/data1" --networkid 123456 --port 30301 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" -rpcport 8541             
WARN [02-02|22:36:02] No etherbase set and no accounts found as default 
INFO [02-02|22:36:02] Starting peer-to-peer node               instance=Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5
INFO [02-02|22:36:02] Allocated cache and file handles         database=/home/neo/ethereum/data1/geth/chaindata cache=128 handles=1024
INFO [02-02|22:36:02] Initialised chain configuration          config="{ChainID: 15 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: <nil> EIP155: 0 EIP158: 0 Byzantium: <nil> Engine: unknown}"
INFO [02-02|22:36:02] Disk storage enabled for ethash caches   dir=/home/neo/ethereum/data1/geth/ethash count=3
INFO [02-02|22:36:02] Disk storage enabled for ethash DAGs     dir=/home/neo/.ethash                    count=2
INFO [02-02|22:36:02] Initialising Ethereum protocol           versions="[63 62]" network=123456
INFO [02-02|22:36:02] Loaded most recent local header          number=0 hash=611596…424d04 td=131072
INFO [02-02|22:36:02] Loaded most recent local full block      number=0 hash=611596…424d04 td=131072
INFO [02-02|22:36:02] Loaded most recent local fast block      number=0 hash=611596…424d04 td=131072
INFO [02-02|22:36:02] Loaded local transaction journal         transactions=0 dropped=0
INFO [02-02|22:36:02] Regenerated local transaction journal    transactions=0 accounts=0
INFO [02-02|22:36:02] Starting P2P networking 
INFO [02-02|22:36:05] UDP listener up                          self=enode://53433417f11d1d9a17f155cbaad2c4ec375af7b141e2989f049b572fc3f856d78f254e58fa82ed6eab48a16b7d625527214522ec0fd3e3af030b5b8dfdadc062@14.103.209.119:30301
INFO [02-02|22:36:05] HTTP endpoint opened: http://0.0.0.0:8541 
INFO [02-02|22:36:05] IPC endpoint opened: /home/neo/ethereum/data1/geth.ipc 
INFO [02-02|22:36:05] RLPx listener up                         self=enode://53433417f11d1d9a17f155cbaad2c4ec375af7b141e2989f049b572fc3f856d78f254e58fa82ed6eab48a16b7d625527214522ec0fd3e3af030b5b8dfdadc062@14.103.209.119:30301
INFO [02-02|22:36:05] Mapped network port                      proto=udp extport=30301 intport=30301 interface="UPNP IGDv1-IP1"
INFO [02-02|22:36:07] Mapped network port                      proto=tcp extport=30301 intport=30301 interface="UPNP IGDv1-IP1"

```

### 4.2. 实例二

```

geth --datadir ~/ethereum/data2 init genesis.json
geth --datadir="~/ethereum/data2" --networkid 123456 --port 30302 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --rpcport 8542		

```

启动后控制台输出与实例一类似

### 4.3. 添加节点

开启一个新终端窗口，运行下面命令查看节点一的 enode 字符串

```

geth --exec 'admin.nodeInfo.enode' attach ethereum/data1/geth.ipc
"enode://53433417f11d1d9a17f155cbaad2c4ec375af7b141e2989f049b572fc3f856d78f254e58fa82ed6eab48a16b7d625527214522ec0fd3e3af030b5b8dfdadc062@[::]:30301?discport=0"				

```

进入节点二，并连接到节点一。

```

neo@netkiller ~ % geth attach ethereum/data2/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> admin.addPeer("enode://53433417f11d1d9a17f155cbaad2c4ec375af7b141e2989f049b572fc3f856d78f254e58fa82ed6eab48a16b7d625527214522ec0fd3e3af030b5b8dfdadc062@[::]:30302")
true
> admin.addPeer("enode://53433417f11d1d9a17f155cbaad2c4ec375af7b141e2989f049b572fc3f856d78f254e58fa82ed6eab48a16b7d625527214522ec0fd3e3af030b5b8dfdadc062@[::]:30301")
true

```

查看节点

```

> admin.peers
[{
    caps: ["eth/63"],
    id: "53433417f11d1d9a17f155cbaad2c4ec375af7b141e2989f049b572fc3f856d78f254e58fa82ed6eab48a16b7d625527214522ec0fd3e3af030b5b8dfdadc062",
    name: "Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5",
    network: {
      localAddress: "[::1]:51250",
      remoteAddress: "[::1]:30301"
    },
    protocols: {
      eth: {
        difficulty: 131072,
        head: "0x611596e7979cd4e7ca1531260fa706093a5492ecbdf58f20a39545397e424d04",
        version: 63
      }
    }
}]

```

至此，节点已经添加完毕。

```

> exit				

```

退出

### 4.4. 节点测试

这里我们实现两个节点间的以太币转账。

现在两个节点上都没有任何账号

```

neo@netkiller ~ % geth --exec 'personal.listAccounts' attach ethereum/data1/geth.ipc                                        
[]
neo@netkiller ~ % geth --exec 'personal.listAccounts' attach ethereum/data2/geth.ipc
[]

```

在两个节点上分别创建两个账号，一个是矿工账号，另一个是普通账号。

```

neo@netkiller ~ % geth --exec 'personal.newAccount("abc123")' attach ethereum/data1/geth.ipc
"0x5ad227e8d7e460713c78eebbe558473571edae72"

neo@netkiller ~ % geth --exec 'personal.newAccount("abc123")' attach ethereum/data1/geth.ipc
"0x3e822e05ee975e02be3f15f32b0fddced8d5bdd0"

neo@netkiller ~ % geth --exec 'personal.listAccounts' attach ethereum/data1/geth.ipc 
["0x5ad227e8d7e460713c78eebbe558473571edae72", "0x3e822e05ee975e02be3f15f32b0fddced8d5bdd0"]

neo@netkiller ~ % geth --exec 'personal.newAccount("abc123")' attach ethereum/data2/geth.ipc
"0xa6df3e3c141e27726f4aeb21a5dab2e5c76c9565"

neo@netkiller ~ % geth --exec 'personal.newAccount("abc123")' attach ethereum/data2/geth.ipc
"0xa66c7b8b1c26856d284a0b962385babe02caa51d"

neo@netkiller ~ % geth --exec 'personal.listAccounts' attach ethereum/data2/geth.ipc 
["0xa6df3e3c141e27726f4aeb21a5dab2e5c76c9565", "0xa66c7b8b1c26856d284a0b962385babe02caa51d"]

```

启动挖矿

```

geth --exec 'miner.start(1)' attach ethereum/data1/geth.ipc 
geth --exec 'miner.start(1)' attach ethereum/data2/geth.ipc 

```

如果正常运行，两个节点上的矿工账号都会有一定的以太币。而普通账号额度应该为零。

```

neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[0])' attach ethereum/data1/geth.ipc
299438256000000000000

neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[1])' attach ethereum/data1/geth.ipc
0

neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[1])' attach ethereum/data1/geth.ipc
298000056000000000000

neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[1])' attach ethereum/data2/geth.ipc
0				

```

我们尝试从节点一矿工账号向节点二上的普通用户转账。

```

neo@netkiller ~ % geth attach ethereum/data1/geth.ipc                               
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5
coinbase: 0x5ad227e8d7e460713c78eebbe558473571edae72
at block: 144 (Fri, 02 Feb 2018 23:24:35 HST)
 datadir: /home/neo/ethereum/data1
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> personal.listAccounts
["0x5ad227e8d7e460713c78eebbe558473571edae72"]

> personal.unlockAccount(eth.accounts[0], "abc123")
true

> eth.sendTransaction({from: "0x5ad227e8d7e460713c78eebbe558473571edae72", to: "0xa66c7b8b1c26856d284a0b962385babe02caa51d", value: web3.toWei(1, "ether")})
"0x87c059d0769c8a74499ddd08c04a10f23b7681651615a28098d73ec63a943684"

> eth.pendingTransactions
[{
    blockHash: null,
    blockNumber: null,
    from: "0x5ad227e8d7e460713c78eebbe558473571edae72",
    gas: 90000,
    gasPrice: 18000000000,
    hash: "0x87c059d0769c8a74499ddd08c04a10f23b7681651615a28098d73ec63a943684",
    input: "0x",
    nonce: 2,
    r: "0xce004f964f268a00e90cadd4e8a685131aa34f37144f7e2e47dc7fe4ec784e55",
    s: "0x412209c18513a28422e62c4bdb85a223f190e133cf71990a87c570a3a53ae093",
    to: "0xa66c7b8b1c26856d284a0b962385babe02caa51d",
    transactionIndex: 0,
    v: "0x41",
    value: 1000000000000000000
}]

```

稍后一会，当使用 eth.pendingTransactions 查看挂起交易为空的时候，表示已经处理完毕。这时退出控制台。

```

> eth.pendingTransactions
[]
> exit				

```

现在查看节点二上的第二个普通账号余额

```

neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[1])' attach ethereum/data2/geth.ipc
1000000000000000000

```

转账成功

现在我们从节点二上的普通用户向节点一上的普通用户转账。

```

neo@netkiller ~ % geth attach ethereum/data2/geth.ipc                                        
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.10-stable-4bb3c89d/linux-amd64/go1.9.5
coinbase: 0xa6df3e3c141e27726f4aeb21a5dab2e5c76c9565
at block: 319 (Fri, 02 Feb 2018 23:50:07 HST)
 datadir: /home/neo/ethereum/data2
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> personal.unlockAccount(eth.accounts[1], "abc123")
true

> eth.sendTransaction({from: "0xa66c7b8b1c26856d284a0b962385babe02caa51d", to: "0x3e822e05ee975e02be3f15f32b0fddced8d5bdd0", value: web3.toWei(0.1, "ether")})
"0x951bd161dfd000ff825379cb0644c4acd4afd4d3e1ac4f4c1c6009b3c2a1d366"

> eth.pendingTransactions
[]
> exit		

```

查看两个普通账号的余额

```

neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[1])' attach ethereum/data1/geth.ipc
100000000000000000
neo@netkiller ~ % geth --exec 'eth.getBalance(eth.accounts[1])' attach ethereum/data2/geth.ipc
899622000000000000

```

## 5. 使用 pm2 启动以太坊

```

npm install -g pm2

```

创建 ~/geth.json 文件

```

[
  {
    "name"              : "geth",
    "cwd"               : "/usr/bin/",
    "script"            : "geth",
    "args"              : "--rpcapi eth,web3 --rpc --dev --datadir /home/neo/ethereum",
    "log_date_format"   : "YYYY-MM-DD HH:mm Z",
    "out_file"      : "/home/neo/ethereum/log/geth_out.log",
    "error_file"    : "/home/neo/ethereum/log/geth_err.log",
    "log_file"      : "/home/neo/ethereum/log/geth_log.log",
    "merge_logs"        : false,
    "watch"             : false,
    "max_restarts"      : 10,
    "exec_interpreter"  : "none",
    "exec_mode"         : "fork_mode"
  }
]

```

启动以太坊

```

pm2 start geth.json

```

## 第 11 章 geth v1.8.16 命令详解

[`geth.ethereum.org`](https://geth.ethereum.org)

版本号

```

neo@MacBook-Pro ~/ethereum/web3 % geth version
Geth
Version: 1.8.16-stable
Architecture: amd64
Protocol Versions: [63 62]
Network Id: 1
Go Version: go1.10
Operating System: darwin
GOPATH=
GOROOT=/usr/local/opt/go/libexec		

```

帮助信息

```

neo@MacBook-Pro ~/ethereum/web3 % geth --help
NAME:
   geth - the go-ethereum command line interface

   Copyright 2013-2017 The go-ethereum Authors

USAGE:
   geth [options] command [command options] [arguments...]

VERSION:
   1.8.16-stable

COMMANDS:
   account     Manage accounts
   attach      Start an interactive JavaScript environment (connect to node)
   bug         opens a window to report a bug on the geth repo
   console     Start an interactive JavaScript environment
   copydb      Create a local chain from a target chaindata folder
   dump        Dump a specific block from storage
   dumpconfig  Show configuration values
   export      Export blockchain into file
   import      Import a blockchain file
   init        Bootstrap and initialize a new genesis block
   js          Execute the specified JavaScript files
   license     Display license information
   makecache   Generate ethash verification cache (for testing)
   makedag     Generate ethash mining DAG (for testing)
   monitor     Monitor and visualize node metrics
   removedb    Remove blockchain and state databases
   version     Print version numbers
   wallet      Manage Ethereum presale wallets
   help, h     Shows a list of commands or help for one command

ETHEREUM OPTIONS:
  --config value                           TOML configuration file
  --datadir "/Users/neo/Library/Ethereum"  Data directory for the databases and keystore
  --keystore                               Directory for the keystore (default = inside the datadir)
  --nousb                                  Disables monitoring for and managing USB hardware wallets
  --networkid value                        Network identifier (integer, 1=Frontier, 2=Morden (disused), 3=Ropsten, 4=Rinkeby) (default: 1)
  --testnet                                Ropsten network: pre-configured proof-of-work test network
  --rinkeby                                Rinkeby network: pre-configured proof-of-authority test network
  --syncmode "fast"                        Blockchain sync mode ("fast", "full", or "light")
  --gcmode value                           Blockchain garbage collection mode ("full", "archive") (default: "full")
  --ethstats value                         Reporting URL of a ethstats service (nodename:secret@host:port)
  --identity value                         Custom node name
  --lightserv value                        Maximum percentage of time allowed for serving LES requests (0-90) (default: 0)
  --lightpeers value                       Maximum number of LES client peers (default: 100)
  --lightkdf                               Reduce key-derivation RAM & CPU usage at some expense of KDF strength

DEVELOPER CHAIN OPTIONS:
  --dev               Ephemeral proof-of-authority network with a pre-funded developer account, mining enabled
  --dev.period value  Block period to use in developer mode (0 = mine only if transaction pending) (default: 0)

ETHASH OPTIONS:
  --ethash.cachedir                     Directory to store the ethash verification caches (default = inside the datadir)
  --ethash.cachesinmem value            Number of recent ethash caches to keep in memory (16MB each) (default: 2)
  --ethash.cachesondisk value           Number of recent ethash caches to keep on disk (16MB each) (default: 3)
  --ethash.dagdir "/Users/neo/.ethash"  Directory to store the ethash mining DAGs (default = inside home folder)
  --ethash.dagsinmem value              Number of recent ethash mining DAGs to keep in memory (1+GB each) (default: 1)
  --ethash.dagsondisk value             Number of recent ethash mining DAGs to keep on disk (1+GB each) (default: 2)

TRANSACTION POOL OPTIONS:
  --txpool.nolocals            Disables price exemptions for locally submitted transactions
  --txpool.journal value       Disk journal for local transaction to survive node restarts (default: "transactions.rlp")
  --txpool.rejournal value     Time interval to regenerate the local transaction journal (default: 1h0m0s)
  --txpool.pricelimit value    Minimum gas price limit to enforce for acceptance into the pool (default: 1)
  --txpool.pricebump value     Price bump percentage to replace an already existing transaction (default: 10)
  --txpool.accountslots value  Minimum number of executable transaction slots guaranteed per account (default: 16)
  --txpool.globalslots value   Maximum number of executable transaction slots for all accounts (default: 4096)
  --txpool.accountqueue value  Maximum number of non-executable transaction slots permitted per account (default: 64)
  --txpool.globalqueue value   Maximum number of non-executable transaction slots for all accounts (default: 1024)
  --txpool.lifetime value      Maximum amount of time non-executable transaction are queued (default: 3h0m0s)

PERFORMANCE TUNING OPTIONS:
  --cache value            Megabytes of memory allocated to internal caching (default: 1024)
  --cache.database value   Percentage of cache memory allowance to use for database io (default: 75)
  --cache.gc value         Percentage of cache memory allowance to use for trie pruning (default: 25)
  --trie-cache-gens value  Number of trie node generations to keep in memory (default: 120)

ACCOUNT OPTIONS:
  --unlock value    Comma separated list of accounts to unlock
  --password value  Password file to use for non-interactive password input

API AND CONSOLE OPTIONS:
  --rpc                  Enable the HTTP-RPC server
  --rpcaddr value        HTTP-RPC server listening interface (default: "localhost")
  --rpcport value        HTTP-RPC server listening port (default: 8545)
  --rpcapi value         API's offered over the HTTP-RPC interface
  --ws                   Enable the WS-RPC server
  --wsaddr value         WS-RPC server listening interface (default: "localhost")
  --wsport value         WS-RPC server listening port (default: 8546)
  --wsapi value          API's offered over the WS-RPC interface
  --wsorigins value      Origins from which to accept websockets requests
  --ipcdisable           Disable the IPC-RPC server
  --ipcpath              Filename for IPC socket/pipe within the datadir (explicit paths escape it)
  --rpccorsdomain value  Comma separated list of domains from which to accept cross origin requests (browser enforced)
  --rpcvhosts value      Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard. (default: "localhost")
  --jspath loadScript    JavaScript root path for loadScript (default: ".")
  --exec value           Execute JavaScript statement
  --preload value        Comma separated list of JavaScript files to preload into the console

NETWORKING OPTIONS:
  --bootnodes value     Comma separated enode URLs for P2P discovery bootstrap (set v4+v5 instead for light servers)
  --bootnodesv4 value   Comma separated enode URLs for P2P v4 discovery bootstrap (light server, full nodes)
  --bootnodesv5 value   Comma separated enode URLs for P2P v5 discovery bootstrap (light server, light nodes)
  --port value          Network listening port (default: 30303)
  --maxpeers value      Maximum number of network peers (network disabled if set to 0) (default: 25)
  --maxpendpeers value  Maximum number of pending connection attempts (defaults used if set to 0) (default: 0)
  --nat value           NAT port mapping mechanism (any|none|upnp|pmp|extip:<IP>) (default: "any")
  --nodiscover          Disables the peer discovery mechanism (manual peer addition)
  --v5disc              Enables the experimental RLPx V5 (Topic Discovery) mechanism
  --netrestrict value   Restricts network communication to the given IP networks (CIDR masks)
  --nodekey value       P2P node key file
  --nodekeyhex value    P2P node key as hex (for testing)

MINER OPTIONS:
  --mine                    Enable mining
  --minerthreads value      Number of CPU threads to use for mining (default: 8)
  --etherbase value         Public address for block mining rewards (default = first account created) (default: "0")
  --targetgaslimit value    Target gas limit sets the artificial target gas floor for the blocks to mine (default: 4712388)
  --gasprice "18000000000"  Minimal gas price to accept for mining a transactions
  --extradata value         Block extra data set by the miner (default = client version)

GAS PRICE ORACLE OPTIONS:
  --gpoblocks value      Number of recent blocks to check for gas prices (default: 20)
  --gpopercentile value  Suggested gas price is the given percentile of a set of recent transaction gas prices (default: 60)

VIRTUAL MACHINE OPTIONS:
  --vmdebug  Record information useful for VM and contract debugging

LOGGING AND DEBUGGING OPTIONS:
  --metrics                 Enable metrics collection and reporting
  --fakepow                 Disables proof-of-work verification
  --nocompaction            Disables db compaction after import
  --verbosity value         Logging verbosity: 0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)
  --vmodule value           Per-module verbosity: comma-separated list of <pattern>=<level> (e.g. eth/*=5,p2p=4)
  --backtrace value         Request a stack trace at a specific logging statement (e.g. "block.go:271")
  --debug                   Prepends log messages with call-site location (file and line number)
  --pprof                   Enable the pprof HTTP server
  --pprofaddr value         pprof HTTP server listening interface (default: "127.0.0.1")
  --pprofport value         pprof HTTP server listening port (default: 6060)
  --memprofilerate value    Turn on memory profiling with the given rate (default: 524288)
  --blockprofilerate value  Turn on block profiling with the given rate (default: 0)
  --cpuprofile value        Write CPU profile to the given file
  --trace value             Write execution trace to the given file

WHISPER (EXPERIMENTAL) OPTIONS:
  --shh                       Enable Whisper
  --shh.maxmessagesize value  Max message size accepted (default: 1048576)
  --shh.pow value             Minimum POW accepted (default: 0.2)

DEPRECATED OPTIONS:
  --fast   Enable fast syncing through state downloads
  --light  Enable light client mode

MISC OPTIONS:
  --help, -h  show help

COPYRIGHT:
   Copyright 2013-2017 The go-ethereum Authors		

```

中文翻译

命令:
account    管理账户
attach     启动交互式 JavaScript 环境（连接到节点）
bug        上报 bug Issues
console    启动交互式 JavaScript 环境
copydb     从文件夹创建本地链
dump       Dump（分析）一个特定的块存储
dumpconfig 显示配置值
export     导出区块链到文件
import     导入一个区块链文件
init       启动并初始化一个新的创世纪块
js         执行指定的 JavaScript 文件(多个)
license    显示许可信息
makecache  生成 ethash 验证缓存(用于测试)
makedag    生成 ethash 挖矿 DAG(用于测试)
monitor    监控和可视化节点指标
removedb   删除区块链和状态数据库
version    打印版本号
wallet     管理 Ethereum 预售钱包
help,h     显示一个命令或帮助一个命令列表
ETHEREUM 选项:
--config value          TOML 配置文件
--datadir “xxx”         数据库和 keystore 密钥的数据目录
--keystore              keystore 存放目录(默认在 datadir 内)
--nousb                 禁用监控和管理 USB 硬件钱包
--networkid value       网络标识符(整型, 1=Frontier, 2=Morden (弃用), 3=Ropsten, 4=Rinkeby) (默认: 1)
--testnet               Ropsten 网络:预先配置的 POW(proof-of-work)测试网络
--rinkeby               Rinkeby 网络: 预先配置的 POA(proof-of-authority)测试网络
--syncmode "fast"       同步模式 ("fast", "full", or "light")
--ethstats value        上报 ethstats service  URL (nodename:secret@host:port)
--identity value        自定义节点名
--lightserv value       允许 LES 请求时间最大百分比(0 – 90)(默认值:0) 
--lightpeers value      最大 LES client peers 数量(默认值:20)
--lightkdf              在 KDF 强度消费时降低 key-derivation RAM&CPU 使用
开发者（模式）选项:
--dev               使用 POA 共识网络，默认预分配一个开发者账户并且会自动开启挖矿。
--dev.period value  开发者模式下挖矿周期 (0 = 仅在交易时) (默认: 0)
ETHASH 选项:
--ethash.cachedir                        ethash 验证缓存目录(默认 = datadir 目录内)
--ethash.cachesinmem value               在内存保存的最近的 ethash 缓存个数  (每个缓存 16MB ) (默认: 2)
--ethash.cachesondisk value              在磁盘保存的最近的 ethash 缓存个数 (每个缓存 16MB) (默认: 3)
--ethash.dagdir ""                       存 ethash DAGs 目录 (默认 = 用户 hom 目录)
--ethash.dagsinmem value                 在内存保存的最近的 ethash DAGs 个数 (每个 1GB 以上) (默认: 1)
--ethash.dagsondisk value                在磁盘保存的最近的 ethash DAGs 个数 (每个 1GB 以上) (默认: 2)
交易池选项:
--txpool.nolocals            为本地提交交易禁用价格豁免
--txpool.journal value       本地交易的磁盘日志：用于节点重启 (默认: "transactions.rlp")
--txpool.rejournal value     重新生成本地交易日志的时间间隔 (默认: 1 小时)
--txpool.pricelimit value    加入交易池的最小的 gas 价格限制(默认: 1)
--txpool.pricebump value     价格波动百分比（相对之前已有交易） (默认: 10)
--txpool.accountslots value  每个帐户保证可执行的最少交易槽数量  (默认: 16)
--txpool.globalslots value   所有帐户可执行的最大交易槽数量 (默认: 4096)
--txpool.accountqueue value  每个帐户允许的最多非可执行交易槽数量 (默认: 64)
--txpool.globalqueue value   所有帐户非可执行交易最大槽数量  (默认: 1024)
--txpool.lifetime value      非可执行交易最大入队时间(默认: 3 小时)
性能调优的选项:
--cache value                分配给内部缓存的内存 MB 数量，缓存值(最低 16 mb /数据库强制要求)(默认:128)
--trie-cache-gens value      保持在内存中产生的 trie node 数量(默认:120)
帐户选项:
--unlock value              需解锁账户用逗号分隔
--password value            用于非交互式密码输入的密码文件
API 和控制台选项:
--rpc                       启用 HTTP-RPC 服务器
--rpcaddr value             HTTP-RPC 服务器接口地址(默认值:“localhost”)
--rpcport value             HTTP-RPC 服务器监听端口(默认值:8545)
--rpcapi value              基于 HTTP-RPC 接口提供的 API
--ws                        启用 WS-RPC 服务器
--wsaddr value              WS-RPC 服务器监听接口地址(默认值:“localhost”)
--wsport value              WS-RPC 服务器监听端口(默认值:8546)
--wsapi  value              基于 WS-RPC 的接口提供的 API
--wsorigins value           websockets 请求允许的源
--ipcdisable                禁用 IPC-RPC 服务器
--ipcpath                   包含在 datadir 里的 IPC socket/pipe 文件名(转义过的显式路径)
--rpccorsdomain value       允许跨域请求的域名列表(逗号分隔)(浏览器强制)
--jspath loadScript         JavaScript 加载脚本的根路径(默认值:“.”)
--exec value                执行 JavaScript 语句(只能结合 console/attach 使用)
--preload value             预加载到控制台的 JavaScript 文件列表(逗号分隔)
网络选项:
--bootnodes value    用于 P2P 发现引导的 enode urls(逗号分隔)(对于 light servers 用 v4+v5 代替)
--bootnodesv4 value  用于 P2P v4 发现引导的 enode urls(逗号分隔) (light server, 全节点)
--bootnodesv5 value  用于 P2P v5 发现引导的 enode urls(逗号分隔) (light server, 轻节点)
--port value         网卡监听端口(默认值:30303)
--maxpeers value     最大的网络节点数量(如果设置为 0，网络将被禁用)(默认值:25)
--maxpendpeers value    最大尝试连接的数量(如果设置为 0，则将使用默认值)(默认值:0)
--nat value             NAT 端口映射机制 (any|none|upnp|pmp|extip:<IP>) (默认: “any”)
--nodiscover            禁用节点发现机制(手动添加节点)
--v5disc                启用实验性的 RLPx V5(Topic 发现)机制
--nodekey value         P2P 节点密钥文件
--nodekeyhex value      十六进制的 P2P 节点密钥(用于测试)
矿工选项:
--mine                  打开挖矿
--minerthreads value    挖矿使用的 CPU 线程数量(默认值:8)
--etherbase value       挖矿奖励地址(默认=第一个创建的帐户)(默认值:“0”)
--targetgaslimit value  目标 gas 限制：设置最低 gas 限制（低于这个不会被挖？） (默认值:“4712388”)
--gasprice value        挖矿接受交易的最低 gas 价格
--extradata value       矿工设置的额外块数据(默认=client version)
GAS 价格选项:
--gpoblocks value      用于检查 gas 价格的最近块的个数  (默认: 10)
--gpopercentile value  建议 gas 价参考最近交易的 gas 价的百分位数，(默认: 50)
虚拟机的选项:
--vmdebug        记录 VM 及合约调试信息
日志和调试选项:
--metrics            启用 metrics 收集和报告
--fakepow            禁用 proof-of-work 验证
--verbosity value    日志详细度:0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)
--vmodule value      每个模块详细度:以 <pattern>=<level>的逗号分隔列表 (比如 eth/*=6,p2p=5)
--backtrace value    请求特定日志记录堆栈跟踪 (比如 “block.go:271”)
--debug                     突出显示调用位置日志(文件名及行号)
--pprof                     启用 pprof HTTP 服务器
--pprofaddr value           pprof HTTP 服务器监听接口(默认值:127.0.0.1)
--pprofport value           pprof HTTP 服务器监听端口(默认值:6060)
--memprofilerate value      按指定频率打开 memory profiling    (默认:524288)
--blockprofilerate value    按指定频率打开 block profiling    (默认值:0)
--cpuprofile value          将 CPU profile 写入指定文件
--trace value               将 execution trace 写入指定文件
WHISPER 实验选项:
--shh                        启用 Whisper
--shh.maxmessagesize value   可接受的最大的消息大小 (默认值: 1048576)
--shh.pow value              可接受的最小的 POW (默认值: 0.2)
弃用选项：
--fast     开启快速同步
--light    启用轻客户端模式
其他选项:
–help, -h    显示帮助

## 1. api 相关参数

rpcapi 启动后允许连接到系统的 API 协议

```

geth --networkid 100000 --rpc --rpcapi "db,eth,net,web3" --rpccorsdomain "*" --datadir "/app/chain" --port "30303" console	

```

系统默认监听 127.0.0.1 如果希望外部访问本机，需要通过--rpcaddr 指定监听地址。

```

geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --nodiscover		

```

### 1.1. rpcapi

--rpcapi 可以控制访问内容

```

$ geth --rpc --rpcapi personal,db,eth,net,web3 --rinkeby	

```

### 1.2. rpcaddr

默认是 127.0.0.1

HTTP endpoint closed: http://127.0.0.1:8545

通过 --rpcaddr="0.0.0.0" 指定监听地址

HTTP endpoint opened: http://0.0.0.0:8545

```

neo@netkiller ~/ethereum % geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --nodiscover console  
INFO [01-20|01:41:33] Starting peer-to-peer node               instance=Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1
INFO [01-20|01:41:33] Allocated cache and file handles         database=/home/neo/.ethereum/geth/chaindata cache=128 handles=1024
INFO [01-20|01:41:34] Initialised chain configuration          config="{ChainID: 15 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: <nil> EIP155: 0 EIP158: 0 Byzantium: <nil> Engine: unknown}"
INFO [01-20|01:41:34] Disk storage enabled for ethash caches   dir=/home/neo/.ethereum/geth/ethash count=3
INFO [01-20|01:41:34] Disk storage enabled for ethash DAGs     dir=/home/neo/.ethash               count=2
INFO [01-20|01:41:34] Initialising Ethereum protocol           versions="[63 62]" network=123456
INFO [01-20|01:41:34] Loaded most recent local header          number=531 hash=1a2707…3a27bc td=79083846
INFO [01-20|01:41:34] Loaded most recent local full block      number=531 hash=1a2707…3a27bc td=79083846
INFO [01-20|01:41:34] Loaded most recent local fast block      number=531 hash=1a2707…3a27bc td=79083846
INFO [01-20|01:41:34] Loaded local transaction journal         transactions=0 dropped=0
INFO [01-20|01:41:34] Regenerated local transaction journal    transactions=0 accounts=0
WARN [01-20|01:41:34] Blockchain not empty, fast sync disabled 
INFO [01-20|01:41:34] Starting P2P networking 
INFO [01-20|01:41:34] RLPx listener up                         self="enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@[::]:30303?discport=0"
INFO [01-20|01:41:34] IPC endpoint opened: /home/neo/.ethereum/geth.ipc 
INFO [01-20|01:41:34] HTTP endpoint opened: http://0.0.0.0:8545 
Welcome to the Geth JavaScript console!

instance: Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1
coinbase: 0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6
at block: 531 (Tue, 14 Nov 2017 17:36:05 HST)
 datadir: /home/neo/.ethereum
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> INFO [01-20|01:41:40] Mapped network port                      proto=tcp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"

```

## 2. 启动 Websocket 端口

```

geth --syncmode light --rpc --rpcaddr 0.0.0.0 --rpcapi web3,eth --ws --wsaddr 0.0.0.0 --wsapi web3,eth --wsorigins '*'

```

安装 websocket 测试工具 wscat

```

npm install -g wscat

```

测试 Websocket

```

wscat -c ws://127.0.0.1:8546

```

## 3. 日志

--verbosity 日志输出级别控制

```

geth --verbosity 0 console

```

日志输出到文件中。

```

geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*"  2>> /tmp/geth.log			

```

后台运行

```

neo@netkiller ~ % geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" 2>> /tmp/geth.log &     
[1] 30075

neo@netkiller ~ % tail -f /tmp/geth.log        
INFO [02-02|21:18:59] Got interrupt, shutting down... 
INFO [02-02|21:18:59] HTTP endpoint closed: http://0.0.0.0:8545 
INFO [02-02|21:18:59] IPC endpoint closed: /home/neo/.ethereum/geth.ipc 
INFO [02-02|21:18:59] Blockchain manager stopped 
INFO [02-02|21:18:59] Stopping Ethereum protocol 
INFO [02-02|21:18:59] Ethereum protocol stopped 
INFO [02-02|21:18:59] Transaction pool stopped 
INFO [02-02|21:18:59] Database closed                          database=/home/neo/.ethereum/geth/chaindata
INFO [02-02|21:18:59] Mapped network port                      proto=tcp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"
WARN [02-02|21:19:00] Already shutting down, interrupt more to panic. times=9			

```

## 4. 控制台

### Geth JavaScript console

```

neo@netkiller ~/ethereum % geth  --networkid 123456 console
INFO [01-19|22:14:52] Starting peer-to-peer node               instance=Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1
INFO [01-19|22:14:52] Allocated cache and file handles         database=/home/neo/.ethereum/geth/chaindata cache=128 handles=1024
INFO [01-19|22:14:52] Initialised chain configuration          config="{ChainID: 15 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: <nil> EIP155: 0 EIP158: 0 Byzantium: <nil> Engine: unknown}"
INFO [01-19|22:14:52] Disk storage enabled for ethash caches   dir=/home/neo/.ethereum/geth/ethash count=3
INFO [01-19|22:14:52] Disk storage enabled for ethash DAGs     dir=/home/neo/.ethash               count=2
INFO [01-19|22:14:52] Initialising Ethereum protocol           versions="[63 62]" network=123456
INFO [01-19|22:14:52] Loaded most recent local header          number=14 hash=70d7f1…45850a td=1966848
INFO [01-19|22:14:52] Loaded most recent local full block      number=14 hash=70d7f1…45850a td=1966848
INFO [01-19|22:14:52] Loaded most recent local fast block      number=14 hash=70d7f1…45850a td=1966848
INFO [01-19|22:14:52] Loaded local transaction journal         transactions=0 dropped=0
INFO [01-19|22:14:52] Regenerated local transaction journal    transactions=0 accounts=0
WARN [01-19|22:14:52] Blockchain not empty, fast sync disabled 
INFO [01-19|22:14:52] Starting P2P networking 

INFO [01-19|22:14:56] UDP listener up                          self=enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@101.232.64.12:30303
INFO [01-19|22:14:56] RLPx listener up                         self=enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@101.232.64.12:30303
INFO [01-19|22:14:56] IPC endpoint opened: /home/neo/.ethereum/geth.ipc 
Welcome to the Geth JavaScript console!

instance: Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1
coinbase: 0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6
at block: 14 (Fri, 19 Jan 2018 21:27:16 HST)
 datadir: /home/neo/.ethereum
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> 
> INFO [01-19|22:14:56] Mapped network port                      proto=udp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"			

```

## 5. 连接控制台

一般测试启动我们使用 console，如果是正式启动无需使用 console。同事我们使用&符号使其进入后台运行。

```

neo@netkiller ~/ethereum % geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --nodiscover &			

```

进入控制台

```

neo@netkiller ~/ethereum % geth attach
Welcome to the Geth JavaScript console!

instance: Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1
coinbase: 0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6
at block: 531 (Tue, 14 Nov 2017 17:36:05 HST)
 datadir: /home/neo/.ethereum
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

```

退出控制台

```

> exit

```

### 5.1. 指定 geth.ipc 文件位置

```

geth --ipcpath ~/.ethereum/geth.ipc attach				

```

### 5.2. IPC 方式连接

```

neo@netkiller ~ % geth attach ethereum/data1/geth.ipc 
Welcome to the Geth JavaScript console!

instance: Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

>				

```

### 5.3. TCP 连接控制台

连接远程控制台

```

neo@netkiller ~/ethereum % geth --exec 'eth.coinbase' attach http://172.16.0.10:8545
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"

```

### 5.4. WebSocket 方式

```

$ geth attach ws://191.168.1.1:8546

```

## 6. 账号管理

### 6.1. 新建账号

查看账号

```

neo@netkiller ~/ethereum % geth account list 
Account #0: {83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6} keystore:///home/neo/.ethereum/keystore/UTC--2018-01-20T04-04-06.786586541Z--83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6				

```

创建账号

```

neo@netkiller ~/ethereum % geth account new
Your new account is locked with a password. Please give a password. Do not forget this password.
Passphrase: 
Repeat passphrase: 
Address: {e8abf98484325fd6afc59b804ac15804b978e607}				

```

指定密码

```

$ echo "abc123" > password 
$ geth --password /path/to/password account new

```

账号创建在 ~/.ethereum/keystore 目录下

```

Mac: ~/Library/Ethereum/keystore
Linux: ~/.ethereum/keystore
Windows: %APPDATA%/Ethereum/keystore				

```

```

neo@netkiller ~/.ethereum/keystore % ll
total 8.0K
-rw------- 1 neo neo 491 Jan 19 18:04 UTC--2018-01-20T04-04-06.786586541Z--83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6
-rw------- 1 neo neo 491 Jan 19 20:11 UTC--2018-01-20T06-11-23.608902164Z--e8abf98484325fd6afc59b804ac15804b978e607				

```

### 6.2. 查看账号

```

neo@netkiller ~/ethereum % geth account list 
Account #0: {83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6} keystore:///home/neo/.ethereum/keystore/UTC--2018-01-20T04-04-06.786586541Z--83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6
Account #1: {e8abf98484325fd6afc59b804ac15804b978e607} keystore:///home/neo/.ethereum/keystore/UTC--2018-01-20T06-11-23.608902164Z--e8abf98484325fd6afc59b804ac15804b978e607				

```

### 6.3. 从私钥导入以太坊地址

首先将私钥存储到文件中，然后导入，导入后需要输入密码。

```

[ethereum@netkiller ~]$ echo "f592b7bf06ca9fd7696ba95d6ed8e357de6a2379b6d5fe1ffd53c6b4b063cd4a" > privatekey
[ethereum@netkiller ~]$ geth account import privatekey
INFO [04-27|17:25:38] Maximum peer count                       ETH=25 LES=0 total=25
Your new account is locked with a password. Please give a password. Do not forget this password.
Passphrase:
Repeat passphrase:
Address: {372fda02e8a1eca513f2ee5901dc55b8b5dd7411}

```

查看导入文件

```

[ethereum@netkiller ~]$ ls .ethereum/keystore/*372fda02e8a1eca513f2ee5901dc55b8b5dd7411
.ethereum/keystore/UTC--2018-04-27T09-25-48.189741023Z--372fda02e8a1eca513f2ee5901dc55b8b5dd7411

[ethereum@netkiller ~]$ cat .ethereum/keystore/UTC--2018-04-27T09-25-48.189741023Z--372fda02e8a1eca513f2ee5901dc55b8b5dd7411
{"address":"372fda02e8a1eca513f2ee5901dc55b8b5dd7411","crypto":{"cipher":"aes-128-ctr","ciphertext":"8e23a0274a4d91bea61273ee3ce2951c292698df13b2214e8afab5c9595a72c4","cipherparams":{"iv":"c5f4fd65e6b6da4f83d30f8d327905d1"},"kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"593eb041c4425723af7ef58a55c03fc875749cd0f7174ce011047e41205e6cdd"},"mac":"e1f3bebd85632db39aaa6ff03fa7641109c1fe46cfcc4251c32d27ad002343eb"},"id":"ca863875-0702-49a8-b5c5-c46a50b95375","version":3}

```

最后一定记得删除私钥问题，因为这个私钥没有加密过，一旦泄露后果不堪设想。

```

[ethereum@netkiller ~]$ rm -rf privatekey

```

如果不存储文件可以单行执行，然后删除 history 历史文件

```

[ethereum@netkiller ~]$ geth account import <(echo f592b7bf06ca9fd7696ba95d6ed8e357de6a2379b6d5fe1ffd53c6b4b063cd4a)
[ethereum@netkiller ~]$ >.bash_history

```

## 7. 配置自动解锁账号

创建 password 文件，在里面输入密码，每个账号一行密码如：

```

123456
123456
123456			

```

启动参数

```

geth --rpc --rpcaddr="0.0.0.0" --rpccorsdomain="*" --unlock '0,1,2' --password ~/.ethereum/password   --nodiscover --maxpeers '5' --networkid '12345' --datadir '~/.ethereum'  console			

```

```

neo@MacBook-Pro ~/ethereum % geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --mine --minerthreads 1 --unlock 0 --password ./password
INFO [02-28|22:51:25] Maximum peer count                       ETH=25 LES=0 total=25
INFO [02-28|22:51:25] Starting peer-to-peer node               instance=Geth/v1.8.1-stable/darwin-amd64/go1.10
INFO [02-28|22:51:25] Allocated cache and file handles         database=/Users/neo/Library/Ethereum/geth/chaindata cache=768 handles=128
INFO [02-28|22:51:25] Initialised chain configuration          config="{ChainID: 15 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: <nil> EIP155: 0 EIP158: 0 Byzantium: <nil> Engine: unknown}"
INFO [02-28|22:51:25] Disk storage enabled for ethash caches   dir=/Users/neo/Library/Ethereum/geth/ethash count=3
INFO [02-28|22:51:25] Disk storage enabled for ethash DAGs     dir=/Users/neo/.ethash                      count=2
INFO [02-28|22:51:25] Initialising Ethereum protocol           versions="[63 62]" network=123456
WARN [02-28|22:51:25] Head state missing, repairing chain      number=5373 hash=6a2b1b…9e3c38
INFO [02-28|22:51:25] Rewound blockchain to past state         number=5372 hash=f6900d…59872d
INFO [02-28|22:51:25] Loaded most recent local header          number=5373 hash=6a2b1b…9e3c38 td=2246785401
INFO [02-28|22:51:25] Loaded most recent local full block      number=5372 hash=f6900d…59872d td=2246064913
INFO [02-28|22:51:25] Loaded most recent local fast block      number=5373 hash=6a2b1b…9e3c38 td=2246785401
INFO [02-28|22:51:25] Loaded local transaction journal         transactions=0 dropped=0
INFO [02-28|22:51:25] Regenerated local transaction journal    transactions=0 accounts=0
WARN [02-28|22:51:25] Blockchain not empty, fast sync disabled 
INFO [02-28|22:51:25] Starting P2P networking 
INFO [02-28|22:51:28] UDP listener up                          self=enode://f4e5cee0be36c8823423d3115c488f29f82b5f95c02a796cd80c4f47078726e0b2dc5b95407469275fb52a24ff0fb95b2a32f38d6eb95f417a2f65268d4e3fa8@[::]:30303
INFO [02-28|22:51:28] RLPx listener up                         self=enode://f4e5cee0be36c8823423d3115c488f29f82b5f95c02a796cd80c4f47078726e0b2dc5b95407469275fb52a24ff0fb95b2a32f38d6eb95f417a2f65268d4e3fa8@[::]:30303
INFO [02-28|22:51:28] IPC endpoint opened                      url=/Users/neo/Library/Ethereum/geth.ipc
INFO [02-28|22:51:28] HTTP endpoint opened                     url=http://0.0.0.0:8545                  cors=* vhosts=localhost
WARN [02-28|22:51:28] ------------------------------------------------------------------- 
WARN [02-28|22:51:28] Referring to accounts by order in the keystore folder is dangerous! 
WARN [02-28|22:51:28] This functionality is deprecated and will be removed in the future! 
WARN [02-28|22:51:28] Please use explicit addresses! (can search via `geth account list`) 
WARN [02-28|22:51:28] ------------------------------------------------------------------- 
INFO [02-28|22:51:29] Unlocked account                         address=0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7
INFO [02-28|22:51:29] Transaction pool price threshold updated price=18000000000
INFO [02-28|22:51:29] Etherbase automatically configured       address=0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7
INFO [02-28|22:51:29] Starting mining operation 
INFO [02-28|22:51:29] Commit new mining work                   number=5373 txs=0 uncles=0 elapsed=403.127µs
INFO [02-28|22:51:38] Successfully sealed new block            number=5373 hash=f70a5d…fe9b7b
INFO [02-28|22:51:38] 🔨 mined potential block                  number=5373 hash=f70a5d…fe9b7b

```

## 8. 运行 JS

```

neo@netkiller ~/ethereum % geth --exec "eth.blockNumber" attach
531

```

```

$ geth --exec 'loadScript("/tmp/checkbalances.js")' attach http://123.123.123.123:8545
$ geth --jspath "/tmp" --exec 'loadScript("checkbalances.js")' attach http://123.123.123.123:8545			

```

## 9. 节点管理

```

geth --bootnodes enode://pubkey1@ip1:port1,enode://pubkey2@ip2:port2,enode://pubkey3@ip3:port3

```

## 10. 启动挖矿

```

geth --mine

```

### 10.1. 挖矿线程数

默认为 2

```

geth --mine --minerthreads=16

```

### 10.2. 指定旷工账号

默认是第一个账号

```

geth --mine --minerthreads=16 --etherbase=0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6			

```

## 11. 运行智能合约

```

pragma solidity ⁰.4.18;

contract Netkiller {
    string name;
    int num;
    function Netkiller() public{
        name = "default";
        num = 1;
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
    function setNum(int n) public{
        num = n;
    }
    function addNum(int m) public view returns(int res){
        res = m + num;
    }
}

```

```

solc --bin --abi --optimize -o output Netkiller.sol

```

var abi = JSON.parse('内容来自 Netkiller.abi')

var bytecode = "0x"+"内容来自 Netkiller.bin"

```

var abi = JSON.parse('[{"constant":true,"inputs":[],"name":"getName","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"n","type":"int256"}],"name":"setNum","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_name","type":"string"}],"name":"setName","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"m","type":"int256"}],"name":"addNum","outputs":[{"name":"res","type":"int256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]');
var bytecode = "0x6060604052341561000f57600080fd5b6040805190810160405280600781526020017f64656661756c74000000000000000000000000000000000000000000000000008152506000908051906020019061005a929190610067565b506001808190555061010c565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106100a857805160ff19168380011785556100d6565b828001600101855582156100d6579182015b828111156100d55782518255916020019190600101906100ba565b5b5090506100e391906100e7565b5090565b61010991905b808211156101055760008160009055506001016100ed565b5090565b90565b61036b8061011b6000396000f300606060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806317d7de7c146100675780636a5aa5ec146100f5578063c47f002714610118578063cc13962a14610175575b600080fd5b341561007257600080fd5b61007a6101ac565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100ba57808201518184015260208101905061009f565b50505050905090810190601f1680156100e75780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561010057600080fd5b6101166004808035906020019091905050610254565b005b341561012357600080fd5b610173600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061025e565b005b341561018057600080fd5b6101966004808035906020019091905050610278565b6040518082815260200191505060405180910390f35b6101b4610286565b60008054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561024a5780601f1061021f5761010080835404028352916020019161024a565b820191906000526020600020905b81548152906001019060200180831161022d57829003601f168201915b5050505050905090565b8060018190555050565b806000908051906020019061027492919061029a565b5050565b600060015482019050919050565b602060405190810160405280600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106102db57805160ff1916838001178555610309565b82800160010185558215610309579182015b828111156103085782518255916020019190600101906102ed565b5b509050610316919061031a565b5090565b61033c91905b80821115610338576000816000905550600101610320565b5090565b905600a165627a7a7230582002b42864089a104d4d80ba0190924e09e15f3c0d0aa107463f49e2689e159b480029";
var gas = web3.eth.estimateGas({data: bytecode})
var deploy = {from:eth.coinbase, data: bytecode, gas: gas};
var address  = eth.coinbase;

personal.unlockAccount(eth.accounts[0],"chen1980")

var mycontract = web3.eth.contract(abi)

var instance = mycontract.new({from:eth.coinbase, data:bytecode, gas:300000}, function(e, contract){
    if(!e) {

      if(!contract.address) {
        console.log("Contract transaction send: TransactionHash: " + contract.transactionHash + " waiting to be mined...");

      } else {
        console.log("Contract mined! Address: " + contract.address);
        console.log(contract);
      }

    }
}); 

var test = mycontract.at(eth.coinbase)

test.addNum(567);

```

## 12. Ropsten 测试网络

```

$ nohup geth --datadir $DATADIR \
             --unlock 0 \
             --password <(echo -n "SECRETPASSWORD") \
             --testnet \
             --fast \
             2>> $HOME/Desktop/ethereum/testnet/geth.log &		

```

## 13. 静态节点

```

$ vim ~/.ethereum/static-nodes.json		

```

```

[
	//由 EthFans 维护的长期节点，位置：广州
	"enode://6427b7e7446bb05f22fe7ce9ea175ec05858953d75a5a6e4f99a6aec0779a8bd6276f1959a42fe5948acbe14bcd0652082dc546d3b37ae8f2aea41eba4eca43b@121.201.14.181:30303",
	//由秘猿维护的长期节点，位置：杭州
	"enode://91922b12115c067005c574844c6bbdb114eb262f90b6355cec89e13b483c3e4669c6d63ec66b6e3ca7a3a462d28edb3c659e9fa05ed4c7234524e582a8816743@120.27.164.92:13333",
	//由云币网维护的分别位于亚太，广东和北京的长期节点
	"enode://3dde41a994b3b99f938f75ddf6d48318c78ddd869c70b48d00b922190bb434fc5474f6250c143723f4387273d123e02f6a38f07d0311f240d2915f6140e09850@207.226.141.212:30303",
	"enode://7ab8fa90b204f2146c00939b8474549c544caa3598a0894fa639a5cdbd992cbc6135fd776f8bcf97ae95fdaa3afbfa2d107fea71549119afd7ea57356b899be5@121.201.24.236:30303",
	"enode://db81152a8296089b04a21ad9bf347df3ff0450ffc8215d9f50c400ccf8d18963118010cacf03c4b71981cf9cac5394438cab3039e98db4d2aae5859ab7d1793e@139.198.1.244:30303",
  	//由 ethfans 社区成员点典维护的节点，位置：深圳
	"enode://68dd1360f0a4ac362b41124692e31652ffe26f6f06a284ca11f3b514b3968594ac1f4320d1aa1ca343b06327c18a2e40eded74edfb3086e1baaa27ca24226b21@113.106.85.172:30303",
	//由银链科技维护的两个节点，分别位于香港、广州
	"enode://58f6b6908286cefe43c166cfc4fed033c750caa1bc3f6e1e1e1507752c0b91248addb3122f8557c5f8912e702285a160ab3a10203ae1eff3807eda25d6ed6478@45.113.71.186:30303",
	"enode://87190a01c02cafb97e7f49672b4c3be2937cf79c3969e0b8e7b35cac28cebfbda52a13d56fd2113c726a1dd359c9476ccf7e60651439cef56e3a71039f6a4f5e@119.29.207.90:30303",
	//由中钞研究院维护的节点，位于杭州
	"enode://d1fdd05a62fd9544eeb455e4f4d4bd8bb574138d82d8f909f3041d0792e3401f8695133d39ad0a3aa5d217e3c5bed0511b531505a67b03607a909ae9096720d2@120.26.129.121:30303",
	//由 ethfans 社区成员 fsword 维护的节点，位于上海
	"enode://a1e9cf99eca94590ae776c8dd5c6c043a8c1f0375e9e391c9fb55133385bf453ac3d3fb3ead8e63415b2ef99d54a19e2a7bc830cd1fdbbb283818e3bcb0ea31e@182.254.209.254:30303",
	//云象科技维护的节点
	"enode://562796b19d43d79dfb6160abd2d7bb78a2f2efd9501a0a767c00677e0fb3a4407235f813c3003682c2a421a58709c52f595827bc15708cc5f534f55d0f8d03ad@121.40.199.54:30303",
	//币网维护的节点
	"enode://fa2c17dcc83a6e2825668210abf7480452de4b13d8bdea8f301c3b603701918bc4dade9e68d119d7a8214e90e7ea10a2782041c98951385d97bee73358fb08f4@120.26.124.58:30303",
	//朝夕网络维护的节点
	"enode://0b331b27e2976d797aed1d1464ac483a7f262860334cb5737a01a0188da08d79226a6973adc5f2a2c1a20192b399161eee23a0d56ecf472cbe4058d010ecc89f@47.89.49.61:30303",
	"enode://0639f20fdb5af1fecd2f2bc0ddb648885483a5945686530e6b046678635d3435dd7b92fe34209f81ec6f003482aa78e407e5e6eb1b10be4773a2adbcf1fc1ba6@118.192.161.147:30303",
	//布鲁克 Brockex 广东亚太
	"enode://fd2a5d30e4f3917ee640876cc57d72a8bf5ecf049e9106c95e60cf306dd7a5dd68d1a295f3718af44a7083252686926d6e8a402f1abe6f805e10e7281967db28@121.201.29.82:30303",
	"enode://0d1b9eed7afe2d5878d5d8a4c2066b600a3bcac2e5730586421af224e93a58cd03cac75bf0b2a62fd8049cd3692a085758cc1e407c8b2c94bb069814a5e8d0f0@209.9.106.245:30303",
	//成都以太云维护的节点
	"enode://ca087a651571d04953187753af969f7deb1582af2a06a3048b90adb3f87d4c41973aac4b5e80449efc97154dac769a5ea447b123c3aaf7a2c23825a1558804dc@[::]:30303",
	"enode://9b53b9d41d964f71db60d2198cfa9013fc7808d707c5e0a32da1e22d3cacd6adbae46901df6506a752d9d4e3791df29171315fbb86f7b09331a25458158fe65b@[::]:30303"
]

```

## 14. JavaScript Console

### 14.1. personal 管理

#### 14.1.1. 创建账号

```

> personal.newAccount()
Passphrase: 
Repeat passphrase: 
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"				

```

指定密码创建用户

```

personal.newAccount("123")				

```

#### 14.1.2. 列出账号

列出所有账号

```

> personal.listAccounts
["0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "0xe8abf98484325fd6afc59b804ac15804b978e607"]				

```

列出指定账号

```

> personal.listAccounts[1]
"0xe8abf98484325fd6afc59b804ac15804b978e607"

> personal.listAccounts[0]
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"				

```

#### 14.1.3. 解锁账号

```

 > personal.unlockAccount(eth.accounts[0],"password")						

```

指定过期时间，单位是毫秒，下面例子是 20 分钟

```

> personal.unlockAccount(eth.accounts[0],"password", 1000*60*20)				

```

### 14.2. eth 管理

#### 14.2.1. 矿工账号

查看默认旷工账号，系统中的第一个账号。

```

> eth.coinbase
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"				

```

查看账号列表

```

> eth.accounts
["0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "0xe8abf98484325fd6afc59b804ac15804b978e607"]	

> eth.accounts[0]
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"			

```

#### 14.2.2. 余额

```

> eth.getBalance(eth.accounts[0])
70000000000000000000

```

##### 14.2.2.1. 单位转换

eth.getBalance()返回的余额是以太币的最小面额 wei，将 wei 转换为以太币 ether。

```

primary = eth.accounts[0]
balance = web3.fromWei(eth.getBalance(primary), "ether");	

```

演示

```

> primary = eth.accounts[0]
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"
> balance = web3.fromWei(eth.getBalance(primary), "ether");
70			

```

##### 14.2.2.2. 一次检查所有账号余额

定义函数

```

function checkAllBalances() {
  web3.eth.getAccounts(function(err, accounts) {
   accounts.forEach(function(id) {
    web3.eth.getBalance(id, function(err, balance) {
     console.log("" + id + ":\tbalance: " + web3.fromWei(balance, "ether") + " ether");
   });
  });
 });
};					

```

运行函数

```

checkAllBalances()					

```

输出演示

```

> function checkAllBalances() {
...   web3.eth.getAccounts(function(err, accounts) {
.........    accounts.forEach(function(id) {
...............     web3.eth.getBalance(id, function(err, balance) {
.....................      console.log("" + id + ":\tbalance: " + web3.fromWei(balance, "ether") + " ether");
.....................    });
...............   });
.........  });
... };
undefined
> checkAllBalances()
0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6:	balance: 929 ether
0xe8abf98484325fd6afc59b804ac15804b978e607:	balance: 11 ether
undefined					

```

#### 14.2.3. 解锁账号

```

> personal.unlockAccount(eth.accounts[0],"password",50000)
true

```

#### 14.2.4. 转账

```

personal.unlockAccount("0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "", 300)	
eth.sendTransaction({from: '0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6', to: '0xe8abf98484325fd6afc59b804ac15804b978e607', value: web3.toWei(1, "ether")})

```

```

默认矿工账号

> eth.coinbase
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"

查看系统中的账号，如果没有请参考上面章节创建

> eth.accounts
["0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "0xe8abf98484325fd6afc59b804ac15804b978e607"]

转出账号中又 285 个以太币

> web3.fromWei(eth.getBalance(eth.accounts[0]))
285

转入账号目前是 0 

> web3.fromWei(eth.getBalance(eth.accounts[1]))
0

解锁传出账号，否则不能转出。personal.unlockAccount(账号, 密码, 300)

> personal.unlockAccount("0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "", 300)
true

转账操作

> eth.sendTransaction({from: '0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6', to: '0xe8abf98484325fd6afc59b804ac15804b978e607', value: web3.toWei(10, "ether")})
"0xb0674a7fee52555d8712f3a1f0f30fbbbf67ff7b5b4b53ab5d131262613215c6"

如果你现在查看转入账号，你会发现余额仍然是 0 ，交易还未成功写进区块，写进区块的方式是挖矿，所以你必须执行挖矿

> miner.start(1)
null

稍后几分钟，再次查看转入账号，将会看到有 10 个以太币入账。传出账号会减少 10 个以太币，同时仍然继续挖矿中。

> web3.fromWei(eth.getBalance(eth.accounts[1]))
10

```

从账号 0 想账号 1 转账

```

> personal.unlockAccount(eth.accounts[0],"password",50000)
true
> eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(1, "ether")})				

```

#### 14.2.5. 查看挂起的交易

```

> eth.pendingTransactions
[{
    blockHash: null,
    blockNumber: null,
    from: "0x5fba50fce50baf0b8a7314200ba46336958ac97e",
    gas: 90000,
    gasPrice: 20000000000,
    hash: "0x51a75422f79fa96e70a0c1481851bc9f827868c44203b68d74f9815ffb367d5f",
    input: "0x",
    nonce: 0,
    r: "0x5632a8ade4a767dbd949ba1042cb33f98dd0722ab999ba18e1454d19d8bd1f6d",
    s: "0x515dcfa3de297f0c956ad9a061a5561f47cc9ccbb0a547cda59193c77fcbe3f7",
    to: "0x0a8c35653d8b229c16f0c9ce6f63cffb877cfdcf",
    transactionIndex: 0,
    v: "0x42",
    value: 1000000000000000000
}]				

```

如果返回空值，表示交易全部完成。

```

> eth.pendingTransactions
[]				

```

#### 14.2.6. 查看当前区块总数

```

> eth.blockNumber 
719			

```

#### 14.2.7. 查看当前 Gas 价格

```

> web3.eth.gasPrice
5000000000

> web3.fromWei(web3.eth.gasPrice.toString())
"0.000000018"

```

#### 14.2.8. 评估执行花费的 GAS

```

> eth.estimateGas({from:eth.accounts[1], to: eth.accounts[2], value:12340000000000000000})
21000

```

#### 14.2.9. 查看区块信息

```

> eth.getBlock(1) 
{
  difficulty: 131072,
  extraData: "0xd783010702846765746885676f312e398777696e646f7773",
  gasLimit: 4995119,
  gasUsed: 0,
  hash: "0x62bc2fc0fd647b43013ba75e65a3f16520cebb60cadc0995965c891d4266a88c",
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  miner: "0xba1821227ebad7e88a51078f6219b392fd601822",
  mixHash: "0x80ad2e29d057e0f6bb9d03f12a252fdc65cb520248fa0023ae6624c997b5d5f2",
  nonce: "0x3d743ef28ba8c8c8",
  number: 1,
  parentHash: "0x611596e7979cd4e7ca1531260fa706093a5492ecbdf58f20a39545397e424d04",
  receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
  size: 535,
  stateRoot: "0x418d9f66e33cbd41fd524b87c10c5fc75f8a6360896967d827a2d56a0c8aadda",
  timestamp: 1510715249,
  totalDifficulty: 262144,
  transactions: [],
  transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  uncles: []
}
> eth.getBlock(2)
{
  difficulty: 131072,
  extraData: "0xd783010702846765746885676f312e398777696e646f7773",
  gasLimit: 4990242,
  gasUsed: 0,
  hash: "0x3323c566fd3501c29e8b026c4a9d2e83a8dd62d153a32b5f879120e999013d07",
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  miner: "0xba1821227ebad7e88a51078f6219b392fd601822",
  mixHash: "0xc415fc64f1bc13842455f8289d33842260c1578a32b5befded5b4293e7a92276",
  nonce: "0x4f4a0e65412663db",
  number: 2,
  parentHash: "0x62bc2fc0fd647b43013ba75e65a3f16520cebb60cadc0995965c891d4266a88c",
  receiptsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
  size: 535,
  stateRoot: "0x39ccb22ff5ca19a2340e137fa64acedb704d42827a753780b53a0aff8922e403",
  timestamp: 1510715341,
  totalDifficulty: 393216,
  transactions: [],
  transactionsRoot: "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
  uncles: []
}

```

#### 14.2.10. 返回交易信息

```

> web3.eth.getTransaction("0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d")
{
  blockHash: "0x59a9905831e7ae3cb9e7c6f125cf48e2688ef4b39317838f6f6b6c8837d01404",
  blockNumber: 4367,
  from: "0x8efb99ec55bcfbe2cfe47918f2d9e55fa732111f",
  gas: 21000,
  gasPrice: 18000000000,
  hash: "0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d",
  input: "0x",
  nonce: 15,
  r: "0xa297401df3a1fb0298cbc1dd609deebe9ded319fadc55934ecef4d525198215",
  s: "0x780d8c46bc8d1bb89ae9d78055307d9d68a4f89ba699ef86d3f8ba88383139a6",
  to: "0xf0688330101d53bd0c6ede2ef04d33c2010e9a5d",
  transactionIndex: 0,
  v: "0x42",
  value: 999622000000000000
}

```

#### 14.2.11. 返回交易收据

```

> web3.eth.getTransactionReceipt("0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d")
{
  blockHash: "0x59a9905831e7ae3cb9e7c6f125cf48e2688ef4b39317838f6f6b6c8837d01404",
  blockNumber: 4367,
  contractAddress: null,
  cumulativeGasUsed: 21000,
  from: "0x8efb99ec55bcfbe2cfe47918f2d9e55fa732111f",
  gasUsed: 21000,
  logs: [],
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  root: "0x69d278e7594e8a5affbebc84380516437f3e4b241b272e6eaebf752af9c76047",
  to: "0xf0688330101d53bd0c6ede2ef04d33c2010e9a5d",
  transactionHash: "0x4e27a477e128b200239bc2ecd899077c6ae064da963a919fef41bcc7462aec8d",
  transactionIndex: 0
}

```

返回值：

Object - 交易的收据对象，如果找不到返回 null 
blockHash: String - 32 字节，这个交易所在区块的哈希。
blockNumber: Number - 交易所在区块的块号。
transactionHash: String - 32 字节，交易的哈希值。
transactionIndex: Number - 交易在区块里面的序号，整数。
from: String - 20 字节，交易发送者的地址。
to: String - 20 字节，交易接收者的地址。如果是一个合约创建的交易，返回 null。
cumulativeGasUsed: Number - 当前交易执行后累计花费的 gas 总值 10。
gasUsed: Number - 执行当前这个交易单独花费的 gas。
contractAddress: String - 20 字节，创建的合约地址。如果是一个合约创建交易，返回合约地址，其它情况返回 null。
logs: Array - 这个交易产生的日志对象数组。

#### 14.2.12. eth.syncing 同步状态

```

> eth.syncing
{
  currentBlock: 645835,
  highestBlock: 5439559,
  knownStates: 1090968,
  pulledStates: 1080746,
  startingBlock: 0
}			

```

显示百分比

```

console.log(parseInt(eth.syncing.currentBlock/eth.syncing.highestBlock*100,10)+'%')		

```

剩余块数

```

eth.syncing.highestBlock - eth.syncing.currentBlock

setInterval(function(){
	console.log(eth.syncing.highestBlock - eth.syncing.currentBlock)
},5000);

```

进度监控

```

var lastPercentage = 0;var lastBlocksToGo = 0;var timeInterval = 10000;
setInterval(function(){
    var percentage = eth.syncing.currentBlock/eth.syncing.highestBlock*100;
    var percentagePerTime = percentage - lastPercentage;
    var blocksToGo = eth.syncing.highestBlock - eth.syncing.currentBlock;
    var bps = (lastBlocksToGo - blocksToGo) / (timeInterval / 1000)
    var etas = 100 / percentagePerTime * (timeInterval / 1000)

    var etaM = parseInt(etas/60,10);
    console.log(parseInt(percentage,10)+'% ETA: '+etaM+' minutes @ '+bps+'bps');

    lastPercentage = percentage;lastBlocksToGo = blocksToGo;
},timeInterval);

```

#### 14.2.13. 查看智能合约编译器

```

> eth.compile
{
  lll: function(),
  serpent: function(),
  solidity: function()
}				

```

### 14.3. web3

#### 14.3.1. Ether 币的基本单位

Ether 币最小的单位是 Wei，也是命令行默认的单位, 然后每 1000 个进一个单位，依次是

kwei (1000 Wei)
mwei (1000 KWei)
gwei (1000 mwei)
szabo (1000 gwei)
finney (1000 szabo)
ether (1000 finney)

如何进行 ether 和 Wei 之间的转换，简单地说就是就是 1 以太币 = 1000000000000000000 Wei （这就是上一站章中为何我们转移 0.01 个以太币，结果却显示很长的原因）

单位转换

```

> web3.fromWei(10000000000000000,"ether")
"0.01"				

```

#### 14.3.2. web3.toWei

```

Ether–> Wei

> web3.toWei(1)
"1000000000000000000"
> web3.toWei(1.3423423)
"1342342300000000000"
> web3.toWei(0.00034)
"340000000000000"						

```

#### 14.3.3. web3.fromWei

```

Wei –> Ether

> web3.fromWei(10000000000000000)
"0.01"
> web3.fromWei(1000000000000000000)
"1"
>

```

### 14.4. admin 管理

```

> admin
{
  datadir: "/home/ethereum/.ethereum",
  nodeInfo: {
    enode: "enode://89a7bfd4472dff266ccdccc76bc75586a9005144df54d4575a9e07d9b2aee8aae6c8004cc98c6212d5f0f4d5e3a524617abd7e7d6f39d5df053f94b7250e5610@[::]:30303?discport=0",
    id: "89a7bfd4472dff266ccdccc76bc75586a9005144df54d4575a9e07d9b2aee8aae6c8004cc98c6212d5f0f4d5e3a524617abd7e7d6f39d5df053f94b7250e5610",
    ip: "::",
    listenAddr: "[::]:30303",
    name: "Geth/v1.8.2-stable/linux-amd64/go1.8.3",
    ports: {
      discovery: 0,
      listener: 30303
    },
    protocols: {
      les: {
        config: {...},
        difficulty: 17179869184,
        genesis: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        head: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        network: 1
      }
    }
  },
  peers: [],
  addPeer: function(),
  clearHistory: function(),
  exportChain: function(),
  getDatadir: function(callback),
  getNodeInfo: function(callback),
  getPeers: function(callback),
  importChain: function(),
  removePeer: function(),
  sleep: function github.com/ethereum/go-ethereum/console.(*bridge).Sleep-fm(),
  sleepBlocks: function github.com/ethereum/go-ethereum/console.(*bridge).SleepBlocks-fm(),
  startRPC: function(),
  startWS: function(),
  stopRPC: function(),
  stopWS: function()
}		

```

#### 14.4.1. 看看 networkid

```

> admin.nodeInfo.protocols.eth.network
123456				

```

#### 14.4.2. 节点管理

可以通过 admin.addPeer()方法连接到其他节点，两个节点要想联通，必须保证网络是相通的，并且要指定相同的 networkid

### 提示

注意去掉 --nodiscover 参数

确保网络可用

```

> net.listening
true

```

##### 14.4.2.1. 显示节点

显示当前节点信息

```

> admin.nodeInfo
{
  enode: "enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@14.103.209.119:30303",
  id: "9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527",
  ip: "14.103.209.119",
  listenAddr: "[::]:30303",
  name: "Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1",
  ports: {
    discovery: 30303,
    listener: 30303
  },
  protocols: {
    eth: {
      difficulty: 108754979,
      genesis: "0x611596e7979cd4e7ca1531260fa706093a5492ecbdf58f20a39545397e424d04",
      head: "0x61330b27cfbfaecbb36bb8666cbe0564c1e0bdecfdcd153622d8c2ca2b82786e",
      network: 123456
    }
  }
}					

```

节点地址

```

> admin.nodeInfo.enode 
"enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@[::]:30303?discport=0"

```

[::] 是 ipv6 地址，可以改为 ipv4 地址。

##### 14.4.2.2. 添加节点

```

> admin.addPeer('enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@172.16.0.1:30303')				

```

```

admin.addPeer('enode://6427b7e7446bb05f22fe7ce9ea175ec05858953d75a5a6e4f99a6aec0779a8bd6276f1959a42fe5948acbe14bcd0652082dc546d3b37ae8f2aea41eba4eca43b@121.201.14.181:30303');
admin.addPeer('enode://91922b12115c067005c574844c6bbdb114eb262f90b6355cec89e13b483c3e4669c6d63ec66b6e3ca7a3a462d28edb3c659e9fa05ed4c7234524e582a8816743@120.27.164.92:13333');
admin.addPeer('enode://3dde41a994b3b99f938f75ddf6d48318c78ddd869c70b48d00b922190bb434fc5474f6250c143723f4387273d123e02f6a38f07d0311f240d2915f6140e09850@207.226.141.212:30303');
admin.addPeer('enode://7ab8fa90b204f2146c00939b8474549c544caa3598a0894fa639a5cdbd992cbc6135fd776f8bcf97ae95fdaa3afbfa2d107fea71549119afd7ea57356b899be5@121.201.24.236:30303');
admin.addPeer('enode://db81152a8296089b04a21ad9bf347df3ff0450ffc8215d9f50c400ccf8d18963118010cacf03c4b71981cf9cac5394438cab3039e98db4d2aae5859ab7d1793e@139.198.1.244:30303');
admin.addPeer('enode://68dd1360f0a4ac362b41124692e31652ffe26f6f06a284ca11f3b514b3968594ac1f4320d1aa1ca343b06327c18a2e40eded74edfb3086e1baaa27ca24226b21@113.106.85.172:30303');
admin.addPeer('enode://58f6b6908286cefe43c166cfc4fed033c750caa1bc3f6e1e1e1507752c0b91248addb3122f8557c5f8912e702285a160ab3a10203ae1eff3807eda25d6ed6478@45.113.71.186:30303');
admin.addPeer('enode://87190a01c02cafb97e7f49672b4c3be2937cf79c3969e0b8e7b35cac28cebfbda52a13d56fd2113c726a1dd359c9476ccf7e60651439cef56e3a71039f6a4f5e@119.29.207.90:30303');
admin.addPeer('enode://d1fdd05a62fd9544eeb455e4f4d4bd8bb574138d82d8f909f3041d0792e3401f8695133d39ad0a3aa5d217e3c5bed0511b531505a67b03607a909ae9096720d2@120.26.129.121:30303');
admin.addPeer('enode://a1e9cf99eca94590ae776c8dd5c6c043a8c1f0375e9e391c9fb55133385bf453ac3d3fb3ead8e63415b2ef99d54a19e2a7bc830cd1fdbbb283818e3bcb0ea31e@182.254.209.254:30303');
admin.addPeer('enode://562796b19d43d79dfb6160abd2d7bb78a2f2efd9501a0a767c00677e0fb3a4407235f813c3003682c2a421a58709c52f595827bc15708cc5f534f55d0f8d03ad@121.40.199.54:30303');
admin.addPeer('enode://fa2c17dcc83a6e2825668210abf7480452de4b13d8bdea8f301c3b603701918bc4dade9e68d119d7a8214e90e7ea10a2782041c98951385d97bee73358fb08f4@120.26.124.58:30303');
admin.addPeer('enode://0b331b27e2976d797aed1d1464ac483a7f262860334cb5737a01a0188da08d79226a6973adc5f2a2c1a20192b399161eee23a0d56ecf472cbe4058d010ecc89f@47.89.49.61:30303');
admin.addPeer('enode://0639f20fdb5af1fecd2f2bc0ddb648885483a5945686530e6b046678635d3435dd7b92fe34209f81ec6f003482aa78e407e5e6eb1b10be4773a2adbcf1fc1ba6@118.192.161.147:30303');
admin.addPeer('enode://fd2a5d30e4f3917ee640876cc57d72a8bf5ecf049e9106c95e60cf306dd7a5dd68d1a295f3718af44a7083252686926d6e8a402f1abe6f805e10e7281967db28@121.201.29.82:30303');
admin.addPeer('enode://0d1b9eed7afe2d5878d5d8a4c2066b600a3bcac2e5730586421af224e93a58cd03cac75bf0b2a62fd8049cd3692a085758cc1e407c8b2c94bb069814a5e8d0f0@209.9.106.245:30303');
admin.addPeer('enode://ca087a651571d04953187753af969f7deb1582af2a06a3048b90adb3f87d4c41973aac4b5e80449efc97154dac769a5ea447b123c3aaf7a2c23825a1558804dc@182.150.37.23:30303');
admin.addPeer('enode://9b53b9d41d964f71db60d2198cfa9013fc7808d707c5e0a32da1e22d3cacd6adbae46901df6506a752d9d4e3791df29171315fbb86f7b09331a25458158fe65b@182.150.37.24:30303');			

```

##### 14.4.2.3. 查看节点

查看节点数量

```

> net.peerCount
1					

```

查看节点地址

```

> admin.peers
[{
    caps: ["eth/62", "eth/63", "par/1", "par/2", "pip/1"],
    id: "a7bbd8fb72e02681b027908f14fd2dbd80e35a1477d7d9d4dc19ed34420be26fe9f991c83a83e4ab8aa371ffbb149494471f30216bc2f662d1ebc6d01811c7a2",
    name: "Parity/v1.7.12-stable-9b796e8-20180121/x86_64-linux-gnu/rustc1.21.0",
    network: {
      localAddress: "172.16.0.1:34092",
      remoteAddress: "52.67.171.152:30388"
    },
    protocols: {
      eth: "handshake"
    }
}]				

```

列出节点 IP 地址

```

admin.peers.forEach(function(p) {console.log(p.network.remoteAddress);})	

```

```

> admin.peers.forEach(function(p) {console.log(p.network.remoteAddress);})
52.90.40.206:30303
120.79.161.22:30303
13.229.198.234:30303
169.0.182.34:30303
23.111.151.158:30304
120.27.196.141:30303
118.193.93.174:30303
35.229.242.1:30303
159.203.32.64:30303
undefined
>				

```

##### 14.4.2.4. networkid

```

> admin.nodeInfo.protocols.les.network
1			

```

### 14.5. miner 挖矿管理

#### 14.5.1. 开始挖矿

```

> miner.start(2)
null			

```

过几分钟后运行

```

> web3.fromWei(eth.getBalance(eth.coinbase), "ether")
30					

```

这时我们已经看到已经产生了 30 个以太币。

#### 14.5.2. 停止挖矿

```

> miner.stop()
true
>

```

#### 14.5.3. 设置默认矿工账号

默认挖矿使用系统中的第一个账号，你可以使用 miner.setEtherbase() 指定账号。

```

> miner.setEtherbase("0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6")
true	

```

```

> eth.accounts
["0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "0xe8abf98484325fd6afc59b804ac15804b978e607", "0x013b5e735e1b48421dd3de3b931d6f03e769e22b"]

> eth.coinbase
"0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6"

> miner.setEtherbase("0xe8abf98484325fd6afc59b804ac15804b978e607")
true

> eth.coinbase
"0xe8abf98484325fd6afc59b804ac15804b978e607"	

```

### 14.6. txpool 管理

#### 14.6.1. txpool.status

查看状态

```

> txpool.status 
{
  pending: 0,
  queued: 0
}

```

例如做一笔转账

```

> amount = web3.toWei(5,'ether')  
"5000000000000000000"  
> eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})	

> txpool.status 
{
  pending: 1,
  queued: 0
}

> miner.start(1);admin.sleepBlocks(1);miner.stop(); 

> txpool.status 
{
  pending: 0,
  queued: 0
}

> web3.fromWei(eth.getBalance(eth.accounts[1]),'ether')  
5  

```

### 14.7. net

#### 14.7.1. 监听状态

```

> net.listening
true

```

## 第 12 章 Wallet

## 1. Ethereum Wallet(Mist)

开始学习以太坊时阅读大量文章常常会提到 Mist 一头雾水，后来才知道 Mist 就是 Ethereum Wallet。 Ethereum Wallet 是软件名字， Mist 是项目名字。

Ethereum Wallet 可以在以太坊首页下载，如果你需要安装历史版本可以访问 [`github.com/ethereum/mist/releases`](https://github.com/ethereum/mist/releases)

参数：

```

neo@MacBook-Pro ~ %  "/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet" --help
Usage: /Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet --help
[Mist options] [Node options]

Mist options:
  --mode, -m              App UI mode: wallet, mist.[string] [default: "wallet"]
  --node                  Node to use: geth, eth        [string] [default: null]
  --network               Network to connect to: main, test
                                                        [string] [default: null]
  --rpc                   Path to node IPC socket file OR HTTP RPC hostport (if
                          IPC socket file then --node-ipcpath will be set with
                          this value).                                  [string]
  --swarmurl              URL serving the Swarm HTTP API. If null, Mist will
                          open a local node.
                                     [string] [default: "http://localhost:8500"]
  --gethpath              Path to Geth executable to use instead of default.
                                                                        [string]
  --ethpath               Path to Eth executable to use instead of default.
                                                                        [string]
  --ignore-gpu-blacklist  Ignores GPU blacklist (needed for some Linux
                          installations).                              [boolean]
  --reset-tabs            Reset Mist tabs to their default settings.   [boolean]
  --logfile               Logs will be written to this file in addition to the
                          console.                                      [string]
  --loglevel              Minimum logging threshold: info, debug, error, trace
                          (shows all logs, including possible passwords over
                          IPC!).                      [string] [default: "info"]
  --syncmode              Geth synchronization mode: [fast|light|full]  [string]
  --version, -v           Display Mist version.                        [boolean]
  --skiptimesynccheck     Disable checks for the presence of automatic time sync
                          on your OS.                                  [boolean]

Node options:
  -  To pass options to the underlying node (e.g. Geth) use the --node- prefix,
     e.g. --node-datadir

Options:
  -h, --help  Show help                                                [boolean]				

```

| ![](img/EthereumWallet.png) |

### 1.1. Ethereum Wallet 工作原理

Ethereum Wallet 工作原理非常简单，启动 Ethereum Wallet 是，Ethereum Wallet 会首先启动 geth，然后在启动 Ethereum Wallet 应用程序。

geth 负责与以太坊网络连接，包括主网，Ropsten 和 Rinkeby 两个测试网，Solo 本地开发模式。geth

例如主网的启动目录是 /Users/neo/Library/Ethereum/geth.ipc 参数是：

```

/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth --syncmode light --cache 1024

```

#### 1.1.1. geth 启动 ropsten 测试网

```

/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth --testnet --syncmode light --cache 1024 --ipcpath /Users/neo/Library/Ethereum/geth.ipc

```

#### 1.1.2. 连接到本地测试网络

首先启动 geth

##### 1.1.2.1. IPC

钱包默认是连接到下面地址。

```

IPC endpoint opened: /Users/neo/Library/Ethereum/geth.ipc

```

连接到其他 ipc 地址

```

"/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet" --rpc /Users/other/Library/Ethereum/geth.ipc

```

##### 1.1.2.2. TCP

如果需要连接到远程节点上，需要使用命令行，方法如下。启动钱包并连接到远程开发环境，localhost 改为你的 IP 地址即可。

```

"/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet" --rpc http://localhost:8545				

```

| ![](img/EthereumWalletTcp.png) |

#### 1.1.3. 控制台

在 Ethereum Wallet 启动期间，随时可以进入 Javascript 控制台。

```

neo@MacBook-Pro ~/Library/Ethereum/geth % geth attach      
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.1-stable-1e67410e/darwin-amd64/go1.9.4
 modules: admin:1.0 debug:1.0 eth:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> eth.accounts
["0xb94054c174995ae2a9e7fcf6c7924635fba8ecf7", "0xf56b81a2bcb964d2806071e9be4289a5559bb0fa", "0x997e5ca600e19447d0b82afbf9c7f00de2b39b16"]
> 				

```

### 1.2. 主网络

#### 1.2.1. 主网启动参数

```

/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth --syncmode light --cache 1024				

```

#### 1.2.2. 进入主网

点击按钮 "USE THE MAIN NETWORK" 进入以太坊主网。

| ![](img/EthereumWalletNetwork.png) |

#### 1.2.3. 以太坊区块浏览器

[`etherscan.io`](https://etherscan.io)

### 1.3. Ropsten 测试网络

#### 1.3.1. 启动参数

```

/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth --testnet --syncmode light --cache 1024 --ipcpath /Users/neo/Library/Ethereum/geth.ipc				

```

#### 1.3.2. 获得测试币

[`faucet.ropsten.be:3001`](http://faucet.ropsten.be:3001)

| ![](img/faucet.png) |

输入账号然后点击 “Send me 1 test ether” 按钮

| ![](img/send.png) |

当现实 “Your request was accepted” 时，表示你的请求已经接受，接下来耐心等待。

#### 1.3.3. Etherscan

[`ropsten.etherscan.io`](https://ropsten.etherscan.io)

### 1.4. Rinkeby 测试网络

[`www.rinkeby.io/`](https://www.rinkeby.io/)

#### 1.4.1. 测试网络

连接测试网络，启动 "Ethereum Wallet"，主菜单-Develop-Network，选择 "Rinkeby - Test network"。

如果这个菜单是灰色的，可以你在本地运行过 geth，解决方法如下：

```

mkdir ~/ethereum/rinkeby			
geth --datadir ~/ethereum/rinkeby --rinkeby --rpc console

```

在另一个终端窗口执行

```

neo@MacBook-Pro ~/ethereum/rinkeby % "/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet" ~/ethereum/rinkeby/geth.ipc	

```

或者使用 TCP 方式连接

```

"/Applications/Ethereum Wallet.app/Contents/MacOS/Ethereum Wallet" --rpc http://localhost:8545				

```

如果你没有安装 geth，可以使用下面的方法

```

neo@MacBook-Pro ~/ethereum/truffle % "/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth" --rinkeby --syncmode light --cache 1024 --ipcpath /Users/neo/Library/Ethereum/geth.ipc
INFO [02-22|11:43:23] Maximum peer count                       ETH=0 LES=100 total=25
INFO [02-22|11:43:23] Starting peer-to-peer node               instance=Geth/v1.8.1-stable-1e67410e/darwin-amd64/go1.9.4
INFO [02-22|11:43:23] Allocated cache and file handles         database=/Users/neo/Library/Ethereum/rinkeby/geth/lightchaindata cache=768 handles=128
INFO [02-22|11:43:27] Persisted trie from memory database      nodes=355 size=65.27kB time=399.41µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B
INFO [02-22|11:43:27] Initialised chain configuration          config="{ChainID: 4 Homestead: 1 DAO: <nil> DAOSupport: true EIP150: 2 EIP155: 3 EIP158: 3 Byzantium: 1035301 Engine: clique}"
INFO [02-22|11:43:27] Loaded most recent local header          number=1813389 hash=d58d6b…a489d9 td=3366103
INFO [02-22|11:43:27] Starting P2P networking 
INFO [02-22|11:43:29] UDP listener up                          net=enode://e84fbdb5d1b75d18fe45fdd13fdad9d5a8ff6d54b82cc8383525870054b91108010ccf8776ac8a50146c9abf9d43c0117af2bbe0cc2668874d269c3817dec47e@[::]:30303
WARN [02-22|11:43:29] Light client mode is an experimental feature 
INFO [02-22|11:43:29] RLPx listener up                         self="enode://e84fbdb5d1b75d18fe45fdd13fdad9d5a8ff6d54b82cc8383525870054b91108010ccf8776ac8a50146c9abf9d43c0117af2bbe0cc2668874d269c3817dec47e@[::]:30303?discport=0"
INFO [02-22|11:43:29] IPC endpoint opened                      url=/Users/neo/Library/Ethereum/geth.ipc
INFO [02-22|11:43:30] Mapped network port                      proto=udp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"
INFO [02-22|11:43:31] Mapped network port                      proto=tcp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"
INFO [02-22|11:43:32] Block synchronisation started 
INFO [02-22|11:43:33] Imported new block headers               count=13 elapsed=245.507ms number=1813402 hash=08317c…fd1806 ignored=0
INFO [02-22|11:43:48] Imported new block headers               count=1  elapsed=898.705µs number=1813403 hash=8a7c1b…5e1652 ignored=0
INFO [02-22|11:44:03] Imported new block headers               count=1  elapsed=892.924µs number=1813404 hash=511a30…561d32 ignored=0			

```

然后正常启动钱包程序 Launchpad - Ethereum Wallet

启动过程比较缓慢，启动后会同步区块信息

弹出第一个界面，让你选择网络，这里选择 Rinkeby 测试网络

| ![](img/EthereumWalletNetwork.png) |

输入密码，要求八位字母和数字组合

| ![](img/EthereumWalletPassword.png) |

提示你备份钱包

| ![](img/EthereumWalletBackup.png) |

生成账号 0x36ccB50B007D3D409E69841905DEf1D77D114Ddc

| ![](img/EthereumWalletAccount.png) |

这时你会看到右下角的数字不断地变化，表示正在同步区块信息。同步过程比较漫长，请耐心等待。

| ![](img/EthereumWallet.png) |

#### 1.4.2. 获取测试网络上的以太币

想获取 Rinkeby 测试网络中的以太币，需要去申请，地址：

[`faucet.rinkeby.io`](https://faucet.rinkeby.io)

| ![](img/home.png) |

输入你的钱包地址，并点击“Give me Ether”，有三种选项，前面是获得的以太币数量，后面是冷却时间，在冷却时间过后才能进行下一次以太币申请。例如第一项是生成 3 个以太币，8 小时后才能再次申请。

如果一切顺利，你会看到你的钱包地址已经多出了申请数量的以太币。

注意：如果申请的人数很多，需要排队等待

#### 1.4.3. 连接节点（Light node）

下载创世区块

```

mkdir ~/.rinkeby
cd ~/.rinkeby
wget https://www.rinkeby.io/rinkeby.json		

```

初始化区块

```

geth --datadir=$HOME/.rinkeby init rinkeby.json			

```

启动以太坊，这里采用 Light node 模式，仅仅下载区块信息，不会运行交易，速度比较快。

```

geth --networkid=4 --datadir=$HOME/.rinkeby --syncmode=light --ethstats='yournode:Respect my authoritah!@stats.rinkeby.io' --bootnodes=enode://a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf@52.169.42.101:30303			

```

#### 1.4.4. 区块链浏览器

[`rinkeby.etherscan.io`](https://rinkeby.etherscan.io)

### 1.5. Solo Network

solo 实际上就是 geth 的 --dev 参数

开发模式会创建一个账号，同时启动挖矿，ETH 多的你用不完。

```

/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth --dev --minerthreads 1 --ipcpath /Users/neo/Library/Ethereum/geth.ipc			

```

### 1.6. 私网

```

"/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth" --datadir=$HOME/ethereum/private init $HOME/ethereum/genesis.json			
"/Users/neo/Library/Application Support/Ethereum Wallet/binaries/Geth/unpacked/geth" --networkid=4444 --datadir=$HOME/ethereum/private --ipcpath /Users/neo/Library/Ethereum/geth.ipc

```

### 1.7. 删除废弃的合约

在 Ethereum Wallet 钱包上会显示所有自己创建或者 Watch 的合约，有些合约仅仅是测试用的，用过即废弃，合约列表依然会显示在那里，只是变成灰色并且无法选择

怎样把无用的合约从列表删除呢？

```

1\. Ethereum Wallet 上打开开发者工具（从窗口选择开发->切换开发工具->钱包界面，或者输入快捷键 Alt+Ctrl+I），显示出控制台界面
2\. 查询 Watch Contract 列表 - 在控制台输入命令: CustomContracts.find().fetch();
3\. 在合约列表中找到需要删除的合约，并且复制 ContractID
4\. 删除合约，在控制台输入命令：CustomContracts.remove('<ContractID>')

```

### 1.8. 免安装，在线使用

[`wallet.ethereum.org`](https://wallet.ethereum.org)

### 1.9. 获得空投币

## 2. MetaMask

MetaMask 是 Chrome 浏览器插件 [`metamask.io`](https://metamask.io)

| ![](img/metamask.png) |

### 2.1. 测试网络

| ![](img/network.png) |

#### 2.1.1. 获取测试网络上的以太币

点击 Buy 按钮，然后再点击 ROPSTEN TEST FAUCET 按钮。

| ![](img/ropsten-test-faucet.png) |

点击 request 1 ether from faucet

| ![](img/faucet.png) |

### 2.2. mnemonic - Reveal seed words

点击头像进入 Settings 菜单

| ![](img/settings.png) |

单机 Reveal seed words 按钮

| ![](img/reveal-seed-words.png) |

输入账号密码解锁

| ![](img/seed-words-password.png) |

查看 mnemonic 字符串

| ![](img/save-seed-words.png) |

### 2.3. 添加 Token 币种

有时我们需要添加新币种，还有一个目的是为了接收空投币。

只需输入合约地址即可，其他选项会自动填充。

| ![](img/add-token.png) |

显示代币数量

| ![](img/add-token-balance.png) |

完成代币添加

| ![](img/add-token-done.png) |

### 2.4. MetaMask Vault Decryptor

MetaMask 将钱包数据存储在浏览中 Local Storage 中，这是 Chrome 谷歌浏览器特有的 Key,Value 数据库。

Key 的名字是 metamask-config 将它复制到 [`metamask.github.io/vault-decryptor/`](https://metamask.github.io/vault-decryptor/) 中可以解密。

解密程序的 Github 地址 https://github.com/MetaMask/vault-decryptor

### 2.5. 部署合约

这里假设你已经安装 MetaMask 钱包，并且创建了账号，账号有足够的 ETH 用来创建合约。

我们准备一个合约

```

pragma solidity ⁰.4.24;

/******************************************/
/*       Netkiller ADVANCED TOKEN         */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-05-23                     */
/******************************************/

contract NetkillerMiniToken {
    address public owner;
    // Public variables of the token
    string public name;
    string public symbol;
    uint public decimals;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint decimalUnits
    ) public {
        owner = msg.sender;
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol; 
        decimals = decimalUnits;
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial token
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        emit Transfer(_from, _to, _value);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
}

```

现在打开 https://remix.ethereum.org/

| ![](img/remix.png) |

点击“+”加号创建合约，合约名称 NetkillerToken, 编译合约。进入 “Run” 选项卡运行合约

| ![](img/remix-transact.png) |

Environment 设置为 Injected Web3 这时可以看到 MetaMask 中的账号以及余额, 然后设置构造方法，最后点击“transact”按钮开始部署合约。

| ![](img/remix-metamask.png) |

确认手续费

| ![](img/remix-console.png) |

remix 显示出 TX Hash 表示完成。

## 3. MyEtherWallet

[`www.myetherwallet.com/`](https://www.myetherwallet.com/)

### 3.1. 执行 ERC20 智能合约函数

首先选择网络，例如主网，测试网，然后填写合约地址，粘贴 ABI，点击 ACCESS 按钮

| ![](img/contact.png) |

#### 3.1.1. 查询余额

选择合约方法，输入参数，执行后可以看到结果，这里仅仅演示查询余额的方法。

| ![](img/balanceOf.png) |

#### 3.1.2. 销毁代币

从合约的 Owner 账号中销毁一定数额的代币

| ![](img/burn.png) |

从指定账号中销毁一定数额的代币

| ![](img/burnFrom.png) |

#### 3.1.3. 冻结账号

冻结账号,输入地址，然后选择 True 最后点击按钮 Write

| ![](img/freezeAccount.png) |

解冻账号，重复上述步骤，选择 False 然后点击 Write 按钮。

查询账号状态，输入地址，点击 Write 按钮，返回 True 表示账号被冻结，返回 False 或 空值，表示没有冻结。

| ![](img/frozenAccount.png) |

#### 3.1.4. 增发代币

输入需要增发到那个地址，然后输入增发数量

| ![](img/mintToken.png) |

#### 3.1.5. 锁仓

冻结是针对单个用户的，如果你需要停止一切交易（任何账号都不能转入，转出），那么可以采用锁仓方案。

| ![](img/setLock.png) |

True 表示开启锁仓， False 表示关闭锁仓。

#### 3.1.6. 批量打币

一次性对多个账号打币，输入账号使用逗号分隔（半角），然后输入数量。

| ![](img/transferBatch.png) |

#### 3.1.7. 修改合约管理者

合约的管理者拥有上面所有权限，如果你想转移给其他账号，使用下面方法操作即可。

| ![](img/transferOwnership.png) |

#### 3.1.8. 设置兑换比例

将 ETH 发送到合约知道，返回 ETH * buyPrice 数量的 Token

| ![](img/setPrices.png) |

#### 3.1.9. 空投设置

设置空投总量

| ![](img/setAirdropTotalSupply.png) |

换算 ETH 到 WEI [`etherconverter.online/`](https://etherconverter.online/) 例如你需要空投 1.5 个 Token，请在下面填写 1500000000000000000

| ![](img/eth2wei.png) |

设置空投数量

| ![](img/setAirdropAmount.png) |

## 4. MyCrypto

[`www.mycrypto.com/`](https://www.mycrypto.com/)

## 5. imToken

[`token.im`](https://token.im)

### 5.1. 添加 Token

具体教程请参考: [`github.com/consenlabs/token-profile/blob/master/README.md`](https://github.com/consenlabs/token-profile/blob/master/README.md)

创建文件 token-profile/erc20/0x4488ed050cd13ccfe0b0fcf3d168216830142775.json

```

{
  "symbol": "NBRC",
  "address": "0x4488ed050cd13ccfe0b0fcf3d168216830142775",
  "overview":{
        "en":"Netkiller eBook Reader Coin."
  },
  "email": "netkiller@msn.com",
  "website": "https://www.netkiller.cn/",
  "whitepaper": "https://www.netkiller.cn/file.pdf",
  "state": "LOCKED",
  "published_on": "2018-06-01",
  "initial_price":{
        "ETH":"0.00166666 ETH",
        "USD":"0.7 USD",
        "BTC":"0.00004137 BTC"
  },
  "links": {
    "blog": "https://my.oschina.net/neochen/blog",
    "telegram": "https://t.me/joinchat/netkiller",
    "github": "https://github.com/netkiller/netkiller.github.io",
    "facebook": "https://www.facebook.com/bg7nyt",
  }
}

```

## 第 13 章 Token

### *ERC 代币标准*

## 1. Ethereum Wallet 创建 ERC20 代币合约

[`ethereum.org/token`](https://ethereum.org/token)

### 1.1. 合约文件

```

pragma solidity ⁰.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}

```

### 1.2. 部署合约

启动 Ethereum Wallet，点击 CONTRACTS 按钮，进入合约管理界面

| ![](img/coin1.png) |

点击 DEPLOY NEW CONTRACT 按钮，部署一个新合约

| ![](img/coin2.png) |

复制粘贴合约文件到 SOLIDITY CONTRACT SOURCE CODE 下方

SELECT CONTRACT TO DEPLOY 列表选择 “Token ERC 20”

Initial supply 是初始发行货币量

Token name 是代币名称

Token symbol 是代币符号

| ![](img/coin3.png) |

拉动滚动调，找到下方 “DEPLOY”按钮，点击该按钮。

| ![](img/coin4.png) |

输入账号密码，并点击“SEND TRANSACTION” 按钮。

| ![](img/coin5.png) |

ERC20 代币创建完成

### 1.3. 代币转账

进入钱包可以看到当前账号的以太币数量，在下方还能看到 ERC20 代币。

| ![](img/coin6.png) |

点击 SEND 按钮

| ![](img/coin7.png) |

填写 TO 地址 和 代币 500 个，点击 SEND 按钮

| ![](img/coin8.png) |

进入目标账号查看余额。

| ![](img/coin9.png) |

### 1.4. Verify And Publish

查看合约执行状态等待执行完成 TxReceipt Status:Success

| ![](img/transaction.png) |

点击合约地址，查看合约

| ![](img/contract.png) |

进入 Code 选项卡，点击 Verify And Publish 按钮

| ![](img/code.png) |

输入合约名称 Contract Name，选择编译器版本 Compiler，点击 Fetch From Gist 按钮输入 Gist 上的合约地址。

| ![](img/gist.png) |

Optimization 选择 Yes

| ![](img/verify-and-publish.png) |

勾选验证码, 然后点击 Verify And Publish 按钮

| ![](img/captcha.png) |

合约校验成功

| ![](img/done.png) |

### 1.5. Links 链接更新

| ![](img/update.png) |

| ![](img/submit.png) |

| ![](img/sign_message.png) |

复制签名信息

进入 MyEtherWallet 签名页面 [`www.myetherwallet.com/signmsg.html`](https://www.myetherwallet.com/signmsg.html)

粘贴签名信息

| ![](img/verify_message.png) |

选择私钥签名

| ![](img/private_key.png) |

解锁账号

| ![](img/unlock.png) |

签名，复制 sig 的值

| ![](img/signature.png) |

粘贴 sig，然后点击 Verify 按钮

| ![](img/signature_hash.png) |

| ![](img/fill_in_form.png) |

| ![](img/fill_in_form1.png) |

信息填写完成后点击“Send Message” 保存

| ![](img/done.png) |

## 2. ERC20 Token Solidity 0.4.24

[`theethereum.wiki/w/index.php/ERC20_Token_Standard`](https://theethereum.wiki/w/index.php/ERC20_Token_Standard)

ERC20 “描述了实现代币合约的标准功能”，ERC20 是各个代币的标准接口。ERC20 代币仅仅是以太坊代币的子集。为了充分兼容 ERC20，开发者需要将一组特定的函数集成到他们的智能合约中，以便在高层面能够执行以下操作：

ERC20 提供的方法

*   获得代币总供应量

*   获得账户余额

*   转让代币

*   批准花费代币

### 2.1. 构造方法

原合约

```

pragma solidity ⁰.4.21;

contract NetkillerToken {
  address public owner;
  string public name;
  string public symbol;
  uint public decimals;
  uint256 public totalSupply;

  event Transfer(address indexed from, address indexed to, uint256 value);

  /* This creates an array with all balances */
  mapping (address => uint256) public balanceOf;

  function NetkillerToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits) public {
    owner = msg.sender;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
    totalSupply = initialSupply * 10 ** uint256(decimals);
    balanceOf[msg.sender] = totalSupply;
  }

  /* Send coins */
  function transfer(address _to, uint256 _value) public {
    /* Check if the sender has balance and for overflows */
    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

    /* Add and subtract new balances */
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    /* Notify anyone listening that this transfer took place */
    emit Transfer(msg.sender, _to, _value);
  }
}

```

新版合约

```

pragma solidity ⁰.4.24;

contract NetkillerToken {
  address public owner;
  string public name;
  string public symbol;
  uint public decimals;
  uint256 public totalSupply;

  event Transfer(address indexed from, address indexed to, uint256 value);

  /* This creates an array with all balances */
  mapping (address => uint256) public balanceOf;

  constructor(uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits) public {
    owner = msg.sender;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
    totalSupply = initialSupply * 10 ** uint256(decimals);
    balanceOf[msg.sender] = totalSupply;
  }

  /* Send coins */
  function transfer(address _to, uint256 _value) public {
    /* Check if the sender has balance and for overflows */
    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

    /* Add and subtract new balances */
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    /* Notify anyone listening that this transfer took place */
    emit Transfer(msg.sender, _to, _value);
  }
}

```

### 2.2. 官方规定 Method 方法

所有的 ERC20 代币都是按照下面这些方法来定义的。下面我们讲解一下每个方法的作用。

#### 2.2.1. name

function name() view public returns (string name)

返回 string 类型的 ERC20 代币的名字，例如：Netkiller Reader Coin

#### 2.2.2. symbol

function symbol() view public returns (string symbol)

返回 string 类型的 ERC20 代币的符号，也就是代币的简称，例如：NRC。

#### 2.2.3. decimals

function decimals() view public returns (uint decimals)

支持几位小数点后几位。如果设置为 3。也就是支持 0.001 表示。

#### 2.2.4. totalSupply

function totalSupply() view public returns (uint256 totalSupply)

发行代币的总量，可以通过这个函数来获取。所有智能合约发行的代币总量是一定的，totalSupply 必须设置初始值。

#### 2.2.5. balanceOf

function balanceOf(address _owner) public returns (uint256 balance)

输入地址，可以获取该地址代币的余额。

#### 2.2.6. transfer

function transfer(address _to, uint256 _value) public returns (bool success)

调用 transfer 函数将自己的 token 转账给 _to 地址，_value 为转账金额

#### 2.2.7. approve

function approve(address _spender, uint256 _value) public returns (bool success)

批准 _spender 账户从自己的账户转移 _value 个 token。可以分多次转移。

#### 2.2.8. transferFrom

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)

与 approve 搭配使用，approve 批准之后，调用 transferFrom 函数来转移 token。

#### 2.2.9. allowance

function allowance(address _owner, address _spender) public returns (uint256 remaining)

返回 _spender 还能提取 token 的个数。

approve、transferFrom 及 allowance 解释：账户 A 有 1000 个代币，想允许 B 账户随意调用 100 个代币。A 账户按照以下形式调用 approve 函数 approve(B,100)。当 B 账户想用这 100 个代币中的 10 个代币给 C 账户时，则调用 transferFrom(A, C, 10)。这时调用 allowance(A, B)可以查看 B 账户还能够调用 A 账户多少个 token。

### 2.3. 事件

#### 2.3.1. Transfer

event Transfer(address indexed _from, address indexed _to, uint256 _value)

当成功转移 token 时，一定要触发 Transfer 事件

#### 2.3.2. Approval

event Approval(address indexed _owner, address indexed _spender, uint256 _value)

当调用 approval 函数成功时，一定要触发 Approval 事件

## 3. Netkiller Crowdsale Contract

### 3.1. Solidity 0.4.24

```

pragma solidity ⁰.4.24;

/******************************************/
/*      Netkiller Crowdsale Contract      */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-06-07 - Solc ver: 0.4.24  */
/******************************************/

interface token {
    function transfer(address receiver, uint amount) external;
}

contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    /**
     * Constructor function
     *
     * Setup the owner
     */
    constructor(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    /**
     * Fallback function
     *
     * The function without name is the default function that is called whenever anyone sends funds to a contract
     */
    function () payable public{
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    /**
     * Check if goal was reached
     *
     * Checks if the goal or time limit has been reached and ends the campaign
     */
    function checkGoalReached() afterDeadline public{
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /**
     * Withdraw the funds
     *
     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,
     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw
     * the amount they contributed.
     */
    function safeWithdrawal() afterDeadline public{
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                //If we fail to send the funds to beneficiary, unlock funders balance
                fundingGoalReached = false;
            }
        }
    }
}

```

### 3.2. Solidity 0.4.21

```

pragma solidity ⁰.4.21;

interface token {
    function transfer(address receiver, uint amount) external;
}

contract Crowdsale {
    address public beneficiary; // 募资成功后的收款地址
    uint public fundingGoal;    // 募资额度
    uint public amountRaised;   // 参与数量
    uint public deadline;       // 募资截止期

    uint public price;          // token 与以太坊的汇率, token 卖多少钱
    token public tokenReward;   // 要卖的 token

    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;    // 众筹是否达到目标
    bool crowdsaleClosed = false;       // 众筹是否结束

    /**
    * 事件可以用来跟踪信息
    **/
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    /**
     * 构造函数, 设置相关属性
     */
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint finneyCostOfEachToken,
        address addressOfTokenUsedAsReward) public {
            beneficiary = ifSuccessfulSendTo;					//募资成功后的收款账号
            fundingGoal = fundingGoalInEthers * 1 ether;		//募资额度
            deadline = now + durationInMinutes * 1 minutes;		//募资时间
            price = finneyCostOfEachToken * 1 finney;			//每个代币的价格, 这里为了方便使用了单位 finney 及值为：1 （1 ether = 1000 finney）
            tokenReward = token(addressOfTokenUsedAsReward);   	// 代币合约地址。传入已发布的 token 合约的地址来创建实例
    }

    /**
     * 无函数名的 Fallback 函数，
     * 在向合约转账时，这个函数会被调用
     */
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        emit FundTransfer(msg.sender, amount, true);
    }

    /**
    *  定义函数修改器 modifier
    * 用于在函数执行前检查某种前置条件（判断通过之后才会继续执行该方法）
    * _ 表示继续执行之后的代码
    **/
    modifier afterDeadline() { if (now >= deadline) _; }

    /**
     * 判断众筹是否完成融资目标， 这个方法使用了 afterDeadline 函数修改器
     *
     */
    function checkGoalReached() afterDeadline public{
        if (amountRaised >= fundingGoal) {
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }

    /**
     * 完成融资目标时，融资款发送到收款方
     * 未完成融资目标时，执行退款
     *
     */
    function safeWithdrawal() afterDeadline public{
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                //If we fail to send the funds to beneficiary, unlock funders balance
                fundingGoalReached = false;
            }
        }
    }
}			

```

## 4. ERC721 - Non-Fungible Tokens

### 4.1. 

```

interface ERC721 {

    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
    function balanceOf(address _owner) external view returns (uint256);
    function ownerOf(uint256 _tokenId) external view returns (address);
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
    function approve(address _approved, uint256 _tokenId) external payable;
    function setApprovalForAll(address _operator, bool _approved) external;
    function getApproved(uint256 _tokenId) external view returns (address);
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}

interface ERC165 {
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

interface ERC721TokenReceiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);
}			

```

### 4.2. ERC721Metadata (可选)

可选实现接口，ERC721Metadata 接口用于提供合约的元数据：name , symbol 及 URI（NFT 所对应的资源）。

```

其接口定义如下：

interface ERC721Metadata /* is ERC721 */ {
    function name() external pure returns (string _name);
    function symbol() external pure returns (string _symbol);
    function tokenURI(uint256 _tokenId) external view returns (string);
}

接口说明：
name(): 返回合约名字，尽管是可选，但强烈建议实现，即便是返回空字符串。
symbol(): 返回合约代币符号，尽管是可选，但强烈建议实现，即便是返回空字符串。
tokenURI(): 返回 _tokenId 所对应的外部资源文件的 URI（通常是 IPFS 或 HTTP(S)路径）。外部资源文件需要包含名字、描述、图片，其格式的要求如下：			

```

### 4.3. ERC721Enumerable （可选）

可选实现接口，ERC721Enumerable 的主要目的是提高合约中 NTF 的可访问性，其接口定义如下：

```

interface ERC721Enumerable /* is ERC721 */ {
    function totalSupply() external view returns (uint256);
    function tokenByIndex(uint256 _index) external view returns (uint256);
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
}
接口说明：

totalSupply(): 返回 NFT 总量
tokenByIndex(): 通过索引返回对应的 tokenId。
tokenOfOwnerByIndex(): 所有者可以一次拥有多个的 NFT, 此函数返回 _owner 拥有的 NFT 列表中对应索引的 tokenId。			

```

## 5. 经典参考案例

一下是作者发布的合约，供读者参考

### 5.1. Enterprise Token Ecosystem (ETE)

合约地址 [`etherscan.io/address/0x6333050c7a025027b51a8039cbafd2584933299d#code`](https://etherscan.io/address/0x6333050c7a025027b51a8039cbafd2584933299d#code)

### 5.2. 积分链 (PE Chain)

合约地址 [`etherscan.io/address/0x9bcf2ea3a9e18e550eba88c97a8bb6b7ea4f58b7#code`](https://etherscan.io/address/0x9bcf2ea3a9e18e550eba88c97a8bb6b7ea4f58b7#code)

### 5.3. Global star league chain (GSLC)

合约地址 [`etherscan.io/token/0x7ffdcccc3e7e33c6163393195a947a6d45f25814`](https://etherscan.io/token/0x7ffdcccc3e7e33c6163393195a947a6d45f25814)

### 5.4. Kyber Network

合约地址 [`etherscan.io/address/0xC14f34233071543E979F6A79AA272b0AB1B4947D#code`](https://etherscan.io/address/0xC14f34233071543E979F6A79AA272b0AB1B4947D#code)

该合约可以实现币币兑换

## 6. 代币合约官方文档

### 6.1. ERC20

https://github.com/ethereum/EIPs/issues/20

https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md

合约源码：https://github.com/ConsenSys/Tokens/tree/master/contracts/eip20

[`theethereum.wiki/w/index.php/ERC20_Token_Standard`](https://theethereum.wiki/w/index.php/ERC20_Token_Standard)

```

 // ----------------------------------------------------------------------------
 // ERC20 Token Standard Interface
 // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
 // ----------------------------------------------------------------------------
contract ERC20 {
      function name() constant returns (string name)
      function symbol() constant returns (string symbol)
      function decimals() constant returns (uint8 decimals)
      function totalSupply() constant returns (uint totalSupply);
      function balanceOf(address _owner) constant returns (uint balance);
      function transfer(address _to, uint _value) returns (bool success);
      function transferFrom(address _from, address _to, uint _value) returns (bool success);
      function approve(address _spender, uint _value) returns (bool success);
      function allowance(address _owner, address _spender) constant returns (uint remaining);
      event Transfer(address indexed _from, address indexed _to, uint _value);
      event Approval(address indexed _owner, address indexed _spender, uint _value);
}			

```

#### 6.1.1. 基本 Token 官方提供的例子

这个例子仅仅用来初学使用，请不用使用在生产环境。

提供例子的地址： [`ethereum.org/token`](https://ethereum.org/token)

这个例子中没有涉及合约管理者，所以任何人都可以操作这个合约。例如这个减持的函数 burn() 人人都可以调用。所以这个例子只能用来学习 ERC20 合约开发，相当于 Helloword 程序。

```

pragma solidity ⁰.4.16;

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constructor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` on behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}

```

#### 6.1.2. 官方提供的例子 ADVANCED TOKEN

提供例子的地址： [`ethereum.org/token`](https://ethereum.org/token) 网页的下方

这个例子已经比较完善，但仍不能够用在生产环境，因为 function burn(uint256 _value) public returns (bool success) 仍然没有控制访问权限。

如果在生产环境使用这个合约你需要修改两处

```

function burn(uint256 _value) public returns (bool success)
改为
function burn(uint256 _value) onlyOwner public returns (bool success)

function burnFrom(address _from, uint256 _value) public returns (bool success)
改为
function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success)

```

这样合约就很安全了。只能创建者可以减持代币。

```

pragma solidity ⁰.4.16;

contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}

/******************************************/
/*       ADVANCED TOKEN STARTS HERE       */
/******************************************/

contract MyAdvancedToken is owned, TokenERC20 {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }

    /// @notice Sell `amount` tokens to contract
    /// @param amount amount of tokens to be sold
    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
}			

```

下面就分析一下这个合约

在许多应用场景中，需要管理发行的代币，为了对代币进行管理，需要给合约添加一个管理者，为此创建了 owned 合约。

contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    // 实现所有权转移
    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}
这个合约重要的是加入了一个函数修改器（Function Modifiers）onlyOwner，函数修改器是一个合约属性，可以被继承，还能被重写。它用于在函数执行前检查某种前置条件。

代币增发, 实现代币增发，代币增发就如同央行印钞票一样，想必很多人都需要这样的功能。给合约添加以下的方法：

```

function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }
注意 onlyOwner 修改器添加在函数末尾，这表示只有 owner 才能调用这用函数。
他的功能很简单，就是给指定的账户增加代币，同时增加总供应量。

```

资产冻结

有时为了监管的需要，需要实现冻结某些账户，冻结后，其资产仍在账户，但是不允许交易，之道解除冻结。

```

给合约添加以下的变量和方法（可以添加到合约的任何地方，但是建议把 mapping 加到和其他 mapping 一起，event 也是如此）：

mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);

function freezeAccount(address target, bool freeze) onlyOwner {
    frozenAccount[target] = freeze;
    FrozenFunds(target, freeze);
}
单单以上的代码还无法冻结，需要把他加入到 transfer 函数中才能真正生效，因此修改 transfer 函数

function transfer(address _to, uint256 _value) {
        require(!frozenAccount[msg.sender]);
        ...
}
这样在转账前，对发起交易的账号做一次检查，只有不是被冻结的账号才能转账。

```

代币买卖（兑换）

```

可以自己的货币中实现代币与其他数字货币（ether 或其他 tokens）的兑换机制。有了这个功能，我们的合约就可以在一买一卖中赚利润了。

先来设置下买卖价格

uint256 public sellPrice;
uint256 public buyPrice;

function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
    sellPrice = newSellPrice;
    buyPrice = newBuyPrice;
}
setPrices()添加了 onlyOwner 修改器，注意买卖的价格单位是 wei（最小的货币单位： 1 eth = 1000000000000000000 wei)

添加来添加买卖函数:

function buy() payable returns (uint amount){
    amount = msg.value / buyPrice;                    // calculates the amount
    require(balanceOf[this] >= amount);               // checks if it has enough to sell
    balanceOf[msg.sender] += amount;                  // adds the amount to buyer's balance
    balanceOf[this] -= amount;                        // subtracts amount from seller's balance
    Transfer(this, msg.sender, amount);               // execute an event reflecting the change
    return amount;                                    // ends function and returns
}

function sell(uint amount) returns (uint revenue){
    require(balanceOf[msg.sender] >= amount);         // checks if the sender has enough to sell
    balanceOf[this] += amount;                        // adds the amount to owner's balance
    balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller's balance
    revenue = amount * sellPrice;
    msg.sender.transfer(revenue);                     // sends ether to the seller: it's important to do this last to prevent recursion attacks
    Transfer(msg.sender, this, amount);               // executes an event reflecting on the change
    return revenue;                                   // ends function and returns
}
加入了买卖功能后，要求我们在创建合约时发送足够的以太币，以便合约有能力回购市面上的代币，否则合约将破产，用户没法先合约卖代币。

```

实现 Gas 的自动补充

```

以太坊中的交易时需要 gas（支付给矿工的费用，费用以 ether 来支付）。而如果用户没有以太币，只有代币的情况（或者我们想向用户隐藏以太坊的细节），就需要自动补充 gas 的功能。这个功能将使我们代币更加好用。

自动补充的逻辑是这样了，在执行交易之前，我们判断用户的余额（用来支付矿工的费用），如果用户的余额非常少（低于某个阈值时）可能影响到交易进行，合约自动售出一部分代币来补充余额，以帮助用户顺利完成交易。

先来设定余额阈值：

uint minBalanceForAccounts;

    function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
         minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
    }
finney 是货币单位 1 finney = 0.001eth
然后交易中加入对用户的余额的判断。

function transfer(address _to, uint256 _value) {
    ...
    if(msg.sender.balance < minBalanceForAccounts)
        sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);
    if(_to.balance<minBalanceForAccounts)   // 可选，让接受者也补充余额，以便接受者使用代币。
        _to.send(sell((minBalanceForAccounts - _to.balance) / sellPrice));
}			

```

#### 6.1.3. Netkiller Basic Token 的例子

下面是我一个合约例子仅供参考，为了部署方便我将所有内容都写入在一个文件中。

合约下载地址： [`github.com/ibook/TokenERC20/blob/master/contracts/TokenERC20.sol`](https://github.com/ibook/TokenERC20/blob/master/contracts/TokenERC20.sol)

有些场景我们需要记录一些数据在区块链上，这个合约增加了 data 数据支持

```

  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));
    transfer(_to, _value);
    require(_to.call(_data));
    return true;
  }			

```

完整的例子如下

```

pragma solidity ⁰.4.20;

// Author: netkiller <netkiller@msn.com>
// Homepage: http://www.netkiller.cn

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract TokenERC20 {
    address public owner;
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    mapping (address => bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        owner = msg.sender;

        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(!frozenAccount[msg.sender]);
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function burn(uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }

  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));
    transfer(_to, _value);
    require(_to.call(_data));
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));

    transferFrom(_from, _to, _value);

    require(_to.call(_data));
    return true;
  }

  function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {
    require(_spender != address(this));

    approve(_spender, _value);

    require(_spender.call(_data));

    return true;
  }

    function transferOwnership(address _owner) onlyOwner public {
        owner = _owner;
    }
    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, owner, mintedAmount);
        Transfer(owner, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) public onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
}

```

#### 6.1.4. Netkiller ADVANCED TOKEN

```

pragma solidity ⁰.4.20;

/******************************************/
/*       Netkiller ADVANCED TOKEN         */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-03-05                     */
/******************************************/

interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

contract NetkillerAdvancedToken {
    address public owner;
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    uint256 public sellPrice;
    uint256 public buyPrice;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function NetkillerAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        owner = msg.sender;
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }

    /// @notice Sell `amount` tokens to contract
    /// @param amount amount of tokens to be sold
    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }

  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));
    transfer(_to, _value);
    require(_to.call(_data));
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));

    transferFrom(_from, _to, _value);

    require(_to.call(_data));
    return true;
  }

  function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {
    require(_spender != address(this));

    approve(_spender, _value);

    require(_spender.call(_data));

    return true;
  }

}			

```

#### 6.1.5. 空投代币

```

uint totalSupply = 100000000 ether; 	// 总发行量
uint currentTotalAirdrop = 0;    		// 已经空投数量
uint airdrop = 1 ether;        		// 单个账户空投数量

// 存储是否空投过
mapping(address => bool) touched;

// 修改后的 balanceOf 方法
function balanceOf(address _owner) public view returns (uint256 balance) {    
    if (!touched[_owner] && currentTotalAirdrop < totalSupply) {
        touched[_owner] = true;
        currentTotalAirdrop += airdrop;
        balances[_owner] += airdrop;
    }    
    return balances[_owner];
}

```

##### 6.1.5.1. 案例一

```

pragma solidity ⁰.4.8;

contract ERC20Interface {
    function totalSupply() public constant returns (uint256 supply);
    function balance() public constant returns (uint256);
    function balanceOf(address _owner) public constant returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

// penispenispenispenis
// YOU get a penis, and YOU get a penis, and YOU get a penis!
contract Penis is ERC20Interface {
    string public constant symbol = "PNS";
    string public constant name = "Penis";
    uint8 public constant decimals = 2;

    uint256 _totalSupply = 0;
    uint256 _airdropAmount = 8008135;
    uint256 _cutoff = _airdropAmount * 80085;

    mapping(address => uint256) balances;
    mapping(address => bool) initialized;

    // Penis accepts request to tip-touch another Penis
    mapping(address => mapping (address => uint256)) allowed;

    function Penis() {
        initialized[msg.sender] = true;
        balances[msg.sender] = _airdropAmount * 8008;
        _totalSupply = balances[msg.sender];
    }

    function totalSupply() constant returns (uint256 supply) {
        return _totalSupply;
    }

    // What's my girth?
    function balance() constant returns (uint256) {
        return getBalance(msg.sender);
    }

    // What is the length of a particular Penis?
    function balanceOf(address _address) constant returns (uint256) {
        return getBalance(_address);
    }

    // Tenderly remove hand from Penis and place on another Penis
    function transfer(address _to, uint256 _amount) returns (bool success) {
        initialize(msg.sender);

        if (balances[msg.sender] >= _amount
            && _amount > 0) {
            initialize(_to);
            if (balances[_to] + _amount > balances[_to]) {

                balances[msg.sender] -= _amount;
                balances[_to] += _amount;

                Transfer(msg.sender, _to, _amount);

                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    // Perform the inevitable actions which cause release of that which each Penis
    // is built to deliver. In EtherPenisLand there are only Penises, so this 
    // allows the transmission of one Penis's payload (or partial payload but that
    // is not as much fun) INTO another Penis. This causes the Penisae to change 
    // form such that all may see the glory they each represent. Erections.
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
        initialize(_from);

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {
            initialize(_to);
            if (balances[_to] + _amount > balances[_to]) {

                balances[_from] -= _amount;
                allowed[_from][msg.sender] -= _amount;
                balances[_to] += _amount;

                Transfer(_from, _to, _amount);

                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    // Allow splooger to cause a payload release from your Penis, multiple times, up to 
    // the point at which no further release is possible..
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    // internal privats
    function initialize(address _address) internal returns (bool success) {
        if (_totalSupply < _cutoff && !initialized[_address]) {
            initialized[_address] = true;
            balances[_address] = _airdropAmount;
            _totalSupply += _airdropAmount;
        }
        return true;
    }

    function getBalance(address _address) internal returns (uint256) {
        if (_totalSupply < _cutoff && !initialized[_address]) {
            return balances[_address] + _airdropAmount;
        }
        else {
            return balances[_address];
        }
    }
}				

```

##### 6.1.5.2. 案例二

```

pragma solidity ⁰.4.8;

contract ERC20Interface {
    function totalSupply() public constant returns (uint256 supply);
    function balance() public constant returns (uint256);
    function balanceOf(address _owner) public constant returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract Simoleon is ERC20Interface {
    string public constant symbol = "SIM";
    string public constant name = "Simoleon";
    uint8 public constant decimals = 2;

    uint256 _totalSupply = 0;
    uint256 _airdropAmount = 1000000;
    uint256 _cutoff = _airdropAmount * 10000;

    mapping(address => uint256) balances;
    mapping(address => bool) initialized;

    // Owner of account approves the transfer of an amount to another account
    mapping(address => mapping (address => uint256)) allowed;

    function Simoleon() {
        initialized[msg.sender] = true;
        balances[msg.sender] = _airdropAmount * 1000;
        _totalSupply = balances[msg.sender];
    }

    function totalSupply() constant returns (uint256 supply) {
        return _totalSupply;
    }

    // What's my balance?
    function balance() constant returns (uint256) {
        return getBalance(msg.sender);
    }

    // What is the balance of a particular account?
    function balanceOf(address _address) constant returns (uint256) {
        return getBalance(_address);
    }

    // Transfer the balance from owner's account to another account
    function transfer(address _to, uint256 _amount) returns (bool success) {
        initialize(msg.sender);

        if (balances[msg.sender] >= _amount
            && _amount > 0) {
            initialize(_to);
            if (balances[_to] + _amount > balances[_to]) {

                balances[msg.sender] -= _amount;
                balances[_to] += _amount;

                Transfer(msg.sender, _to, _amount);

                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    // Send _value amount of tokens from address _from to address _to
    // The transferFrom method is used for a withdraw workflow, allowing contracts to send
    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge
    // fees in sub-currencies; the command should fail unless the _from account has
    // deliberately authorized the sender of the message via some mechanism; we propose
    // these standardized APIs for approval:
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
        initialize(_from);

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {
            initialize(_to);
            if (balances[_to] + _amount > balances[_to]) {

                balances[_from] -= _amount;
                allowed[_from][msg.sender] -= _amount;
                balances[_to] += _amount;

                Transfer(_from, _to, _amount);

                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.
    // If this function is called again it overwrites the current allowance with _value.
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    // internal private functions
    function initialize(address _address) internal returns (bool success) {
        if (_totalSupply < _cutoff && !initialized[_address]) {
            initialized[_address] = true;
            balances[_address] = _airdropAmount;
            _totalSupply += _airdropAmount;
        }
        return true;
    }

    function getBalance(address _address) internal returns (uint256) {
        if (_totalSupply < _cutoff && !initialized[_address]) {
            return balances[_address] + _airdropAmount;
        }
        else {
            return balances[_address];
        }
    }
}			

```

##### 6.1.5.3. 案例三

```

pragma solidity ⁰.4.18;

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);
    return c;
  }
}

contract Ownable {
  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

contract SurpriseToken is Ownable{

    using SafeMath for uint256;

    string public constant name       = "SURPRISE";
    string public constant symbol     = "SPS";
    uint32 public constant decimals   = 18;
    uint256 public totalSupply        = 208932000 ether;
    uint256 public currentTotalSupply = 0;
    uint256 startBalance              = 276 ether;

    mapping(address => bool) touched;
    mapping(address => uint256) balances;
    mapping (address => mapping (address => uint256)) internal allowed;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));

        if( !touched[msg.sender] && currentTotalSupply < totalSupply ){
            balances[msg.sender] = balances[msg.sender].add( startBalance );
            touched[msg.sender] = true;
            currentTotalSupply = currentTotalSupply.add( startBalance );
        }

        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));

        require(_value <= allowed[_from][msg.sender]);

        if( !touched[_from] && currentTotalSupply < totalSupply ){
            touched[_from] = true;
            balances[_from] = balances[_from].add( startBalance );
            currentTotalSupply = currentTotalSupply.add( startBalance );
        }

        require(_value <= balances[_from]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
     }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
        uint oldValue = allowed[msg.sender][_spender];
        if (_subtractedValue > oldValue) {
          allowed[msg.sender][_spender] = 0;
        } else {
          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
        }
        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
        return true;
     }

    function getBalance(address _a) internal constant returns(uint256)
    {
        if( currentTotalSupply < totalSupply ){
            if( touched[_a] )
                return balances[_a];
            else
                return balances[_a].add( startBalance );
        } else {
            return balances[_a];
        }
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return getBalance( _owner );
    }
}				

```

### 6.2. ERC223 token standard reference implementation.

[`github.com/Dexaran/ERC223-token-standard`](https://github.com/Dexaran/ERC223-token-standard)

ERC223 是以太坊上最新的代币(token)接口标准,主要是为了解决 ERC220 代币转账丢失问题

ERC220 接口以 transfer 为例:

```

// @notice send `_value` token to `_to` from `msg.sender` 
// @param _to The address of the recipient 
// @param _value The amount of token to be transferred 
// @return Whether the transfer was successful or not 
function transfer(address _to, uint256 _value) public returns (bool success);

```

transfer 的功能非常简单，给一个指定地址转多少代币。

但是当初设计的时候没有考虑到的一个问题就是如果接收者是一个智能合约,那么合约是没法感知自己收到了多少 token 的.

ERC223 中的方法定义

```

function transfer(address _to, uint _value) public returns (bool ok);
function transfer(address _to, uint _value, bytes _data) public returns (bool ok);
function transfer(address _to, uint _value, bytes _data, string _custom_fallback)		

```

除此之外 ERC223 还提供了安全的数学运算方法。

```

pragma solidity ⁰.4.11;

/**
 * Math operations with safety checks
 */
library SafeMath {
  function mul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint a, uint b) internal returns (uint) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function add(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
  }

  function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal constant returns (uint256) {
    return a < b ? a : b;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}		

```

ERC223 接口

```

pragma solidity ⁰.4.11;

contract ERC223Interface {
    uint public totalSupply;
    function balanceOf(address who) constant returns (uint);
    function transfer(address to, uint value);
    function transfer(address to, uint value, bytes data);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}

```

```

pragma solidity ⁰.4.11;

 /**
 * @title Contract that will work with ERC223 tokens.
 */

contract ERC223ReceivingContract { 
/**
 * @dev Standard ERC223 function that will handle incoming token transfers.
 *
 * @param _from  Token sender address.
 * @param _value Amount of tokens.
 * @param _data  Transaction metadata.
 */
    function tokenFallback(address _from, uint _value, bytes _data);
}		

```

```

pragma solidity ⁰.4.11;

import './ERC223_interface.sol';
import './ERC223_receiving_contract.sol';
import '././SafeMath.sol';

/**
 * @title Reference implementation of the ERC223 standard token.
 */
contract ERC223Token is ERC223Interface {
    using SafeMath for uint;

    mapping(address => uint) balances; // List of user balances.

    /**
     * @dev Transfer the specified amount of tokens to the specified address.
     *      Invokes the `tokenFallback` function if the recipient is a contract.
     *      The token transfer fails if the recipient is a contract
     *      but does not implement the `tokenFallback` function
     *      or the fallback function to receive funds.
     *
     * @param _to    Receiver address.
     * @param _value Amount of tokens that will be transferred.
     * @param _data  Transaction metadata.
     */
    function transfer(address _to, uint _value, bytes _data) {
        // Standard function transfer similar to ERC20 transfer with no _data .
        // Added due to backwards compatibility reasons .
        uint codeLength;

        assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        Transfer(msg.sender, _to, _value, _data);
    }

    /**
     * @dev Transfer the specified amount of tokens to the specified address.
     *      This function works the same with the previous one
     *      but doesn't contain `_data` param.
     *      Added due to backwards compatibility reasons.
     *
     * @param _to    Receiver address.
     * @param _value Amount of tokens that will be transferred.
     */
    function transfer(address _to, uint _value) {
        uint codeLength;
        bytes memory empty;

        assembly {
            // Retrieve the size of the code on target address, this needs assembly .
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, empty);
        }
        Transfer(msg.sender, _to, _value, empty);
    }

    /**
     * @dev Returns balance of the `_owner`.
     *
     * @param _owner   The address whose balance will be returned.
     * @return balance Balance of the `_owner`.
     */
    function balanceOf(address _owner) constant returns (uint balance) {
        return balances[_owner];
    }
}

```

### 6.3. ERC721 - Non-fungible Token Standard

[`eips.ethereum.org/EIPS/eip-721`](https://eips.ethereum.org/EIPS/eip-721)

[`github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC721`](https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC721)

ERC721 是以太猫项目采用的合约标准。

### 6.4. ERC827 Token Standard (ERC20 Extension)

[`github.com/ethereum/EIPs/issues/827`](https://github.com/ethereum/EIPs/issues/827)

[`github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC827`](https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC827)

### 6.5. ERC875 for non fungible tokens and simple atomic swaps

[`github.com/ethereum/EIPs/issues/875`](https://github.com/ethereum/EIPs/issues/875)

[`github.com/alpha-wallet/ERC875-Example`](https://github.com/alpha-wallet/ERC875-Example)

### 6.6. ERC: Standard URI scheme with metadata, value and byte code

[`gist.github.com/netkiller/427c196eb256ed43c7be08ac875d34a7`](https://gist.github.com/netkiller/427c196eb256ed43c7be08ac875d34a7)

## 第 14 章 智能合约语言 Solidity v0.5.0

### *本文作者最近在找工作，有意向致电 13113668890*

Solidity 是什么？Solidity 是以太坊智能合约的编程语言。

## 1. Remix - browser-solidity

在线使用 browser-solidity

[`ethereum.github.io/browser-solidity/`](https://ethereum.github.io/browser-solidity/) [`remix.ethereum.org/`](https://remix.ethereum.org/)

国内网络有时不给力，建议将 Remix 安装到本地目录。

### 1.1. 将 Remix(browser-solidity) 安装到本地

共享合约目录

```

npm install -g remixd
remixd -S "/home/ethereum/codebase/blocks/contracts"		

```

安装 browser-solidity

```

git clone https://github.com/ethereum/browser-solidity 
cd browser-solidity 
npm install 
npm run prepublish

sudo chown -R $USER:$(id -gn $USER) /home/neo/.config

npm start

```

启动后浏览器中输入 [`localhost:8080`](http://localhost:8080) 可以看到 Remix 界面

### Web3 Provider

Remix 提供三种运行环境,常用的有 JavaScript VM 和 Web3 Provider (连接到 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --rpcport 8545)

Web3 Provider 方式需要解锁账号和启动挖矿

```

> personal.unlockAccount(eth.accounts[0],"");
> miner.start(2); admin.sleepBlocks(1); miner.stop();			

```

### 1.2. 输入数组

```

	function mint(address[] _to, uint256 _value) public returns (bool success) {
        for (uint i=0; i<_to.length; i++) {
            balanceOf[_to[i]] = _value;
        }
        return true;
    }

```

在 Remix 中输入数组的方法

```

["0x6F56648fbD2306f843442f8dC61d5C8861Fac7C9","0x81b7E08F65Bdf5648606c89998A9CC8164397647"]			

```

## 2. solc 命令

### 2.1. 使用 solc 编译 *.sol 代码

```

neo@netkiller ~/ethereum/solidity % solc --bin --abi --optimize -o ./output helloworld.sol
neo@netkiller ~/ethereum/solidity % find output         
output
output/HelloWorld.bin
output/HelloWorld.abi			

```

## 3. 智能合约入门演示

这里我们先做一个 Helloword 演示，让你初步对智能合约有一个大概的认识。

### 提示

需要注意的是，你在网上会看到很多例子，对照这例子一步一步操作，始终无法成功，这根 Solidity 的版本有很大关系。

将下面代码粘贴到

```

pragma solidity ⁰.4.25;

contract HelloWorld
{
    string tmp;

    function HelloWorld() public
    {

    }

    function get() public constant returns (string)
    {
        return tmp;
    }

    function set(string _tmp) public
    {
        tmp = _tmp;
    }

}

```

Compile - Details - WEB3DEPLOY

```

var helloworldContract = web3.eth.contract([{"constant":false,"inputs":[{"name":"_tmp","type":"string"}],"name":"set","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]);
var helloworld = helloworldContract.new(
   {
     from: web3.eth.accounts[0], 
     data: '0x6060604052341561000f57600080fd5b6102e38061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ed3885e146100515780636d4ce63c146100ae575b600080fd5b341561005c57600080fd5b6100ac600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061013c565b005b34156100b957600080fd5b6100c1610156565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101015780820151818401526020810190506100e6565b50505050905090810190601f16801561012e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b80600090805190602001906101529291906101fe565b5050565b61015e61027e565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101f45780601f106101c9576101008083540402835291602001916101f4565b820191906000526020600020905b8154815290600101906020018083116101d757829003601f168201915b5050505050905090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061023f57805160ff191683800117855561026d565b8280016001018555821561026d579182015b8281111561026c578251825591602001919060010190610251565b5b50905061027a9190610292565b5090565b602060405190810160405280600081525090565b6102b491905b808211156102b0576000816000905550600101610298565b5090565b905600a165627a7a72305820ea826c30d131f20a4d3a8e3fb059ffa95f4c222a5b099029750e4c1937b46e5b0029', 
     gas: '4700000'
   }, function (e, contract){
    console.log(e, contract);
    if (typeof contract.address !== 'undefined') {
         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);
    }
 })

```

部署智能合约需要消耗 gas 所以你要先解锁账号。

```

> personal.unlockAccount("0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "", 300)
true			

```

```

> var helloworldContract = web3.eth.contract([{"constant":false,"inputs":[{"name":"_tmp","type":"string"}],"name":"set","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"}]);
undefined
> var helloworld = helloworldContract.new(
...    {
......      from: web3.eth.accounts[0], 
......      data: '0x6060604052341561000f57600080fd5b6102e38061001e6000396000f30060606040526004361061004c576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680634ed3885e146100515780636d4ce63c146100ae575b600080fd5b341561005c57600080fd5b6100ac600480803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509190505061013c565b005b34156100b957600080fd5b6100c1610156565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156101015780820151818401526020810190506100e6565b50505050905090810190601f16801561012e5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b80600090805190602001906101529291906101fe565b5050565b61015e61027e565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156101f45780601f106101c9576101008083540402835291602001916101f4565b820191906000526020600020905b8154815290600101906020018083116101d757829003601f168201915b5050505050905090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061023f57805160ff191683800117855561026d565b8280016001018555821561026d579182015b8281111561026c578251825591602001919060010190610251565b5b50905061027a9190610292565b5090565b602060405190810160405280600081525090565b6102b491905b808211156102b0576000816000905550600101610298565b5090565b905600a165627a7a72305820ea826c30d131f20a4d3a8e3fb059ffa95f4c222a5b099029750e4c1937b46e5b0029', 
......      gas: '4700000'
......    }, function (e, contract){
......     console.log(e, contract);
......     if (typeof contract.address !== 'undefined') {
.........          console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);
.........     }
......  })
null [object Object]
undefined

```

helloworld 智能合约已经创建完毕

```

> helloworld
{
  abi: [{
      constant: false,
      inputs: [{...}],
      name: "set",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
  }, {
      constant: true,
      inputs: [],
      name: "get",
      outputs: [{...}],
      payable: false,
      stateMutability: "view",
      type: "function"
  }, {
      inputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "constructor"
  }],
  address: undefined,
  transactionHash: "0x466c9ad9db8f37ed5b65bc261210da92f51364ebab1dcbd3759bfc3e16ad6502"
}

```

## 4. 数据类型

### 4.1. 数值型

int/uint：变长的有符号或无符号整型。变量支持的步长以 8 递增，支持从 uint8 到 uint256，以及 int8 到 int256。需要注意的是，uint 和 int 默认代表的是 uint256 和 int256。

有符号整型能够表示负数的代价是其能够存储正数的范围的缩小，因为其约一半的数值范围要用来表示负数。如：uint8 的存储范围为 0 ~ 255，而 int8 的范围为-127 ~ 127

支持的运算符:

比较：<=，<，==，!=，>=，>，返回值为 bool 类型。

位运算符：&，|，（^异或），（~非）。

数学运算：+，-，一元运算+，*，/，（%求余），（**次方），（<<左移），（>>右移）。

小数由"."组成，在他的左边或右边至少要包含一个数字。如"1."，".1"，"1.3"均是有效的小数。

#### 4.1.1. 加 +，减 -，乘 *，除 ／ 运算演示

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function mul(int a, int b) public pure returns (int) {

      int c = a * b;
      return c;
  }

  function div(int a, int b) public pure  returns (int) {

      int c = a / b;
      return c;
  }

  function sub(int a, int b) public pure  returns (int) {

      return a - b;
  }

  function add(int a, int b) public pure  returns (int) {

      int c = a + b;
      return c;
  }
}				

```

#### 4.1.2. 求余 % 运算演示

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function m(int a, int b) public pure returns (int) {

      int c = a % b;
      return c;
  }
}				

```

#### 4.1.3. 幂运算演示

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function m(uint a, uint b) public pure returns (uint) {

      uint c = a**b;
      return c;
  }

}				

```

#### 4.1.4. 与 &，| 或，非 ～，异或 ^ 演示

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Math {

  function yu() public pure returns (uint) {

      uint a = 3; // 0b0011
      uint b = 4; // 0b0100

      uint c = a & b; // 0b0000
      return c; // 0
  }

  function huo() public pure returns (uint) {

      uint a = 3; // 0b0011
      uint b = 4; // 0b0100

      uint c = a | b; // 0b0111
      return c; // 7
  }

  function fei() public pure returns (uint8) {

      uint8 a = 3; // 0b00000011
      uint8 c = ~a; // 0b11111100
      return c; // 0
  }

  function yihuo() public pure returns (uint) {

      uint a = 3; // 0b0011
      uint b = 4; // 0b0100

      uint c = a ^ b; // 0b0111
      return c; // 252
  }
}

```

#### 4.1.5. 位移演示

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn

contract Math {

  function leftShift() public pure returns (uint8) {

      uint8 a = 8; // 0b00001000
      uint8 c = a << 2; // 0b00100000
      return c; // 32
  }

  function rightShift() public pure returns (uint8) {

      uint8 a = 8; // 0b00001000
      uint8 c = a >> 2; // 0b00000010
      return c; // 2
  }

}

```

a << n 表示 a 的二进制位向左移动 n 位，在保证位数没有溢出的情况下等价于 a 乘以 2 的 n 次方。
a >> n 表示 a 的二进制位向右移动 n 位，在保证位数没有溢出的情况下等价于 a 除以 2 的 n 次方。

### 4.2. 字符串

string 字符串类型，字符串可以通过""或者''来定义字符串的值

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract StringTest {

    string name;

    function StringTest() public{
        name = "default";
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
}			

```

#### 4.2.1. 获取字符串长度

在 Solidity 中想获得字符串长度必须转成 bytes 类型然后使用 length 属性获得。bytes(string).length

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract StringTest {

    string public name = "http://www.netkiller.cn";

    function nameBytes() public constant returns (bytes) {

        return bytes(name);
    }

    function nameLength() public constant returns (uint) {

        return bytes(name).length;
    }

    function length(string _name) public pure returns (uint) {

        return bytes(_name).length;
    }

}

```

### 提示

注意：汉字采用 UTF8 编码，一个汉字等于 3 个字节，当你使用 length("景峯") 测试时会返回长度 6。

### 4.3. 布尔(Booleans)

bool: 可能的取值为常量值 true 和 false。支持的运算符：

```

! 逻辑非

&& 逻辑与

|| 逻辑或

== 等于

!= 不等于

bool a = true;
bool b = !a;

// a == b -> false
// a != b -> true
// a || b -> true
// a && b -> false			

```

### 4.4. 字节类型

```

bytes names = "netkiller"
bytes9 _names = "netkiller";
bytes(name)[0] = 0xFF;

bytes memory _tmp = new bytes(3);
_tmp[0] = 0x4e;
_tmp[1] = 0x65;
_tmp[2] = 0x6f;

```

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract BytesTest {

    bytes names = "netkiller";

    function get() public view returns (bytes) {

        return names;
    }
    function getBytes2() public pure returns (bytes2) {
        bytes9 _names = "netkiller";
        return bytes2(_names);
    }
    function bytesToString() public constant returns (string) {

        return string(names);
    }

    function copyBytes(bytes b) public pure returns (bytes) {

       bytes memory tmp = new bytes(b.length);

       for(uint i = 0; i < b.length; i++) {

           tmp[i] = b[i];
       }

       return tmp;
    }

    function bytesToString2() public pure returns (string) {
        bytes memory _tmp = new bytes(3);
        _tmp[0] = 0x4e;
        _tmp[1] = 0x65;
        _tmp[2] = 0x6f;
        return string(_tmp);
    }

}			

```

.length 可以动态修改字节数组的长度

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract BytesTest2 {

    // 初始化一个两个字节空间的字节数组
    bytes public array = new bytes(2);

    // 设置修改字节数组的长度
    function setLength(uint _len) public {
        array.length = _len;
    }

    // 返回字节数组的长度
    function getLength() constant public returns (uint) {
        return array.length;
    }

    // 往字节数组中添加字节
    function pushArray(byte _tmp) public{
        array.push(_tmp);
    }

}			

```

### 4.5. 数组

```

	//创建一个 memory 的数组
	uint[] memory a = new uint[](7);

	uint[] x = [uint(1), 3, 4];

    bytes memory b = new bytes(10);

```

二维数组

```

uint [2][3] T = [[1,2],[3,4],[5,6]];			

```

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract ArrayTest {

    uint [] array = [1,2,3,4,5];

    // 通过 for 循环计算数组内部的值的总和
    function sum() constant public returns (uint) {
        uint num = 0;
        for(uint i = 0; i < array.length; i++) {
            num = num + array[i];
        }
        return num;
    }

    function sumNumbers(uint[] _numbers) public pure returns (uint) {
        uint num = 0;
        for(uint i = 0; i < _numbers.length; i++) {
            num = num + _numbers[i];
        }
        return num;
    }

}

```

#### 4.5.1. length

.length 属性是活动数组的尺寸

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract ArrayLength {

    uint [] array = [1,2,3,4,5];

    function getLength() public constant returns (uint) {

        return array.length;
    }

}				

```

#### 4.5.2. push() 方法

通过 push 可以向数组中添加数据

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract ArrayLength {

    uint [] array = [1,2,3,4,5];

    function pushArray() public {

        array.push(6);
    }

    function getLength() public constant returns (uint) {

        return array.length;
    }

}				

```

### 4.6. 枚举类型

State 就是一个自定义的整型，当枚举数不够多时，它默认的类型为 uint8，当枚举数足够多时，它会自动变成 uint16，枚举下标定义从左至右从零开始。

New=0, Pending=1, Done=2, Deleted=3

访问枚举方式 State.New 实际等于数字 0

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract EnumTest {
    enum State { New, Pending, Done, Deleted }
    State state = State.New;

    function set(State _state) public {
        state = _state;
    }

    function get() constant public returns (State) {
        return state;
    }

}			

```

枚举用来定义状态

```

pragma solidity ⁰.4.0;

contract Purchase {
    enum State { Created, Locked, Inactive } // Enum
}				

```

### 4.7. 结构体

定义结构体

```

	struct Voter {
        uint weight; // weight is accumulated by delegation
        bool voted;  // if true, that person already voted
        address delegate; // person delegated to
        uint vote;   // index of the voted proposal
    }

    // This is a type for a single proposal.
    struct Proposal {
        bytes32 name;   // short name (up to 32 bytes)
        uint voteCount; // number of accumulated votes
    }			

```

演示例子

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Students {

    struct Person {
        string name;
        uint age;
        uint class;

    }

    Person person = Person("Neo",18,1);

    function getPerson() public view returns(string){
        return person.name;
    }
}				

```

#### 4.7.1. 函数返回 Struct

Struct 不知直接返回，解决方法如下

```

pragma solidity ⁰.4.19;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract Netkiller {
    struct JobStruct {
      uint a;
      uint b;
      uint c;
    }

    function getValues () public pure returns (uint, uint, uint) {
      JobStruct memory js = JobStruct(1, 2, 3);
      return (js.a, js.b, js.c);
    }
}				

```

### 4.8. address

```

address public minter;

```

下面是一个获得账号余额的例子。

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract AddressTest{

    function getBalance(address _addr) public constant returns (uint){
        return _addr.balance;
    }

}			

```

#### 4.8.1. payable

#### 4.8.2. .value()

#### 4.8.3. .gas()

### 4.9. mapping

mapping 就是图数据结构，由 key 和 value 组成。

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract MappingExample {

    mapping(uint => string) map;

    function put(uint key, string value) public {
        map[key] = value;
    }

    function get(uint key) constant public returns (string) {
        return map[key];
    }
}			

```

## 5. 单位

### 5.1. 货币单位（Ether Units）

kwei (1000 Wei)
mwei (1000 KWei)
gwei (1000 mwei)
szabo (1000 gwei)
finney (1000 szabo)
ether (1000 finney)

以太币单位其实是密码学家的名字，是以太坊创始人为了纪念他们在数字货币的领域的贡献。他们分别是：
wei: Wei Dai 戴伟 密码学家 ，发表 B-money
finney: Hal Finney 芬尼 密码学家、工作量证明机制（POW）提出
szabo: Nick Szabo 尼克萨博 密码学家、智能合约的提出者

```

pragma solidity ⁰.4.25;
//Author: netkiller <netkiller@msn.com>
//Home: http://www.netkiller.cn
contract UnitTest {
    function tf() public pure returns (bool) {
      if (1 ether == 1000 finney){
          return true;
      }
      return false;
    }

    function ts() public pure returns (bool) {
      if (1 ether == 1000000 szabo){
          return true;
      }
      return false;
    }

    function tgw() public pure returns (bool) {
      if (1 ether == 1000000000000000000 wei){
          return true;
      }
      return false;
    }
}			

```

### 5.2. 时间单位（Time Units）

时间单位: seconds, minutes, hours, days, weeks, years 均可做为后缀，并进行相互转换，规则如下：

1 == 1 seconds (默认是 seconds 为单位)
1 minutes == 60 seconds
1 hours == 60 minutes
1 days == 24 hours
1 weeks = 7 days
1 years = 365 days

由于无法预测闰秒，必须由外部的预言（oracle）来更新从而得到一个精确的日历库。
所以使用这些单位进行日期计算需要特别小心，因为不是每年都是 365 天，且并不是每天都有 24 小时，因为还有闰秒。

## 6. 变量

```

address public minter;
string name;
int num;	

    uint constant x = 32**22 + 8;
    string constant text = "abc";
    bytes32 constant myHash = keccak256("abc");

    uint256 ticket = 1 ether;

```

变量赋值

```

pragma solidity ⁰.4.25;

contract C {
    uint[] data;

    function f() public view returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        // 声明和分配变量。 明确指定类型是不可能的。
        var (x, b, y) = f();
        // 分配给一个预先存在的变量。
        (x, y) = (2, 7);
        // 互换值的常用技巧对于非价值存储类型不起作用。
        (x, y) = (y, x);
        // 组件可以省略（也可以用于变量声明）。
        // 如果元组以空组件结束，其余的值将被丢弃。
        (data.length,) = f(); // 设置长度为 7
        // 在左边也可以做同样的事情。
        (,data[3]) = f(); // Sets data[3] to 2
        // 组件只能在作业的左侧排除，但有一个例外：
        (x,) = (1,);
        // (1,) 是指定 1 元组元的唯一方法，因为（1）等于 1。
    }
}			

```

### 6.1. 全局变量

```

block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only
works for 256 most recent blocks
block.coinbase (address): current block miner’s address
block.difficulty (uint): current block difficulty
block.gaslimit (uint): current block gaslimit
block.number (uint): current block number
block.timestamp (uint): current block timestamp
msg.data (bytes): complete calldata
msg.gas (uint): remaining gas
msg.sender (address): sender of the message (current call)
msg.value (uint): number of wei sent with the message
now (uint): current block timestamp (alias for block.timestamp)
tx.gasprice (uint): gas price of the transaction
6.4\. Solidity in Depth 99Solidity Documentation, 0.4.10
tx.origin (address): sender of the transaction (full call chain)
revert(): abort execution and revert state changes
keccak256(...) returns (bytes32): compute the Ethereum-SHA-3 (Keccak-256) hash of the
(tightly packed) arguments
sha3(...) returns (bytes32): an alias to keccak256()
sha256(...) returns (bytes32): compute the SHA-256 hash of the (tightly packed) arguments
ripemd160(...) returns (bytes20): compute the RIPEMD-160 hash of the (tightly packed) arguments
ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):
recover address associated with the public key from elliptic curve signature, return zero on error
addmod(uint x, uint y, uint k) returns (uint): compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256
mulmod(uint x, uint y, uint k) returns (uint): compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256
this (current contract’s type): the current contract, explicitly convertible to address
super: the contract one level higher in the inheritance hierarchy
selfdestruct(address recipient): destroy the current contract, sending its funds to the given address
.balance (uint256): balance of the Address in Wei
.send(uint256 amount) returns (bool): send given amount of Wei to Address, returns false on failure
.transfer(uint256 amount): send given amount of Wei to Address, throws on failure			

```

block.blockhash(uint blockNumber) returns (bytes32): 某个区块的区块链 hash 值
block.coinbase (address): 当前区块的挖矿地址
block.difficulty (uint): 当前区块的难度
block.gaslimit (uint): 当前区块的 gaslimit
block.number (uint): 当前区块编号
block.timestamp (uint): 当前区块时间戳
msg.data (bytes): 参数数据
msg.gas (uint): 剩余的 gas
msg.sender (address): 当前发送消息的地址，执行合约的地址。
msg.sig (bytes4): 方法 ID
msg.value (uint): 执行合约时，转账的 eth 数量，以 wei 为单位。
now (uint): 时间戳，等价于 block.timestamp (uint)
tx.gasprice (uint): 交易的 gas 单价
tx.origin (address):交易发送地址

### 6.2. storage

使用 storage 这个关键字时，当前的函数必须是 internal 或者 private 类型。

### 6.3. memory

## 7. 函数

### 7.1. 构造方法

构造方法的定义是 contract 与 function 相同

```

pragma solidity ⁰.4.18;

contract MyContractByNetkiller {
    /* Constructor */

    function MyContractByNetkiller() public{

    }
}

```

### 7.2. 定义函数

没有返回值

```

	function setName(string _name) public{
        name = _name;
    }			

```

### 7.3. 函数返回值

有返回值

```

	function getName() public view returns(string){
        return name;
    }

```

### 7.4. 参数传递

除了 f(2,3) 这样传递参数，还可以使用类似字典或 Map 的方式 f({value: 2, key: 3});

```

pragma solidity ⁰.4.0;

contract C {
    function f(uint key, uint value) {
        // ...
    }

    function g() {
        // named arguments
        f({value: 2, key: 3});
    }
}				

```

### 7.5. 函数的例子

完整的例子

```

pragma solidity ⁰.4.18;

contract MyContractByNetkiller {
    /* Constructor */
    string name;
    int num;
    function MyContractByNetkiller() public{
        name = "default";
        num = 1;
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
    function setNum(int n) public{
        num = n;
    }
    function addNum(int m) public view returns(int res){
        res = m + num;
    }
}

```

### 7.6. Fallback function

### 7.7. modifier

modifier 可以理解为 function 的触发器，或者理解为 hook。执行 function 的时候会首先运行 modifier

_; 表示执行 modifier 完成所有命令后，继续运行 function 内的逻辑。

```

pragma solidity ⁰.4.11;  

contract owned {  
    function owned() { owner = msg.sender; }  
    address owner;    
    uint price;
    mapping (address => bool) registeredAddresses;

    modifier onlyOwner {  
        require(msg.sender == owner);  
        _;  
    } 
    function changePrice(uint _price) onlyOwner {  
        price = _price;  
    } 
    function close() onlyOwner {  
        selfdestruct(owner);  
    }  
}

```

## 8. 事件

什么是 event 呢？ 在 Solidity 中 event 类似触发器，是合约与外部程序连接接口。

外部程序监听事件，智能合约中的事件一旦触发，就将数据交给监听程序处理。

换个角度，如果你懂得消息队列，那么只能合约中的 event 是消息发布者，外部的 event 监听程序是消息的消费者。

使用 event 来创建,下面是 ERC20 的标准 event.

```

event Transfer(address indexed from, address indexed to, uint256 value);

```

事件名称你可以随意定义，开头字母大写即可，参数传递根据你的实际需要增加。

```

event Sent(address from, address to, uint amount);		

```

## 9. 面向对象编程

### 9.1. 可见性修饰符

Solidity 对函数和状态变量提供了四种可见性。分别是 external,public,internal,private。其中函数默认是 public。状态变量默认的可见性是 internal。

```

internal - 状态变量默认为 internal 类型，函数只能通过内部访问（当前合约或者继承的合约），可在当前合约或继承合约中调用。类似于 Java 的 protected
public - public 标识的函数是合约接口的一部分。可以通过内部，或者消息来进行调用。与 Java 的 public 含义一致。
external - external 标识的函数是合约接口的一部分。函数只能通过外部的方式调用。外部函数在接收大的数组时更有效。Java 中无与此对应的关键字。
private - 只能在当前合约内访问，在继承合约中都不可访问。与 Java 中的 private 含义一致。

payable ：可支付的函数修饰符，没有该修饰符无法接受转账操作。

```

### 9.2. 错误处理

assert(bool condition)：不满足条件，将抛出异常

require(bool condition)：不满足条件，将抛出异常

revert() 抛出异常

```

if(msg.sender != owner) { revert(); }
assert(msg.sender == owner);
require(msg.sender == owner);			

```

### 9.3. interface 接口

接口是抽象的合约，接口中不能实现方法。

接口：

*   不能继承其他合约或接口

*   不能定义构造方法

*   不能定义变量

*   不能定义结构体

*   不能定义枚举

```

pragma solidity ⁰.4.11;

interface Token {
    function transfer(address recipient, uint amount) public;
}

```

### 9.4. library 库

定义 library

```

pragma solidity ⁰.4.25;

// This is the same code as before, just without comments
library Set {
  struct Data { mapping(uint => bool) flags; }

  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
        return false; // already there
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // not there
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}

```

调用库中的函数

```

contract C {
    using Set for Set.Data; // this is the crucial change
    Set.Data knownValues;

    function register(uint value) public {
        // Here, all variables of type Set.Data have
        // corresponding member functions.
        // The following function call is identical to
        // `Set.insert(knownValues, value)`
        require(knownValues.insert(value));
    }
}

```

#### 9.4.1. 使用库来扩展数据类型

```

pragma solidity ⁰.4.25;

library Search {
    function indexOf(uint[] storage self, uint value)
        public
        view
        returns (uint)
    {
        for (uint i = 0; i < self.length; i++)
            if (self[i] == value) return i;
        return uint(-1);
    }
}

contract C {
    using Search for uint[];
    uint[] data;

    function append(uint value) public {
        data.push(value);
    }

    function replace(uint _old, uint _new) public {
        // This performs the library function call
        uint index = data.indexOf(_old);
        if (index == uint(-1))
            data.push(_new);
        else
            data[index] = _new;
    }
}			

```

### 9.5. 继承

例子 mortal 继承 owned

```

pragma solidity ⁰.4.11;  

contract owned {  
    function owned() { owner = msg.sender; }  
    address owner;  

    modifier onlyOwner {  
        require(msg.sender == owner);  
        _;  
    }  
}  

contract mortal is owned {  
    function close() onlyOwner {  
        selfdestruct(owner);  
    }  
}

```

## 10. 合约调用

```

address token = 0xdC7c2ab64Bc6861852C0Cd60B79564164eD890CF;
token.call(bytes4(sha3("fun(uint256)")), a);		

```

```

Function: transfer(address _to, uint256 _value)
MethodID: 0xa9059cbb		

token.call('0xa9059cbb', _to, _value);

pragma solidity ⁰.4.24;

contract Test{
    address public token;

    constructor(address _contractAddress) public {
        token = _contractAddress; 
    }
    function transfer(address _to, uint256 _value) public returns (bool success){
        if(token.call(bytes4(keccak256("fun(address, uint256)")), _to, _value)){
            return false;
        }
        return true;
    }
}

```

## 11. 合约接收 ETH

首先你需要在智能合约中定义这个函数 function () payable public {}，这时这个合约地址就可以接收 ETH 了。

测试方法，向合约地址发送 ETH 即可。

### 11.1. 调用 selfdestruct(msg.sender); 取出合约中的 ETH

```

pragma solidity ⁰.4.24;

contract NetkillerCashier {

    function () payable public {}

    function claim() public {
        selfdestruct(msg.sender);
    }
}

```

https://ropsten.etherscan.io/tx/0x6504df0e18416c3c319f1f11f84ffa40a752b47c257faee58a7ef2c8ef78cc45

```

 Contract 0x0896827f5e3d2683763321bdf780bde1824f6137  
 TRANSFER  0.03 Ether from 0x0896827f5e3d2683763321bdf780bde1824f6137 to  0x22c57f0537414fd95b9f0f08f1e51d8b96f14029
 SELF-DESTRUCT Contract 0x0896827f5e3d2683763321bdf780bde1824f6137			

```

查看 Code https://ropsten.etherscan.io/address/0x0896827f5e3d2683763321bdf780bde1824f6137#code 显示

```

Contract SelfDestruct called at TxHash 0x6504df0e18416c3c319f1f11f84ffa40a752b47c257faee58a7ef2c8ef78cc45			

```

### 11.2. 自动退款合约

本合约只收取 1 ETH 多余 ETH 将退给用户

```

pragma solidity ⁰.4.24;

// Author: netkiller@msn.com
// Website: http://www.netkiller.cn

contract Refund {

    address owner = 0x0;

    uint256 ticket = 1 ether;

    constructor() public payable {
        owner = msg.sender;
    }

    function () public payable {
        require(msg.value >= ticket);
        if (msg.value > ticket) {
            uint refundFee = msg.value - ticket;
            msg.sender.transfer(refundFee);
        }
    }
}

```

### 11.3. 收款合约自动转账

合约收到 ETH 后自动转到 owner 账号中。

```

pragma solidity ⁰.4.24;

contract NetkillerCashier {

    address public owner;

    constructor() public payable {
        owner = msg.sender;
    }
    function () payable public {
        owner.transfer(msg.value);
    }

}			

```

### 11.4. 指定账号提取 ETH

```

pragma solidity ⁰.4.24;

contract NetkillerCashier {

    address public owner;
    uint public amount;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function () public payable {
        amount += msg.value;
    }

	function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function withdraw() onlyOwner public {
        msg.sender.transfer(amount);
        amount = 0;
    }

}			

```

```

function transferOwnership(address newOwner) 可以修改指定账号提取 ETH
function withdraw()	提取 ETH 的函数

```

https://ropsten.etherscan.io/tx/0xadad8c4cd7649d825fb8c362e97f80c4821b07c97d423050289986bd75703b78

```

 Contract 0xb31fb5297340a06e1af3e21c1780b7001db6890a  
 TRANSFER  0.05 Ether from 0xb31fb5297340a06e1af3e21c1780b7001db6890a to  0x22c57f0537414fd95b9f0f08f1e51d8b96f14029			

```

## 12. 合约中实例化一个接口

在合约中调用一个已经存在的合约。

```

pragma solidity ⁰.4.24;

/******************************************/
/*      Netkiller Crowdsale Contract      */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-06-07 - Solc ver: 0.4.24  */
/******************************************/

interface token {
	function balanceOf(address _address) constant external returns (uint256);
    function transfer(address receiver, uint amount) external;
}

contract Netkiller {

    token public tokenContract;

    constructor(address addressOfToken) public {
        tokenContract = token(addressOfToken);
    }
	function getBalance(address _address) view public returns (uint256){
        return tokenContract.balanceOf(_address);
    }
    function transfer(address _to, uint256 _value) payable public{
        tokenContract.transfer(_to, _value);
    }

}

```

## 13. 合约中实例化另一个合约

当合约已经部署到链上，如需扩展合约的功能可以采用此种方法。

```

pragma solidity ⁰.4.24;

contract ERC20 {
    uint256 public totalSupply;
    uint public decimals;
    function balanceOf(address _address) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool success);
}
contract NetkillerBatchTransfer {

    ERC20 public token;

    constructor(address _contractAddress) public {
        token = ERC20(_contractAddress);
    }
    function getBalance(address _address) view public returns (uint256){
        return token.balanceOf(_address);
    }
}		

```

### 13.1. msg.sender 与 this 的区别

当一个合约访问另一个合约是，msg.sender 与 this 的区别是什么呢？

```

pragma solidity ⁰.4.24;

/******************************************/
/*       Netkiller Mini TOKEN             */
/******************************************/
/* Author netkiller <netkiller@msn.com>   */
/* Home http://www.netkiller.cn           */
/* Version 2018-05-31 Fixed transfer bool */
/******************************************/

contract NetkillerMiniToken {

    constructor() public { }

    function test1() public view returns (address addr){
        return msg.sender;
    }
    function test2() public view returns (address addr){
        return this;
    }
}			

```

例子

```

Contract A: 0xf328c11c4df88d18fcbd30ad38d8b4714f4b33bf
Contract B: 0xb9b7e0cb2edf5ea031c8b297a5a1fa20379b6a0a

```

Contract A 调用 Contract B

```

msg.sender 	= 0xF328c11c4dF88d18FcBd30ad38d8B4714F4b33bF
this		= 0xB9B7e0cb2EDF5Ea031C8B297A5A1Fa20379b6A0a			

```

### 13.2. 地址格式

在合约中出现地址，例如下面：

```

pragma solidity ⁰.4.24;
contract ERC20 {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

contract TestContract{
    ERC20 public token = ERC20(0xAeeD5A0C200efA0670330d0C7509C854c52AF859);

    function tot() public view returns (uint){
        return token.totalSupply();
    }

    function balance(address _address) public view returns (uint){
        return token.balanceOf(_address);
    }

}			

```

合约中不支持全小写的地址。

```

正确的：0xAeeD5A0C200efA0670330d0C7509C854c52AF859
错误的：0xaeed5a0c200efa0670330d0c7509c854c52af859			

```

## 14. Solidity 安全问题

### 14.1. 整型溢出

什么是整型溢出呢？在 solidity 编写合约时，定义整型一般是用 uint8, uint256。一个变量如果定义为 uint8 表示的无符号的 8 位整型，即取值范围为 0-255。当给这个变量赋值 256 时，即整型溢出变成了 0，以此类推 257 变成了 1。

```

pragma solidity ⁰.4.24;

//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn

contract NetkillerOverflowTest{

    function add(uint8 a, uint8 b) pure public returns (uint8){

        uint8 result = a + b;

        return result;

    }

    function sub(uint8 a, uint8 b) pure public returns (uint8){

        uint8 result = a - b;

        return result;

    }

    function mul(uint8 a, uint8 b) pure public returns (uint8){

        uint8 result = a * b;

        return result;

    }

    function div(uint8 a, uint8 b) pure public returns (uint8){

        uint8 result = a / b;

        return result;

    }

}		

```

调用上面合约，运行结果

```

254 + 1 = 255
254 + 2 = 0
254 + 3 = 1

```

减法运行结果

```

10 - 20 = 246

```

乘法运行结果

```

51 * 5 = 255
51 * 6 = 50

```

再来测试乘法

```

255 / 10 = 25			

```

这有点想千年虫问题，即 99 年变成 00 年后，你无法区分 1900 年还是 2000 年。

现在测试一下 uint256，uint256 支持的取值范围是 0 到 2²⁵⁶-1

```

pragma solidity ⁰.4.24;

//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn

contract TestUint256Overflow {
    // (2**256 – 1) + 1 = 0 向上溢出测试
    function overflow() pure public returns (uint256 _overflow) {
        uint256 max = 2 ** 256 - 1;
        return max + 1;
    }

    // 0 – 1 = 2**256 – 1 向下溢出测试
    function underflow() pure public returns (uint256 _underflow) {
        uint256 min = 0;
        return min - 1;
    }
}

```

运行结果

```

_overflow : 0
_underflow : 115792089237316195423570985008687907853269984665640564039457584007913129639935

```

第一个函数溢出为 0，第二个函数 0 - 1 = 115792089237316195423570985008687907853269984665640564039457584007913129639935

解决溢出问题使用 SafeMath 库

```

pragma solidity ⁰.4.24;

//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
    if (a == 0) {
      return 0;
    }

    c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return a / b;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
    c = a + b;
    assert(c >= a);
    return c;
  }
}

contract NetkillerSafeMath {

    using SafeMath for uint256;    

    function add(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.add(b);
        return result;
    }
    function sub(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.sub(b);
        return result;
    }
    function mul(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.mul(b);
        return result;
    }
    function div(uint256 a, uint256 b) pure public returns (uint256){
        uint256 result = a.div(b);
        return result;
    }
}			

```

测试 SafeMath

```

add(115792089237316195423570985008687907853269984665640564039457584007913129639934,1)  => 115792089237316195423570985008687907853269984665640564039457584007913129639935
add(115792089237316195423570985008687907853269984665640564039457584007913129639935,1)  => 抛出异常

```

## 15. solidity example

### 15.1. Voting

```

pragma solidity ⁰.4.25;
//author: netkiller <netkiller@msn.com>
//homepage: http://www.netkiller.cn
contract Voting {

  mapping (bytes32 => uint8) public votesReceived;

  // 存储候选人名字的数组
  bytes32[] public candidateList;

  // 构造函数 初始化候选人名单
  function Voting(bytes32[] candidateNames) public {

    candidateList = candidateNames;
  }

  // 查询某个候选人的总票数
  function totalVotesFor(bytes32 candidate) public constant returns (uint8) {
    require(validCandidate(candidate) == true);
    // 或者
    // assert(validCandidate(candidate) == true);
    return votesReceived[candidate];
  }

  // 为某个候选人投票
  function voteForCandidate(bytes32 candidate) public{
    assert(validCandidate(candidate) == true);
    votesReceived[candidate] += 1;
  }

  // 检索投票的姓名是不是候选人的名字
  function validCandidate(bytes32 candidate) public constant returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }

}

```

### 15.2. MetaCoin

```

pragma solidity ⁰.4.25;
contract MetaCoin {
	mapping (address => uint) balances;
	event Transfer(address indexed _from, address indexed _to, uint256 _value);
	function MetaCoin() public {
		balances[tx.origin] = 10000;
	}
	function sendCoin(address receiver, uint amount) public returns(bool sufficient) {
		if (balances[msg.sender] < amount) return false;
		balances[msg.sender] -= amount;
		balances[receiver] += amount;
		Transfer(msg.sender, receiver, amount);
		return true;
	}
	function getBalance(address addr) public view returns(uint) {
		return balances[addr];
	}
}

```

### 15.3. Anonymous voting on Ethereum without a tally authority. Protocol from this paper

[`github.com/stonecoldpat/anonymousvoting`](https://github.com/stonecoldpat/anonymousvoting)

### 15.4. Ballot

```

pragma solidity ⁰.4.0;
contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    /// Create a new ballot with $(_numProposals) different proposals.
    function Ballot(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    /// Give $(toVoter) the right to vote on this ballot.
    /// May only be called by $(chairperson).
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    /// Delegate your vote to the voter $(to).
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; // assigns reference
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    /// Give a single vote to proposal $(toProposal).
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
}			

```

### 15.5. Conference

```

pragma solidity ⁰.4.25;

contract Conference {
  address public organizer;
  mapping (address => uint) public registrantsPaid;
  uint public numRegistrants;
  uint public quota;

  event Deposit(address _from, uint _amount);  // so you can log these events
  event Refund(address _to, uint _amount); 

  function Conference() public{ // Constructor
    organizer = msg.sender;
    quota = 500;
    numRegistrants = 0;
  }
  function buyTicket() public payable returns (bool success) {
    if (numRegistrants >= quota) { return false; }
    registrantsPaid[msg.sender] = msg.value;
    numRegistrants++;
    Deposit(msg.sender, msg.value);
    return true;
  }
  function changeQuota(uint newquota) public {
    if (msg.sender != organizer) { return; }
    quota = newquota;
  }
  function refundTicket(address recipient, uint amount) public {
    if (msg.sender != organizer) { return; }
    if (registrantsPaid[recipient] == amount) { 
      address myAddress = this;
      if (myAddress.balance >= amount) { 
        recipient.transfer(amount);
        registrantsPaid[recipient] = 0;
        numRegistrants--;
        Refund(recipient, amount);
      }
    }
  }
  function destroy() public{ // so funds not locked in contract forever
    if (msg.sender == organizer) { 
      selfdestruct(organizer); // send funds to organizer
    }
  }
}

```

控制台调试

```

var contract;
Conference.deployed().then(function(instance){contract=instance;});
contract.buyTicket();

```

测试程序

```

neo@MacBook-Pro ~/ethereum/Conference % cat test/conference.js 
var Conference = artifacts.require("./Conference.sol");

contract('Conference', function(accounts) {
	console.log(accounts);
	var owner_account = accounts[0];
    var sender_account = accounts[1];

  it("Initial conference settings should match", function(done) {

  	Conference.deployed({from: owner_account}).then(function(conference) {
        conference.quota.call().then(function(quota) { 
                assert.equal(quota, 100, "Quota doesn't match!"); 
        }).then(function() { 
                return conference.numRegistrants.call(); 
        }).then(function(num) { 
                assert.equal(num, 0, "Registrants doesn't match!");
                return conference.organizer.call();
        }).then(function(organizer) { 
                assert.equal(organizer, owner_account, "Owner doesn't match!");
                done();
        }).catch(done);
  	}).catch(done);
  });

  it("Should update quota", function(done) {

  	Conference.deployed({from: owner_account}).then(function(conference) {
        conference.quota.call().then(
            function(quota) { 
                assert.equal(quota, 100, "Quota doesn't match!"); 
        }).then(
            function() { 
                return conference.changeQuota(300);
        }).then(
            function() { 
                return conference.quota.call()
        }).then(
            function(quota) { 
                assert.equal(quota, 300, "New quota is not correct!");
                done();
        }).catch(done);
  	}).catch(done);
  });

  it("Should let you buy a ticket", function(done) {

  	Conference.deployed({ from: accounts[0] }).then(function(conference) {

        var ticketPrice = web3.toWei(.05, 'ether');
        var initialBalance = web3.eth.getBalance(conference.address).toNumber();  

  			conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(
          function() {
  					var newBalance = web3.eth.getBalance(conference.address).toNumber();
            var difference = newBalance - initialBalance;
  					assert.equal(difference, ticketPrice, "Difference should be what was sent");
  					return conference.numRegistrants.call(); 
  			}).then(
  				function(num) { 
  					assert.equal(num, 1, "there should be 1 registrant");
  					return conference.registrantsPaid.call(sender_account);
  			}).then(
  				function(amount) {
  					assert.equal(amount.toNumber(), ticketPrice, "Sender's paid but is not listed as paying");	
  					return web3.eth.getBalance(conference.address);
  			}).then(
  				function(bal) {
            assert.equal(bal.toNumber(), ticketPrice, "Final balance mismatch");
  					done();
  			}).catch(done);
  	}).catch(done);
  });

  it("Should issue a refund by owner only", function(done) {

    Conference.deployed({ from: accounts[0] }).then(function(conference) {

        var ticketPrice = web3.toWei(.05, 'ether');
        var initialBalance = web3.eth.getBalance(conference.address).toNumber(); 

        conference.buyTicket({ from: accounts[1], value: ticketPrice }).then(
          function() {
            var newBalance = web3.eth.getBalance(conference.address).toNumber();
            var difference = newBalance - initialBalance;
            assert.equal(difference, ticketPrice, "Difference should be what was sent");

            // Now try to issue refund as second user - should fail
            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[1]});
        }).then(
          function() {  
            var balance = web3.eth.getBalance(conference.address);
            assert.equal(balance, ticketPrice, "Balance should be unchanged");
            // Now try to issue refund as organizer/owner
            return conference.refundTicket(accounts[1], ticketPrice, {from: accounts[0]});
        }).then(
          function() {
            var postRefundBalance = web3.eth.getBalance(conference.address).toNumber();
            assert.equal(postRefundBalance, initialBalance, "Balance should be initial balance");
            done();
        }).catch(done);
      }).catch(done);
    });

});			

```

## 第 15 章 Truffle v4.1.8 开发框架

Truffle 是 solidity 开发框架， [`truffleframework.com`](http://truffleframework.com)

## 1. 安装 Truffle

安装 truffle

```

sudo npm install -g truffle

```

升级

```

npm update -g truffle		

```

## 2. 开发环境

### 2.1. truffle develop

truffle develop 是 truffle 自带的开发环境。

### 2.2. Ganache

truffle develop 使用起来并不直观，还有另一个开发环境是 Ganache，Ganache 有命令行版本和图形界面版本。下面是命令行版本安装方法：

```

sudo npm install -g ganache-cli

```

图形界面版本这里下载 [`truffleframework.com/ganache/`](http://truffleframework.com/ganache/)

图形界面交互性相比命令行比较好，推荐使用。你能在界面上直接查看账号，区块，交易，日志等等。

### 2.3. testrpc

由于 truffle 4.0 自带开发环境(truffle develop)，所以本章不在使用 testrpc(不建议使用)，如果仍需要 testrpc 请参考下面安装方法：

```

# 安装 testrpc
sudo npm install -g ethereumjs-testrpc

```

## 3. Truffle 快速入门

### 3.1. Ubuntu 环境

#### 3.1.1. 启动开发环境

truffle 自带一个开发环境

```

neo@netkiller ~/ethereum/truffle-project %  truffle develop
Truffle Develop started at http://localhost:9545/

Accounts:
(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57
(1) 0xf17f52151ebef6c7334fad080c5704d77216b732
(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef
(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544
(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2
(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e
(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5
(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5
(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc
(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de

Private Keys:
(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3
(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f
(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1
(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c
(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418
(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63
(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8
(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7
(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4
(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5

Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat

truffle(develop)> 

```

truffle develop 的作用于 testrpc 类似。

```

neo@netkiller ~/ethereum/truffle-project % testrpc 
EthereumJS TestRPC v6.0.3 (ganache-core: 2.0.2)

Available Accounts
==================
(0) 0xb5fd43ee8fa5ce1db9a30a25ba385ee3bfc72966
(1) 0xf5a732345734e1f0f49cbadb145a20d1e1a44b95
(2) 0x834fcd8c55fdf21fd14c82e9a1ef5d3636a2fed6
(3) 0x5aa4d047d85727309d3ca653c83c3bb0ecd18903
(4) 0xb4db2dede86f4539e56ac4438f6e36f09c307e46
(5) 0x8da382b1a10ab2f1dc149e19fda228a07c78935c
(6) 0xb290297e89b52713548ff93e5fc23bc3c4183dde
(7) 0x546183289bd4d9d33a3aee0ee663c0729926e583
(8) 0xca58321e442533b7f827e6e8976e1905acd15214
(9) 0xe2c0b336bbb03564204e15a2cb7744564a53efcc

Private Keys
==================
(0) ff32f7a06e2fb26b51a745c1e428c60df92c0f9bb3301b19a5b7e0cdfaae521a
(1) cdbfe40321b6ade8a246748df1c48a738b8a531aee4d1f60a45bfd7f941e0064
(2) 7092117c2d7832980945e18645a60a1ed0e59261d040749f8b5202c2fc653d74
(3) f329657c9ad808e9f794a7462a1a9c276266343d5ced263ab618b6a19d6857c1
(4) 1221766592618add3a57ab109f00efcc70867dd8a9b10a0f7ea75c2b619edfc3
(5) c27005d6c3581193124c84766cc0b1cc318cb201b7d00b1035f4a4c7767ba790
(6) 6b7f43dca1dcc00203b751191096bb0602e17a9a94dcee8b846329efa703cea9
(7) 41be5971d71935bc88c3cf8aefd78ed3188c8721b7134cda3b25d353faf05d4f
(8) bd4c9d512a4f2da2cdcd9e4f89c049e3e7ac81bf57a05369997c2f13e793bebb
(9) 04196d803f743cc1fd021e7d02d5a552f14ab9826ccd4d4b265ff96c45169d2c

HD Wallet
==================
Mnemonic:      confirm shift cable melody caught swing erode language spend victory conduct van
Base HD Path:  m/44'/60'/0'/0/{account_index}

Listening on localhost:8545			

```

#### 3.1.2. 创建项目

```

cd ~/ethereum
mkdir truffle-project
cd truffle-project 
truffle init			

```

操作演示

```

neo@netkiller ~/ethereum/truffle-project % truffle init
Downloading...
Unpacking...
Setting up...
Unbox successful. Sweet!

Commands:

  Compile:        truffle compile
  Migrate:        truffle migrate
  Test contracts: truffle test

neo@netkiller ~/ethereum/truffle-project % tree 
.
|-- contracts
|   `-- Migrations.sol
|-- migrations
|   `-- 1_initial_migration.js
|-- test
|-- truffle-config.js
`-- truffle.js

3 directories, 4 files			

```

目录结构简单说明如下：

contract/ - Truffle 默认的合约文件存放地址。
migrations/ - 存放发布脚本文件
test/ - 用来测试应用和合约的测试文件
truffle.js - Truffle 的配置文件

app/ - 需要用户创建，应用文件运行的默认目录。

#### 3.1.3. 创建合约

```

pragma solidity ⁰.4.18;

contract Netkiller {
    string name;
    int num;
    function Netkiller() public{
        name = "default";
        num = 1;
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
    function setNum(int n) public{
        num = n;
    }
    function addNum(int m) public view returns(int res){
        res = m + num;
    }
}

```

```

neo@netkiller ~/ethereum/truffle-project % vim migrations/2_initial_migration.js

var Netkiller = artifacts.require("./Netkiller.sol");

module.exports = function(deployer) {
  deployer.deploy(Netkiller);
};

```

#### 3.1.4. 配置 Truffle

打开文件 truffle.js

```

module.exports = {
  // See <http://truffleframework.com/docs/advanced/configuration>
  // to customize your Truffle configuration!
};			

```

修改为

```

module.exports = {
  // See <http://truffleframework.com/docs/advanced/configuration>
  // to customize your Truffle configuration!

  networks: {
    development: {
      host: "localhost",
      port: 9545,
      network_id: "*" // Match any network id
    }
  }	

};	

```

#### 3.1.5. 编译智能合约

```

neo@netkiller ~/ethereum/truffle-project % truffle compile
Compiling ./contracts/Migrations.sol...
Compiling ./contracts/Netkiller.sol...
Writing artifacts to ./build/contracts

```

truffle 默认只会编译最后一次修改过的合约文件, 这是为了减少比重复编译。"--all"选项,可以强制编译所有文件。

编译结果

```

neo@netkiller ~/ethereum/truffle-project % find build 
build
build/contracts
build/contracts/Migrations.json
build/contracts/Netkiller.json

```

#### 3.1.6. migrate

```

neo@netkiller ~/ethereum/truffle-project % truffle migrate      
Using network 'development'.

Network up to date.			

```

### 3.2. Mac 环境

Mac 环境

```

neo@MacBook-Pro ~/ethereum/truffle % node --version
v9.5.0

neo@MacBook-Pro ~/ethereum/truffle % npm version
{ npm: '5.6.0',
  ares: '1.13.0',
  cldr: '32.0.1',
  http_parser: '2.7.0',
  icu: '60.2',
  modules: '59',
  napi: '2',
  nghttp2: '1.29.0',
  node: '9.5.0',
  openssl: '1.0.2n',
  tz: '2017c',
  unicode: '10.0',
  uv: '1.19.1',
  v8: '6.2.414.46-node.18',
  zlib: '1.2.11' }		

neo@MacBook-Pro ~/ethereum/truffle % truffle version
Truffle v4.0.6 (core: 4.0.6)
Solidity v0.4.19 (solc-js)		

```

创建项目并初始化

```

mkdir -p ~/ethereum/truffle
cd 	ethereum/truffle
truffle init	

```

truffle 自带一个开发环境

```

neo@netkiller ~/ethereum/truffle-project %  truffle develop
Truffle Develop started at http://localhost:9545/

Accounts:
(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57
(1) 0xf17f52151ebef6c7334fad080c5704d77216b732
(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef
(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544
(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2
(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e
(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5
(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5
(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc
(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de

Private Keys:
(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3
(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f
(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1
(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c
(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418
(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63
(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8
(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7
(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4
(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5

Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat

truffle(develop)> 

```

创建合约文件 contracts/Greeter.sol

```

pragma solidity ⁰.4.20;

contract Greeter         
{
    address creator;     
    string greeting;     

    function Greeter() public   
    {
        creator = msg.sender;
        greeting = "default";
    }

    function greet() constant public returns (string)          
    {
        return greeting;
    }

    function setGreeting(string _newgreeting) public 
    {
        greeting = _newgreeting;
    }

    function kill() public
    { 
        if (msg.sender == creator)
            selfdestruct(creator);

    }

}		

```

创建部署文件 migrations/2_initial_migration.js

```

var Greeter = artifacts.require("./Greeter.sol");

module.exports = function(deployer) {
  deployer.deploy(Greeter);
};

```

打开文件 truffle.js

```

module.exports = {
  // See <http://truffleframework.com/docs/advanced/configuration>
  // to customize your Truffle configuration!
};			

```

修改为

```

module.exports = {
  // See <http://truffleframework.com/docs/advanced/configuration>
  // to customize your Truffle configuration!

  networks: {
    development: {
      host: "localhost",
      port: 9545,
      network_id: "*" // Match any network id
    }
  }	

};	

```

编译并部署合约

```

neo@MacBook-Pro ~/ethereum/truffle % truffle compile          
Compiling ./contracts/Greeter.sol...
Writing artifacts to ./build/contracts

neo@MacBook-Pro ~/ethereum/truffle % truffle migrate --reset     
Using network 'development'.

Running migration: 1_initial_migration.js
  Replacing Migrations...
  ... 0xddeac9a1c57772df50064f11227fcb5515e54a3e88e15843f5c0bc1b55a0dad7
  Migrations: 0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4
Saving successful migration to network...
  ... 0x9b51540f5a7d75a8fc920e3e5e4ec66792ba31fd006bd176901f0e6347af2dba
Saving artifacts...
Running migration: 2_initial_migration.js
  Deploying Greeter...
  ... 0x312ead931bbe4b288315317bdf6735ba4fe4f30c20382f085ca27be345819983
  Greeter: 0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6
Saving successful migration to network...
  ... 0x69eaa7ed49cc72426706d54c4f52ba70b742ed6910f1223eb0df5f250b4b8ec3
Saving artifacts...

```

测试脚本

```

Greeter.deployed().then(instance => console.log(instance.address))

var contract;
Greeter.deployed().then(function(instance){contract= instance;});
contract.greet();
contract.setGreeting("http://www.netkiller.cn")
contract.greet();		

```

进入控制台，交互执行上面程序

```

neo@MacBook-Pro ~/ethereum/truffle % truffle console
truffle(development)>

truffle(development)> Greeter.deployed().then(instance => console.log(instance.address))
0x82d50ad3c1091866e258fd0f1a7cc9674609d254
undefined
truffle(development)> var contract;
undefined
truffle(development)> Greeter.deployed().then(function(instance){contract= instance;});
undefined
truffle(development)> contract.greet();
'default'
truffle(development)> contract.setGreeting("http://www.netkiller.cn")
{ tx: '0xa5cbfba78c84415517740a482c2bf2208da0c6b0ecabcd5c22db2c85749041c8',
  receipt: 
   { transactionHash: '0xa5cbfba78c84415517740a482c2bf2208da0c6b0ecabcd5c22db2c85749041c8',
     transactionIndex: 0,
     blockHash: '0x557758e0d9b1ef81f41728cb92f43041d009751d5ce5e2e4424f7fb90f52041a',
     blockNumber: 16,
     gasUsed: 34206,
     cumulativeGasUsed: 34206,
     contractAddress: null,
     logs: [],
     status: 1 },
  logs: [] }
truffle(development)> contract.greet();
'http://www.netkiller.cn'

```

### 3.3. ERC20 代币部署

#### 3.3.1. 合约文件

```

[ethereum@netkiller truffle]$ cat contracts/TokenERC20.sol
pragma solidity ⁰.4.20;

contract TokenERC20 {
    address public owner;
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);

    mapping (address => bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        owner = msg.sender;

        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(!frozenAccount[msg.sender]);
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function approveAndCall(address _spender, uint256 _value)
        public
        returns (bool success) {
        if (approve(_spender, _value)) {
            return true;
        }
    }

    function burn(uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        return true;
    }

    function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        return true;
    }

  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));
    transfer(_to, _value);
    require(_to.call(_data));
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {
    require(_to != address(this));
    transferFrom(_from, _to, _value);
    require(_to.call(_data));
    return true;
  }

  function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {
    require(_spender != address(this));
    approve(_spender, _value);
    require(_spender.call(_data));
    return true;
  }

    function transferOwnership(address _owner) onlyOwner public {
        owner = _owner;
    }
    function mintToken(address target, uint256 mintedAmount) public onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
    }

    function freezeAccount(address target, bool freeze) public onlyOwner {
        frozenAccount[target] = freeze;
    }
}

```

#### 3.3.2. 部署文件

```

[ethereum@netkiller truffle]$ cat migrations/2_initial_token.js
var TokenERC20 = artifacts.require("./TokenERC20.sol");

module.exports = function(deployer) {
  deployer.deploy(TokenERC20,1200000000,"Netkiller Coin","NKC");
};

```

#### 3.3.3. 编译部署

```

[ethereum@netkiller truffle]$ truffle compile
Compiling ./contracts/Migrations.sol...
Compiling ./contracts/TokenERC20.sol...
Writing artifacts to ./build/contracts

[ethereum@netkiller truffle]$ truffle migrate
Using network 'development'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x80746c040d6c6ed8178f90d74356a994fea81516bdd6579d003c433d7a0a0116
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_initial_token.js
  Deploying TokenERC20...
  ... 0xb375b52fe6df9f298828672f3ba3560d7a6f6806ce344e964439d0febc13cb97
  TokenERC20: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

```

#### 3.3.4. 合约调用

```

[ethereum@netkiller truffle]$ truffle console
truffle(development)> var contract;
undefined
truffle(development)> TokenERC20.deployed().then(function(instance){contract=instance;});
undefined
truffle(development)> contract.symbol.call().then(console.log);
NKC
truffle(development)> contract.name.call().then(console.log);
Netkiller Coin

```

### 3.4. 高级 ERC20 代币合约

#### 3.4.1. 部署合约

解锁账号，查看 gas limit 价格

```

[ethereum@netkiller ~]$ geth attach
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.7-stable/linux-amd64/go1.10.2
coinbase: 0x8232ef29d29f46d3621350ab7097604247ed4830
at block: 2863 (Fri, 11 May 2018 17:16:01 CST)
 datadir: /home/ethereum/.ethereum
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> personal.unlockAccount(eth.accounts[0],"12345678",50000)
true
> web3.eth.getBlock("pending").gasLimit
4712388
> exit

```

配置 truffle.js

```

[ethereum@netkiller truffle]$ cat truffle.js
module.exports = {
  // See <http://truffleframework.com/docs/advanced/configuration>
  // to customize your Truffle configuration!

  networks: {
    development: {
      host: "localhost",
      port: 8545,
	  gas: 4712388,
      network_id: "*" // Match any network id
    }
  }

};

```

```

[ethereum@netkiller truffle]$ truffle compile
(node:23256) ExperimentalWarning: The fs.promises API is experimental
Compiling ./contracts/NetkillerAdvancedToken.sol...
Writing artifacts to ./build/contracts

```

```

[ethereum@netkiller truffle]$ truffle migrate
(node:23456) ExperimentalWarning: The fs.promises API is experimental
Using network 'development'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xa5937808d9d42dba231738d79d5989e160a2bbc02aa7e8938d0ee71a11eab9a7
  Migrations: 0x0f6d790c0ce6453161ead810246602c601f836e7
Saving successful migration to network...
  ... 0xabd2d76488caa48eac5b9ad5d662b34a8b41acacb5657ff4f78c5c4530913d2b
Saving artifacts...
Running migration: 2_initial_token.js
  Deploying NetkillerAdvancedToken...
  ... 0x190239e85c54aa407ba8dd98357ebabbe2dcab65811f3c4aab7486af27436a09
  NetkillerAdvancedToken: 0xb45bd60c48ea18991a5f25a644682d8cf7572ccf
Saving successful migration to network...
  ... 0x97b9fffef368b2411341d9fed31bd771d0beebe02bde8c19c61a9e0dde0cc773
Saving artifacts...

```

#### 3.4.2. 控制台检查合约

```

var contract;
NetkillerAdvancedTokenAirDrop.deployed().then(function(instance){contract=instance;});
contract.symbol.call().then(console.log);
contract.name.call().then(console.log);
contract.totalSupply.call().then(console.log);
contract.balanceOf.call(web3.eth.accounts[0]).then(console.log);

```

#### 3.4.3. 测试转账

```

contract.transfer(web3.eth.accounts[1],100).then(function(){contract.balanceOf.call(web3.eth.accounts[1]).then(console.log);});

```

```

contract.transferFrom(web3.eth.accounts[0],web3.eth.accounts[1],100).then(function(){contract.balanceOf.call(web3.eth.accounts[1]).then(console.log);});

```

#### 3.4.4. 锁仓

```

contract.setLock(true);
contract.transfer(web3.eth.accounts[2],100).then(function(){contract.balanceOf.call(web3.eth.accounts[2]).then(console.log);});

```

演示

```

truffle(development)> contract.setLock(true);
{ tx: '0x6a603ca9456b574224aa97b8bf1d66280fc8509c94253c0037bc5bb71135a667',
  receipt: 
   { transactionHash: '0x6a603ca9456b574224aa97b8bf1d66280fc8509c94253c0037bc5bb71135a667',
     transactionIndex: 0,
     blockHash: '0x4e0893b5ff6b1d85182dca0ceb3c0c2cb750183ff856b7ad2e323ad2a3b55fdc',
     blockNumber: 13,
     gasUsed: 42424,
     cumulativeGasUsed: 42424,
     contractAddress: null,
     logs: [],
     status: 1 },
  logs: [] }
truffle(development)> contract.transfer(web3.eth.accounts[2],100).then(function(){contract.balanceOf.call(web3.eth.accounts[2]).then(console.log);});
Error: VM Exception while processing transaction: revert
    at XMLHttpRequest._onHttpResponseEnd (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:509:1)
    at XMLHttpRequest._setReadyState (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:354:1)
    at XMLHttpRequestEventTarget.dispatchEvent (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:64:1)
    at XMLHttpRequest.request.onreadystatechange (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/httpprovider.js:128:1)
    at /usr/local/lib/node_modules/truffle/build/webpack:/~/truffle-provider/wrapper.js:134:1
    at /usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/requestmanager.js:86:1
    at Object.InvalidResponse (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1)

```

解锁后再测试

```

contract.setLock(false);
contract.transfer(web3.eth.accounts[2],100).then(function(){contract.balanceOf.call(web3.eth.accounts[2]).then(console.log);});

```

```

truffle(development)> contract.setLock(false);
{ tx: '0x3d4b8d49626c1171ab7160274a9f573bb06999fa7bc33240704199c7905f62fd',
  receipt: 
   { transactionHash: '0x3d4b8d49626c1171ab7160274a9f573bb06999fa7bc33240704199c7905f62fd',
     transactionIndex: 0,
     blockHash: '0x0c78b27d817449b6a3727a13041f1880cbf5466a8b81719f2541c08d59ca5fb3',
     blockNumber: 15,
     gasUsed: 13680,
     cumulativeGasUsed: 13680,
     contractAddress: null,
     logs: [],
     status: 1 },
  logs: [] }
truffle(development)> contract.transfer(web3.eth.accounts[2],100).then(function(){contract.balanceOf.call(web3.eth.accounts[2]).then(console.log);});
undefined
truffle(development)> BigNumber { s: 1, e: 2, c: [ 100 ] }

```

#### 3.4.5. 测试空投

```

[ethereum@netkiller ~]$ geth account new
INFO [05-11|17:25:49] Maximum peer count                       ETH=25 LES=0 total=25
Your new account is locked with a password. Please give a password. Do not forget this password.
Passphrase:
Repeat passphrase:
Address: {3c1ba8b80b9a8697f2e34194c2a73a93105be23d}

```

```

contract.mintAirdropToken(1000000);
contract.totalAirdropSupply.call().then(console.log);
contract.totalSupply.call().then(console.log);
contract.setAirdrop(10);
contract.setAirdropLock(true);
contract.balanceOf.call(web3.eth.accounts[3]).then(console.log);

contract.currentTotalAirdrop.call().then(console.log);

```

操作演示

```

[ethereum@netkiller ~]$  truffle console      
truffle(development)> var contract;
NetkillerAdvancedTokenAirDrop.deployed().then(function(instance){contract=instance;});undefined
truffle(development)> NetkillerAdvancedTokenAirDrop.deployed().then(function(instance){contract=instance;});
undefined
truffle(development)> contract.mintAirdropToken(1000000);
{ tx: '0xab251fafc30724273259442fc02bfa429235ff14535f4fb25e29bed7de09ea11',
  receipt: 
   { transactionHash: '0xab251fafc30724273259442fc02bfa429235ff14535f4fb25e29bed7de09ea11',
     transactionIndex: 0,
     blockHash: '0x5498eb579a08e8da1ca2d5ad3d6dd5b0a5c21cc9a630809783d09b65e26929b9',
     blockNumber: 28,
     gasUsed: 47701,
     cumulativeGasUsed: 47701,
     contractAddress: null,
     logs: [],
     status: 1 },
  logs: [] }
truffle(development)> contract.setAirdrop(10);
{ tx: '0xd8a3a16328373858e3cc30c7947b3c3c00db447bb3306f2cf2af58fd0215aef8',
  receipt: 
   { transactionHash: '0xd8a3a16328373858e3cc30c7947b3c3c00db447bb3306f2cf2af58fd0215aef8',
     transactionIndex: 0,
     blockHash: '0x5be96cfd95031a132fc643b06d01dba0b14f736fa9fa3f16dd5bbd9c7f030700',
     blockNumber: 29,
     gasUsed: 42209,
     cumulativeGasUsed: 42209,
     contractAddress: null,
     logs: [],
     status: 1 },
  logs: [] }
truffle(development)> contract.setAirdropLock(true);
{ tx: '0x7b8b5747a64111a500cce22371d78b2c3c4ce0b5a2b585b26c0278876044e231',
  receipt: 
   { transactionHash: '0x7b8b5747a64111a500cce22371d78b2c3c4ce0b5a2b585b26c0278876044e231',
     transactionIndex: 0,
     blockHash: '0xd6960add791b36afac1126a00af16f2833043dcb3416d68bb4056db64313dc93',
     blockNumber: 30,
     gasUsed: 42408,
     cumulativeGasUsed: 42408,
     contractAddress: null,
     logs: [],
     status: 1 },
  logs: [] }
truffle(development)> contract.balanceOf.call(web3.eth.accounts[5]).then(console.log);
BigNumber { s: 1, e: 1, c: [ 10 ] }
undefined				

```

## 4. Truffle 命令详解

neo@MacBook-Pro ~/ethereum/truffle % truffle help
Truffle v4.0.6 - a development framework for Ethereum

Usage: truffle <command> [options]

Commands:
  init      Initialize new and empty Ethereum project
  compile   Compile contract source files
  migrate   Run migrations to deploy contracts
  deploy    (alias for migrate)
  build     Execute build pipeline (if configuration present)
  test      Run JavaScript and Solidity tests
  debug     Interactively debug any transaction on the blockchain (experimental)
  opcode    Print the compiled opcodes for a given contract
  console   Run a console with contract abstractions and commands available
  develop   Open a console with a local development blockchain
  create    Helper to create new contracts, migrations and tests
  install   Install a package from the Ethereum Package Registry
  publish   Publish a package to the Ethereum Package Registry
  networks  Show addresses for deployed contracts on each network
  watch     Watch filesystem for changes and rebuild the project automatically
  serve     Serve the build directory on localhost and watch for changes
  exec      Execute a JS module within this Truffle environment
  unbox     Download a Truffle Box, a pre-built Truffle project
  version   Show version number and exit

See more at http://truffleframework.com/docs

### 4.1. version

输出版本号然后退出。

```

neo@MacBook-Pro ~/ethereum/truffle % truffle version
Truffle v4.0.6 (core: 4.0.6)
Solidity v0.4.19 (solc-js)

```

### 4.2. Truffle console 控制台

```

neo@MacBook-Pro ~/ethereum/truffle % truffle console
truffle(development)>		

```

### 4.3. create

#### 4.3.1. contract 创建合约

```

neo@MacBook-Pro ~/ethereum/truffle % truffle create contract MyContract
neo@MacBook-Pro ~/ethereum/truffle % cat contracts/MyContract.sol 
pragma solidity ⁰.4.4;

contract MyContract {
  function MyContract() {
    // constructor
  }
}				

```

#### 4.3.2. test 创建单元测试

```

neo@MacBook-Pro ~/ethereum/truffle % truffle create test MyTest
neo@MacBook-Pro ~/ethereum/truffle % cat test/my_test.js
contract('MyTest', function(accounts) {
  it("should assert true", function(done) {
    var my_test = MyTest.deployed();
    assert.isTrue(true);
    done();
  });
});

```

### 4.4. migrate

```

% truffle migrate --reset			

```

### 4.5. compile

```

% truffle compile --all

```

### 4.6. test

运行测试

```

neo@MacBook-Pro ~/ethereum/truffle % truffle test          
Using network 'development'.

  Contract: Migrations
    1) should assert true
    > No events were emitted

  0 passing (31ms)
  1 failing

  1) Contract: Migrations should assert true:
     ReferenceError: Migrations is not defined
      at Context.<anonymous> (test/migrations.js:3:22)

```

运行单个测试文件

```

neo@MacBook-Pro ~/ethereum/truffle % truffle test test/migrations.js			

```

### 4.7. watch

启动后监控文件系统的边龙并自动构建项目。

```

truffle watch			

```

## 5. 合约开发

### 5.1. 构造方法

在 Truffer 中部署构造方法需要参数传递例子如下，MyContract 需要传递参数 _name：

```

pragma solidity ⁰.4.19;

contract MyContract {

    string name;

    function MyContract(string _name) public{
        name = _name;
    }

    function getName() public view returns (string) {
        return name;
    }
}

```

migrations/3_initial_migration.js

```

var MyContract = artifacts.require("./MyContract.sol");

module.exports = function(deployer) {
  deployer.deploy(MyContract,"Netkiller");
};			

```

给构造方法传递变量的方法是 deployer.deploy(MyContract,arg1, arg2, ...); arg1 是传递的参数。

多个合约传递方法是：

```

deployer.deploy([
  [ContractA, arg1, arg2, ...],
  ContractB,
  [ContractC, arg1]
]);			

```

## 6. truffle console

### 6.1. 获取账号列表

```

truffle(development)> web3.eth.accounts
[ '0x8232ef29d29f46d3621350ab7097604247ed4830',
  '0x3c1ba8b80b9a8697f2e34194c2a73a93105be23d' ]

truffle(development)> web3.eth.getAccounts(function(err,res) { accounts = res; });
undefined
truffle(development)> accounts[0]
'0x8232ef29d29f46d3621350ab7097604247ed4830'

```

### 6.2. 余额

```

truffle(development)> web3.eth.getBalance(web3.eth.accounts[0])
BigNumber { s: 1, e: 22, c: [ 206250000 ] }

```

### 6.3. 实例化合约

```

var contract;
Conference.deployed().then(function(instance){contract=instance;});

```

### 6.4. 访问 public 变量

```

truffle(development)> contract.quota.call().then(console.log);
BigNumber { s: 1, e: 1, c: [ 50 ] }
undefined			

```

### 6.5. 调用 public 函数

```

var contract;
Conference.deployed().then(function(instance){contract=instance;});
contract.buyTicket();

```

函数参数 call(param1, param2 ......)

```

truffle(development)> contract.balanceOf.call(web3.eth.accounts[0]).then(console.log);
BigNumber { s: 1, e: 27, c: [ 12000000000000 ] }
undefined

```

## 7. 测试

### 7.1. balanceOf

```

it("should return the balance of token owner", function() {
  var token;
  return Token.deployed().then(function(instance){
    token = instance;
    return token.balanceOf.call(accounts[0]);
  }).then(function(result){
    assert.equal(result.toNumber(), 1000000, 'balance is wrong');
  })
});

```

### 7.2. transfer

```

it("should transfer right token", function() {
  var token;
  return Token.deployed().then(function(instance){
    token = instance;
    return token.transfer(accounts[1], 500000);
  }).then(function(){
    return token.balanceOf.call(accounts[0]);
  }).then(function(result){
    assert.equal(result.toNumber(), 500000, 'accounts[0] balance is wrong');
    return token.balanceOf.call(accounts[1]);
  }).then(function(result){
    assert.equal(result.toNumber(), 500000, 'accounts[1] balance is wrong');
  })
});			

```

transferFrom

```

it("should give accounts[1] authority to spend account[0]'s token", function() {
  var token;
  return Token.deployed().then(function(instance){
   token = instance;
   return token.approve(accounts[1], 200000);
  }).then(function(){
   return token.allowance.call(accounts[0], accounts[1]);
  }).then(function(result){
   assert.equal(result.toNumber(), 200000, 'allowance is wrong');
   return token.transferFrom(accounts[0], accounts[2], 200000, {from: accounts[1]});
  }).then(function(){
   return token.balanceOf.call(accounts[0]);
  }).then(function(result){
   assert.equal(result.toNumber(), 300000, 'accounts[0] balance is wrong');
   return token.balanceOf.call(accounts[1]);
  }).then(function(result){
   assert.equal(result.toNumber(), 500000, 'accounts[1] balance is wrong');
   return token.balanceOf.call(accounts[2]);
  }).then(function(result){
   assert.equal(result.toNumber(), 200000, 'accounts[2] balance is wrong');
  })
});

```

Transfer Event

```

it("should show the transfer event", function() {
  var token;
  return Token.deployed().then(function(instance){
    token = instance;
    return token.transfer(accounts[1], 100000);
  }).then(function(result){
    console.log(result.logs[0].event)
  })
});

```

## 8. TRUFFLE BOXES

Truffle Boxes [`truffleframework.com/boxes/`](http://truffleframework.com/boxes/) 是一些有用的实例，学习 truffle 开发是供开发者参考学习。

使用下面命令下载例子

```

truffle unbox webpack

```

## 9. Zeppelin Solidity - OpenZeppelin is a library for writing secure Smart Contracts on Ethereum.

OpenZeppelin is an open framework of reusable and secure smart contracts in the Solidity language.

网站： [`openzeppelin.org`](https://openzeppelin.org)

Github: [`github.com/OpenZeppelin/zeppelin-solidity`](https://github.com/OpenZeppelin/zeppelin-solidity)

### 9.1. ERC20

```

pragma solidity ⁰.4.19;
import "zeppelin-solidity/contracts/token/StandardToken.sol";

contract NeoCoin is StandardToken {
  string public name = "NeoCoin";
  string public symbol = "BLC";
  uint8 public decimals = 4;
  uint256 public INITIAL_SUPPLY = 666666;
  function NeoCoin() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}			

```

### 9.2. ERC872

创建项目目录

```

neo@MacBook-Pro ~/ethereum/truffle % mkdir TokenERC827
neo@MacBook-Pro ~/ethereum/truffle % cd TokenERC827 
neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % truffle init
Downloading...
Unpacking...
Setting up...
Unbox successful. Sweet!

Commands:

  Compile:        truffle compile
  Migrate:        truffle migrate
  Test contracts: truffle test

```

安装 zeppelin-solidity

```

neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % npm init -y
Wrote to /Users/neo/ethereum/truffle/TokenERC827/package.json:

{
  "name": "TokenERC827",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}

neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % npm install -E zeppelin-solidity
npm notice created a lockfile as package-lock.json. You should commit this file.
npm WARN TokenERC827@1.0.0 No description
npm WARN TokenERC827@1.0.0 No repository field.

+ zeppelin-solidity@1.7.0
added 8 packages in 2.591s

   ╭─────────────────────────────────────╮
   │                                     │
   │   Update available 5.6.0 → 5.7.1    │
   │       Run npm i npm to update       │
   │                                     │
   ╰─────────────────────────────────────╯			

```

合约被安装在 node_modules/zeppelin-solidity/contracts 目录

创建合约和测试文件

```

neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % truffle create contract TokenERC827
neo@MacBook-Pro ~/ethereum/truffle/TokenERC827 % truffle create test TokenERC827

```

编辑合约文件

```

pragma solidity ⁰.4.19;

import "zeppelin-solidity/contracts/token/ERC827/ERC827Token.sol";

contract TokenERC827 is ERC827Token {

  string public name = "NetkillerCoin";
  string public symbol = "NKC";
  uint8 public decimals = 4;
  uint256 public INITIAL_SUPPLY = 1000000;

  function TokenERC827() public {
    // constructor
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}

```

## 第 16 章 web3.js - 1.0.0

注意本章采用 web3.js v1.0.0 版本，这个版本仍在 beta 阶段，还没有 release。

你看到网上很多实例，安照例子的步骤操作，发现无法成功，很可能跟版本有关。v1.0.0 与之前的版本还是有很大差异，所以选择版本很重要。因为 v1.0.0 很快就会 release 所以本章不会在用早起版本举例。

| ![](img/devel.png) |

## 1. 开发环境

```

npm init
npm install web3 --save
npm install solc

```

### 1.1. Ropsten 测试网

```

geth --testnet --syncmode light --cache 1024 --ipcpath /Users/neo/Library/Ethereum/geth.ipc

```

Ropsten 测试网上转账的例子

```

fs = require('fs');
var net = require('net');
var Web3 = require('web3');
var web3 = new Web3('/Users/neo/Library/Ethereum/geth.ipc', net);

console.log(web3.version)
const abi = fs.readFileSync('output/TokenERC20.abi', 'utf-8');

const contractAddress = "0x70682386d0dE84B1e549DC3c4305CCB2D261b2a8";
const coinbase = "0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7";
const toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";

balanceWei = web3.eth.getBalance(coinbase);
console.log(balanceWei);

const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});

web3.eth.personal.unlockAccount(coinbase, "netkiller").then(function(result){
	console.log(result)
	contract.methods.balanceOf(coinbase).call().then(console.log).catch(console.error);
	contract.methods.balanceOf(toAddress).call().then(console.log).catch(console.error);
});

contract.methods.transfer(toAddress, 10000).send().then(function(receipt){

	console.log(receipt);

}).catch(console.error);

contract.methods.balanceOf(coinbase).call().then(console.log).catch(console.error);
contract.methods.balanceOf(toAddress).call().then(console.log).catch(console.error);			

```

## 2. truffle-contract

```

neo@MacBook-Pro ~/ethereum/web3 % npm install truffle-contract		

```

## 3. 连接到以太坊客户端

### 3.1. http 方式

```

var Web3 = require('web3');
var web3 = new Web3('http://localhost:8545');

```

查看连接状态

```

> web3.currentProvider
HttpProvider {
  host: 'http://localhost:8545',
  timeout: 0,
  connected: true,
  headers: undefined }			

```

connected: true 表示连接成功。

### 3.2. WebSocket 方式

```

var Web3 = require('web3');
var web3 = new Web3(Web3.givenProvider || 'ws://remotenode.com:8546');

```

### 3.3. IPC 方式

```

// Using the IPC provider in node.js
var net = require('net');
var Web3 = require('web3');
var web3 = new Web3('/Users/myuser/Library/Ethereum/geth.ipc', net); // mac os path

```

## 4. web3

### 4.1. version 显示 web3 版本号

```

> web3.version
'1.0.0-beta.30'			

```

## 5. web3.eth

### 5.1. 查看账号列表

```

var Web3 = require('web3');
var web3 = new Web3('http://localhost:8545');

web3.eth.getAccounts().then(console.log);		

```

### 5.2. 查询矿工账号

```

var Web3 = require('web3');
var web3 = new Web3('http://localhost:8545');

web3.eth.getCoinbase().then(console.log);			

```

Callback 方式

```

web3.eth.getCoinbase(
    function(error, result){ 
    if (error) {
        console.error(error);
    } else {
        console.log(result); 
    }
 })			

```

### 5.3. 获得余额

```

web3.eth.getBalance(req.query.address).then(function(balance){
      res.json({"status": true, "code":0, "data":{"account":req.query.address, "balance": web3.utils.fromWei(balance)}}); 
});

```

Callback 方式

```

web3.eth.getBalance(req.query.address, function (error, wei) {
    if (!error) {
        var balance = web3.utils.fromWei(wei, 'ether');
        res.json({"status": true, "code":0, "data":{"account":req.query.address, "balance": balance}});
    }else{
        console.log(error);
        res.json({"status": false, "code":1, "data":{"error":error.message}});
    }
});

```

捕捉错误

```

router.get('/balance.json', function(req, res) {

	try {
		web3.eth.getBalance(req.query.address, function (error, wei) {
		    if (!error) {
		        var balance = web3.utils.fromWei(wei, 'ether');
		        res.json({"status": true, "code":0, "data":{"account":req.query.address, "balance": balance}});
		    }else{
		        console.log(error);
		        res.json({"status": false, "code":1, "data":{"error":error.message}})
	       }
		});
	}
	catch(error){
		res.json({"status": false, "code":1, "data":{"error":error.message}});
	};

});				

```

### 5.4. web3.eth.sendTransaction()

```

web3.eth.sendTransaction({
    from: coinbase,
    to: '0x2C687bfF93677D69bd20808a36E4BC2999B4767C',
    value: web3.utils.toWei('2','ether')
},
function(error, result){
    if(!error) {
        console.log("#" + result + "#")
    } else {
        console.error(error);
    }
});

var code = "0x603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3";

web3.eth.sendTransaction({from: coinbase, data: code}, function(err, transactionHash) {
  if (!err)
    console.log(transactionHash); // "0x7f9fade1c0d57a7af66ab4ead7c2eb7b11a91385"
});

web3.eth.sendTransaction({from: coinbase, data: code}).then(function(receipt){
        console.log(receipt);
});			

```

### 5.5. web3.eth.sendSignedTransaction() 私钥签名转账

#### 5.5.1. 例子 1

```

var account = web3.eth.accounts.privateKeyToAccount(privateKey);

web3.eth.accounts.signTransaction({
  from: account.address,
  to: "0x0013a861865d74b13ba94713d4e84d97c57e7081",
  gas: "3000000",
  value: '100000000000000000',
  gasPrice: '0x09184e72a000',
  data: "0x00"
}, account.privateKey)
.then(function(result) {
  console.log("Results: ", result)

  web3.eth.sendSignedTransaction(result.rawTransaction)
    .on('receipt', console.log);
})			

```

#### 5.5.2. 例子 2

获取 pending 状态的区块

```

[ethereum@netkiller web3.example]$ vim test.js
[ethereum@netkiller web3.example]$ export PRIVATE_KEY=585a219fd6a5583b325e96770a88e69660f404efc06e56be71d82beedb7a989e
[ethereum@netkiller web3.example]$ echo $PRIVATE_KEY
585a219fd6a5583b325e96770a88e69660f404efc06e56be71d82beedb7a989e
[ethereum@netkiller web3.example]$ node
> process.env["PRIVATE_KEY"]
'585a219fd6a5583b325e96770a88e69660f404efc06e56be71d82beedb7a989e'

```

```

[ethereum@netkiller web3.example]$ cat transfer.js
fs = require('fs');
const Web3 = require('web3');
var Tx = require('ethereumjs-tx');
const web3 = new Web3('http://localhost:8545');
console.log(web3.version)

coinbase 	= "0xaa96686a050e4916afbe9f6d8c5107062fa646dd";
address 	= "0x372fda02e8a1eca513f2ee5901dc55b8b5dd7411"
contractAddress = "0x9ABcF16f6685fE1F79168534b1D30056c90B8A8A"

const main = async () => {
	var balance = await web3.eth.getBalance(coinbase);
	console.log(`Balance ETH: ${balance} \n`);

	const abi = fs.readFileSync('output/NetkillerToken.abi', 'utf-8');
	const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: address});

	var balance = await contract.methods.balanceOf(address).call();
	console.log(`Balance before send: ${balance} \n`);

	var count = await web3.eth.getTransactionCount(coinbase);
	const gasPrice = await web3.eth.getGasPrice();
	console.log(`gasPrice: ${gasPrice}\n`)
    	var gasLimit = 1000000;
	var transferAmount = 1000;
    // Chain ID of Ropsten Test Net is 3, replace it to 1 for Main Net
    var chainId = 1;

    var rawTransaction = {
        "from": coinbase,
        /* "nonce": "0x" + count.toString(16),*/
        "nonce":  web3.utils.toHex(count),
        "gasPrice": web3.utils.toHex(gasPrice),
        "gasLimit": web3.utils.toHex(gasLimit),
        "to": contractAddress,
        "value": "0x0",
        "data": contract.methods.transfer(address, transferAmount).encodeABI(),
        "chainId": web3.utils.toHex(chainId)
    };

    console.log(`Raw of Transaction: \n${JSON.stringify(rawTransaction, null, '\t')}\n`);

    // The private key for myAddress in .env
    var privateKey = new Buffer(process.env["PRIVATE_KEY"], 'hex');
    var tx = new Tx(rawTransaction);
    tx.sign(privateKey);
    var serializedTx = tx.serialize();

    // Comment out these four lines if you don't really want to send the TX right now
    console.log(`Attempting to send signed tx:  ${serializedTx.toString('hex')}\n`);

    var receipt = await web3.eth.sendSignedTransaction('0x' + serializedTx.toString('hex'));

    // The receipt info of transaction, Uncomment for debug
    console.log(`Receipt info: \n${JSON.stringify(receipt, null, '\t')}\n`);

    // The balance may not be updated yet, but let's check
	var balance = await contract.methods.balanceOf(address).call();
	console.log(`Balance after send: ${balance}`);
}

main();

```

```

[ethereum@netkiller web3.example]$ node test.js
1.0.0-beta.34
Balance ETH: 8695480352861952

Balance before send: 100

gasPrice: 3000000000

Raw of Transaction:
{
	"from": "0xaa96686a050e4916afbe9f6d8c5107062fa646dd",
	"nonce": "0x20",
	"gasPrice": "0xb2d05e00",
	"gasLimit": "0xf4240",
	"to": "0x9ABcF16f6685fE1F79168534b1D30056c90B8A8A",
	"value": "0x0",
	"data": "0xa9059cbb000000000000000000000000372fda02e8a1eca513f2ee5901dc55b8b5dd741100000000000000000000000000000000000000000000000000000000000003e8",
	"chainId": "0x1"
}

Attempting to send signed tx:  f8a92084b2d05e00830f4240949abcf16f6685fe1f79168534b1d30056c90b8a8a80b844a9059cbb000000000000000000000000372fda02e8a1eca513f2ee5901dc55b8b5dd741100000000000000000000000000000000000000000000000000000000000003e825a05017058348d8f751cc40e71c13a63b8d8e21683841bd002c9f6bf691d34b6a4ba07df3fa8792aa66cc272ff89373509f6335272a4298e98177536a79c8ab7c947c

Receipt info:
{
	"blockHash": "0x32f45f27040b1df616ff4efd25557416793782541b995a6d4ecbd66f8441783f",
	"blockNumber": 5518045,
	"contractAddress": null,
	"cumulativeGasUsed": 5054117,
	"from": "0xaa96686a050e4916afbe9f6d8c5107062fa646dd",
	"gasUsed": 36184,
	"logs": [
		{
			"address": "0x9ABcF16f6685fE1F79168534b1D30056c90B8A8A",
			"topics": [
				"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
				"0x000000000000000000000000aa96686a050e4916afbe9f6d8c5107062fa646dd",
				"0x000000000000000000000000372fda02e8a1eca513f2ee5901dc55b8b5dd7411"
			],
			"data": "0x00000000000000000000000000000000000000000000000000000000000003e8",
			"blockNumber": 5518045,
			"transactionHash": "0x203ebcbe1cc8340c4b5a13f4e6c36a4f63142754437e0f43b0ff5e5c0bf512cc",
			"transactionIndex": 104,
			"blockHash": "0x32f45f27040b1df616ff4efd25557416793782541b995a6d4ecbd66f8441783f",
			"logIndex": 94,
			"removed": false,
			"id": "log_7ef3f104"
		}
	],
	"logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000100000000040000000000000000000000000000000008000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000002000000000000000000000000000000001200000000000000000000200000000000000000000000000000100000000000000000000000000000000000",
	"status": true,
	"to": "0x9abcf16f6685fe1f79168534b1d30056c90b8a8a",
	"transactionHash": "0x203ebcbe1cc8340c4b5a13f4e6c36a4f63142754437e0f43b0ff5e5c0bf512cc",
	"transactionIndex": 104
}

Balance after send: 1100

```

### 5.6. web3.eth.getBlock() 获取区块

获取 pending 状态的区块

```

web3.eth.getBlock(
    "pending",
function (error, block) {
    if (error) {
        console.error(error);
    } else {
        console.log(block.transactions.length); 
    }
})			

```

## 6. 账号管理

### 6.1. web3.eth.personal.unlockAccount()

```

var coinbase = "0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7";
//console.log(coinbase)
web3.eth.personal.unlockAccount(coinbase, "your password").then(console.log);

```

## 7. 智能合约

### 7.1. 部署合约

解锁账号

```

> personal.unlockAccount(eth.accounts[0], "netkiller",5000)
true
> miner.stop()
true
> miner.start(2)			

```

编译只能合约

```

solc --bin --abi --optimize -o ./output helloworld.sol		

```

```

var Web3 = require("web3");
var fs = require ('fs');

var web3 = new Web3("http://localhost:8545");

var abi = JSON.parse(fs.readFileSync('output/Netkiller.abi'));
var bin = '0x'+fs.readFileSync('output/Netkiller.bin').toString();

var myContract = new web3.eth.Contract(abi, null, {
    from: '0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7'
});

myContract.deploy({ data: bin }).send({
    from: '0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7',
    gas: 1500000,
    gasPrice: '30000000000000'
}).then(function(newContractInstance){
    console.log(newContractInstance.options.address) 
});			

```

### 7.2. 使用最佳手续费创建合约

```

var fs = require('fs');
var net = require('net');
var Web3 = require("web3");
var fs = require ('fs');

var web3 = new Web3("http://localhost:8545");

var abi = JSON.parse(fs.readFileSync('NetkillerAdvancedToken.abi'));
var bin = '0x'+fs.readFileSync('NetkillerAdvancedToken.bin').toString();
var address = '0x22c57F0537414FD95b9f0f08f1E51d8b96F14029';
var myContract = new web3.eth.Contract(abi, null, {from: address});

var options = { data: bin, arguments: [100000000, 'Netkiller Test Coin', 'NTC', 18] };

web3.eth.getGasPrice().then(function(gasPrice){
    myContract.deploy(options).estimateGas(function(err, gas){
        console.log(gas);
        web3.eth.personal.unlockAccount(req.body.from, req.body.password).then(function(error){
            myContract.deploy(options).send({
                from: address,
                gas: gas,
                gasPrice: gasPrice
            }).then(function(newContractInstance){
                console.log(newContractInstance.options.address) 
            });
        });
    });
});			

```

### 7.3. 调用合约

部署智能合约，你可以使用钱包部署，也可以使用 Truffer 部署，不管你采用什么方式，最终我们需要合约地址。

```

pragma solidity ⁰.4.18;

contract MetaCoin {
	mapping (address => uint) balances;

	event Transfer(address indexed _from, address indexed _to, uint256 _value);

	function MetaCoin() public {
		balances[tx.origin] = 10000;
	}

	function sendCoin(address receiver, uint amount) public returns(bool sufficient) {
		if (balances[msg.sender] < amount) return false;
		balances[msg.sender] -= amount;
		balances[receiver] += amount;
		Transfer(msg.sender, receiver, amount);
		return true;
	}

	function getBalanceInEth(address addr) public view returns(uint){
		return convert(getBalance(addr),2);
	}

	function getBalance(address addr) public view returns(uint) {
		return balances[addr];
	}

	function convert(uint amount,uint conversionRate) public pure returns (uint convertedAmount)
	{
		return amount * conversionRate;
	}

}

```

这里使用 Truffle 部署

```

neo@MacBook-Pro ~/ethereum/truffle % truffle compile --all
Compiling ./contracts/MetaCoin.sol...
Writing artifacts to ./build/contracts

neo@MacBook-Pro ~/ethereum/truffle % truffle migrate --reset
Using network 'development'.

Running migration: 5_initial_migration.js
  Deploying MetaCoin...
  ... 0x9c006b398733a1d8679cbb00493ca75ff063f51c34521ae67a70523deeebf9c4
  MetaCoin: 0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6
Saving successful migration to network...
  ... 0x755a48ef99e488d7cf8460d718773a5afe73f760fb87697e51c40f3e6086f10b
Saving artifacts...

```

得到合约地址 MetaCoin: 0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6

编译合约获得 abi 接口

```

neo@MacBook-Pro ~/ethereum/truffle % solc --bin --abi --optimize -o ./output contracts/MetaCoin.sol 
neo@MacBook-Pro ~/ethereum/truffle % cat output/MetaCoin.abi 
[{"constant":true,"inputs":[{"name":"addr","type":"address"}],"name":"getBalanceInEth","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"receiver","type":"address"},{"name":"amount","type":"uint256"}],"name":"sendCoin","outputs":[{"name":"sufficient","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"amount","type":"uint256"},{"name":"conversionRate","type":"uint256"}],"name":"convert","outputs":[{"name":"convertedAmount","type":"uint256"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[{"name":"addr","type":"address"}],"name":"getBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"}]			

```

```

var Web3 = require("web3");
// 创建 web3 对象
var web3 = new Web3("http://localhost:9545");
// 合约 ABI
var abi = [{"constant":true,"inputs":[{"name":"addr","type":"address"}],"name":"getBalanceInEth","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"receiver","type":"address"},{"name":"amount","type":"uint256"}],"name":"sendCoin","outputs":[{"name":"sufficient","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"amount","type":"uint256"},{"name":"conversionRate","type":"uint256"}],"name":"convert","outputs":[{"name":"convertedAmount","type":"uint256"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[{"name":"addr","type":"address"}],"name":"getBalance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"}];
// 合约地址
var address = "0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6";
var tokenContract = new web3.eth.Contract(abi, address);
// 调用函数
tokenContract.methods.getBalance("0x627306090abab3a6e1400e9345bc60c78a8bef57").call(null,function(error,result){
        console.log("getBalance "+result);
});
tokenContract.methods.getBalanceInEth("0x627306090abab3a6e1400e9345bc60c78a8bef57").call(null,function(error,result){
        console.log("getBalanceInEth "+result);
});	
tokenContract.methods.getBalance("0xf17f52151ebef6c7334fad080c5704d77216b732").call(null,function(error,result){
        console.log("getBalance 2 "+result);
});	
tokenContract.methods.sendCoin("0xf17f52151ebef6c7334fad080c5704d77216b732",387).send({from: '0x627306090abab3a6e1400e9345bc60c78a8bef57'})
.on('transactionHash', function(hash){
}).on('confirmation', function(confirmationNumber, receipt){
}).on('receipt', function(receipt){
    // receipt example
    console.log(receipt); //查询这里可以得到结果
}).on('error', console.error); // If a out of gas error, the second parameter is the receipt.

```

运行结果

```

getBalance 10000
getBalanceInEth 20000
getBalance 2 0
{ transactionHash: '0x0f7514413865219d70873634c00d1b4746c5faa436283786f5414b483b6d6333',
  transactionIndex: 0,
  blockHash: '0x5a7662d14f78b6b4d64b05c0ec1e1e641bd39440467f0476409f4e49c21f287a',
  blockNumber: 11,
  gasUsed: 51024,
  cumulativeGasUsed: 51024,
  contractAddress: null,
  status: 1,
  events: 
   { Transfer: 
      { logIndex: 0,
        transactionIndex: 0,
        transactionHash: '0x0f7514413865219d70873634c00d1b4746c5faa436283786f5414b483b6d6333',
        blockHash: '0x5a7662d14f78b6b4d64b05c0ec1e1e641bd39440467f0476409f4e49c21f287a',
        blockNumber: 11,
        address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
        type: 'mined',
        id: 'log_8b567824',
        returnValues: [Result],
        event: 'Transfer',
        signature: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
        raw: [Object] } } }

```

再次运行

```

getBalance 9613
getBalanceInEth 19226
getBalance 2 387
{ transactionHash: '0x6d33487d9067494288190f7a64b3118c20560479e01afe8d53e37ca46a6001e4',
  transactionIndex: 0,
  blockHash: '0x28f6d416c68dbbd698d1a0b0fdc4ce842694d82318a38ea6395413fd15397642',
  blockNumber: 12,
  gasUsed: 36024,
  cumulativeGasUsed: 36024,
  contractAddress: null,
  status: 1,
  events: 
   { Transfer: 
      { logIndex: 0,
        transactionIndex: 0,
        transactionHash: '0x6d33487d9067494288190f7a64b3118c20560479e01afe8d53e37ca46a6001e4',
        blockHash: '0x28f6d416c68dbbd698d1a0b0fdc4ce842694d82318a38ea6395413fd15397642',
        blockNumber: 12,
        address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
        type: 'mined',
        id: 'log_e5cfee46',
        returnValues: [Result],
        event: 'Transfer',
        signature: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
        raw: [Object] } } }

```

第二次运行会打印出账号 2 的余额

代码优化，由于开发阶段 abi 接口经常变化，从 solc 编译的 abi 文件中直接读取最为方便。

```

const fs = require ('fs');
var Web3 = require("web3");
var web3 = new Web3("http://localhost:9545");
var abi = JSON.parse(fs.readFileSync('MetaCoin.abi'));
var address = "0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6";
var tokenContract = new web3.eth.Contract(abi, address);
tokenContract.methods.getBalance("0x627306090abab3a6e1400e9345bc60c78a8bef57").call(null,function(error,result){
        console.log("getBalance "+result);
});	

```

### 7.4. event

下面以 ERC20 代币为例演示事件如何工作

```

neo@MacBook-Pro ~/ethereum/web3 % cat event.js 

fs = require('fs');
var net = require('net');
var Web3 = require('web3');
var web3 = new Web3('/Users/neo/Library/Ethereum/geth.ipc', net);

console.log(web3.version)
const abi = fs.readFileSync('output/TokenERC20.abi', 'utf-8');

const contractAddress = "0x70682386d0dE84B1e549DC3c4305CCB2D261b2a8";
const coinbase = "0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7";
const toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";

balanceWei = web3.eth.getBalance(coinbase);
console.log(balanceWei);

const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});

contract.events.Transfer({
    fromBlock: 0,
    toBlock:'latest'
}, function(error, event){ console.log(event); })
.on('data', function(event){
    console.log(event); // same results as the optional callback above
})
.on('changed', function(event){
    // remove event from local database
})
.on('error', console.error);

```

运行后程序不会退出，会源源不断的打印出每笔交易

```

neo@MacBook-Pro ~/ethereum/web3 % node event.js 

{ address: '0x70682386d0dE84B1e549DC3c4305CCB2D261b2a8',
  blockNumber: 0,
  transactionHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  transactionIndex: 0,
  blockHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
  logIndex: 0,
  removed: false,
  id: 'log_247b1779',
  returnValues: 
   Result {
     '0': '0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7',
     '1': '0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA',
     '2': '10000000',
     from: '0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7',
     to: '0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA',
     value: '10000000' },
  event: 'Transfer',
  signature: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
  raw: 
   { data: '0x0000000000000000000000000000000000000000000000000000000000989680',
     topics: 
      [ '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
        '0x000000000000000000000000b94054c174995ae2a9e7fcf6c7924635fba8ecf7',
        '0x000000000000000000000000f56b81a2bcb964d2806071e9be4289a5559bb0fa' ] } }

```

## 8. 

### 8.1. 

```

const Web3 = require('web3');

const web3 = new Web3(new Web3.providers.WebsocketProvider('wss://mainnet.infura.io/ws'));

var subscription = web3.eth.subscribe('pendingTransactions', function(error, result){
    if (!error)
        console.log(result);
})
.on("data", function(transaction){
    console.log(transaction);
});

// unsubscribes the subscription
subscription.unsubscribe(function(error, success){
    if(success)
        console.log('Successfully unsubscribed!');
});

```

```

const Web3 = require('web3');

const web3wss = new Web3(new Web3.providers.WebsocketProvider('wss://mainnet.infura.io/ws'));
const web3 = new Web3("https://mainnet.infura.io/CsS9shwaAab0z7B4LP2d");

var subscription = web3wss.eth.subscribe('pendingTransactions', function(error, result){
    if (!error){
        console.log("--------------------" + result +"--------------------");
        var receipt = web3.eth.getTransactionReceipt(result).then(console.log);
     }
})
.on("data", function(transaction){
    console.log(transaction);
});

// unsubscribes the subscription
subscription.unsubscribe(function(error, success){
    if(success)
        console.log('Successfully unsubscribed!');
});

```

### 8.2. 订阅 newBlockHeaders

```

#!/usr/bin/env node
const Web3 = require('web3');

const web3 = new Web3(new Web3.providers.WebsocketProvider('wss://mainnet.infura.io/ws'));

const subscription = web3.eth.subscribe('newBlockHeaders', (error, blockHeader) => {
  if (error) return console.error(error);

  console.log('Successfully subscribed!', blockHeader);
}).on('data', (blockHeader) => {
  console.log('data: ', blockHeader);
});

// unsubscribes the subscription
subscription.unsubscribe((error, success) => {
  if (error) return console.error(error);

  console.log('Successfully unsubscribed!');
});			

```

### 8.3. 订阅 log

```

#!/usr/bin/env node
const Web3 = require('web3');

const web3 = new Web3(new Web3.providers.WebsocketProvider('wss://mainnet.infura.io/ws'));

var subscription = web3.eth.subscribe('logs', {
	fromBlock: 5709426,
    address: '0x7fFdCccC3E7e33C6163393195A947A6d45f25814'
}, function(error, result){
    if (!error)
        console.log(result);
})
.on("data", function(log){
    console.log(log);
})
.on("changed", function(log){
});

// unsubscribes the subscription
subscription.unsubscribe(function(error, success){
    if(success)
        console.log('Successfully unsubscribed!');
});

```

### 8.4. 订阅同步状态

```

const Web3 = require('web3');

const web3 = new Web3(new Web3.providers.WebsocketProvider('wss://mainnet.infura.io/ws'));

var subscription = web3.eth.subscribe('syncing', function(error, sync){
    if (!error)
        console.log(sync);
})
.on("data", function(sync){
    // show some syncing stats
})
.on("changed", function(isSyncing){
    if(isSyncing) {
        // stop app operation
    } else {
        // regain app operation
    }
});

// unsubscribes the subscription
subscription.unsubscribe(function(error, success){
    if(success)
        console.log('Successfully unsubscribed!');
});

```

## 9. utils

### 9.1. web3.utils.toWei()

```

web3.utils.toWei('1', 'ether');
> "1000000000000000000"

web3.utils.toWei('1', 'finney');
> "1000000000000000"

web3.utils.toWei('1', 'szabo');
> "1000000000000"

web3.utils.toWei('1', 'shannon');
> "1000000000"			

```

### 9.2. 将 Wei 转换到指定单位

```

web3.utils.fromWei('1', 'ether');
> "0.000000000000000001"

web3.utils.fromWei('1', 'finney');
> "0.000000000000001"

web3.utils.fromWei('1', 'szabo');
> "0.000000000001"

web3.utils.fromWei('1', 'shannon');
> "0.000000001"

```

## 10. web3 编译合约

### 10.1. solc.compile

```

pragma solidity ⁰.4.0;
contract HelloWorldContract {
  function sayHi() constant returns (string){
    return 'Hello World';
  }
}			

```

```

const fs = require ('fs');
const solc = require ('solc');
const input = fs.readFileSync('HelloWorldContract.sol');
const output = solc.compile(input.toString(), 1);
for (var contractName in output.contracts){
 console.log(contractName + ': ' + output.contracts[contractName].bytecode)
}

```

```

> const fs = require ('fs');
undefined
> const solc = require ('solc');

undefined
> const input = fs.readFileSync('HelloWorldContract.sol');
undefined
> const output = solc.compile(input.toString(), 1);

undefined
> for (var contractName in output.contracts){
...  console.log(contractName + ': ' + output.contracts[contractName].bytecode)
... }
:HelloWorldContract: 6060604052341561000f57600080fd5b61014e8061001e6000396000f3006060604052600436106100405763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630c49c36c8114610045575b600080fd5b341561005057600080fd5b6100586100cf565b60405160208082528190810183818151815260200191508051906020019080838360005b8381101561009457808201518382015260200161007c565b50505050905090810190601f1680156100c15780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6100d7610110565b60408051908101604052600b81527f48656c6c6f20576f726c640000000000000000000000000000000000000000006020820152905090565b602060405190810160405260008152905600a165627a7a723058206dc75b1be2caa91f056c3682d24390fcb090a96bbf1b2b4c11cdd807518dc03c0029
undefined

```

## 11. web3admin

[`github.com/DecentricCorp/web3admin`](https://github.com/DecentricCorp/web3admin)

```

npm install web3admin

```

```

const Web3 = require('web3')
var web3 = new Web3('http://localhost:8545')
const web3Admin = require('web3admin')
setTimeout(function(){
    web3Admin.extend(web3)
    console.log("turning on mining", web3.miner.start())
    console.log("isMining?", web3.eth.mining)
    console.log("isMining?", web3.eth.mining)
}, 1000)

```

## 12. ABI-encoded

ABI-encoded 实际上就是构造方法变量数据

```

var abi = require('ethereumjs-abi')

var parameterTypes = ["address", "uint256", "bool"];
var parameterValues = ["0x1234567812345678", "0x314159268", true];

var encoded = abi.rawEncode(parameterTypes, parameterValues);

console.log(encoded.toString('hex'));

```

在线生成工具 https://abi.sonnguyen.ws/， https://abi.hashex.org/

还有一种方法可以找到 ABI 数据 https://etherscan.io/tx/0xc53f52b287ec1c71e9d203dd08cc68035ef40bf5155f8b0711da227c01d84d70 查看 Input Data: 0029 之后所有的数据就是 ABI

## 13. 实用例子

### 13.1. 数据写入到区块链中

做一笔交易，并写入数据到区块链中

```

let Web3 = require("web3");
let fs = require("fs");
let web3 = new Web3("http://localhost:8545");

let log = {
    time:(new Date).getTime(),
    type:"info",
    msg:"Web3 Test!!!"
};
let str = JSON.stringify(log);
console.log(str);
let data = Buffer.from(str).toString('hex');
data = '0x'+data;
console.log(data);

//将数据写入到交易中
let coinbase = "0x5c18a33df2cc41a1beddc91133b8422e89f041b7"
console.log(coinbase)
let user1 = "0xc2b9e316f246d35052118e51b55c75bfe99d247e";
web3.eth.personal.unlockAccount(coinbase, "coinbase");
let address = web3.eth.sendTransaction({
    from:coinbase,
    to:user1,
    value:'0x00',
    data:data
},function(error, hash){
    console.log(hash);
});

```

运行上面程序，会产生一个交易，记下 hash 值，然后启动挖矿。

```

> miner.start();
null
# 过一段时间后停止
> miner.stop();
true

```

然后查看这比交易

```

let Web3 = require("web3");
let fs = require("fs");
let web3 = new Web3("http://localhost:8545");
let address ="0xb15681eb4bdb6b9670d305fb341ebbc95d45c2ede0ea5034ef432b74f30b1b4f";
//从交易地址获取数据
web3.eth.getTransaction(address).then(console.log);

web3.eth.getTransaction(address,function(error, result){
    //console.log(result);
    inputData = result.input;
    res_str = Buffer.from(inputData.replace('0x',''),'hex').toString();
    res_json = JSON.parse(res_str);
    console.log(res_json);
});			

```

结果输出

```

{ blockHash: '0x78dacc2af60900d2e4cae90b71e27446e6e883df36c53f21cbc9e071f7a586f4',
  blockNumber: 1258,
  from: '0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7',
  gas: 90000,
  gasPrice: '18000000000',
  hash: '0xb15681eb4bdb6b9670d305fb341ebbc95d45c2ede0ea5034ef432b74f30b1b4f',
  input: '0x7b2274696d65223a313531383933313435323537372c2274797065223a22696e666f222c226d7367223a22576562332054657374212121227d',
  nonce: 4,
  to: '0xc2b9e316F246d35052118E51B55C75BfE99d247e',
  transactionIndex: 0,
  value: '0',
  v: '0x41',
  r: '0x7fcd86c7fd975a0e98bd0e61a99da950b0155cd6c4581fefa4defbdcd404a930',
  s: '0x16f14ce1fbfadb9d59f343f8ac235cdd73dcedec5db1025ef91206b8bb17a827' }
{ time: 1518931452577, type: 'info', msg: 'Web3 Test!!!' }

```

{ time: 1518931452577, type: 'info', msg: 'Web3 Test!!!' } 就是保存在区块链中的数据。

### 13.2. 编译部署智能合约

```

console.log('Setting up...');
const fs = require ('fs');
const solc = require ('solc');
const Web3 = require ('web3');
const web3 = new Web3("http://localhost:8545");
console.log('Reading Contract...');
const input = fs.readFileSync('Netkiller.sol');
console.log('Compiling Contract...');
const output = solc.compile(input.toString(), 1);
//console.log(output);
const bytecode = output.contracts[':Netkiller'].bytecode;
//console.log(bytecode);
const abi = output.contracts[':Netkiller'].interface;
//console.log(abi);
//Contract Object
//const helloWorldContract = web3.eth.contract(JSON.parse(abi));

var myContract = new web3.eth.Contract(JSON.parse(abi), '0x5c18a33df2cc41a1beddc91133b8422e89f041b7', {
    from: '0x5c18a33df2cc41a1beddc91133b8422e89f041b7', // default from address
    gasPrice: '20000000000' // default gas price in wei, 20 gwei in this case
});

console.log('unlocking Coinbase account');
const password = "chen1980";
web3.eth.personal.unlockAccount("0x5c18a33df2cc41a1beddc91133b8422e89f041b7", password,100);

console.log("Deploying the contract");

```

### 13.3. 部署合约

```

var Web3 = require('web3');
var net = require('net');
var web3 = new Web3(new Web3.providers.IpcProvider("~/netkiller/ethereum/geth.ipc",net));

var abi = [...];
var bin = "";

var tokenContract = new web3.eth.Contract(abi, null, {
    from: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6' // 目前 web3 没有 api 来解锁账户,只能自己事先解锁
});

tokenContract.deploy({
    data: bin,
    arguments: ['netkiller'] // 这里是构造函数传值，如果构造函数没有参数，请删除这行。
}).send({
    from: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
    gas: 1500000,
    gasPrice: '30000000000000'
}, function(error, transactionHash){
    console.log("deploy tx hash:"+transactionHash)
})
.on('error', function(error){ console.error(error) })
.on('transactionHash', function(transactionHash){ console.log("hash:",transactionHash)})
.on('receipt', function(receipt){
   console.log(receipt.contractAddress) // contains the new contract address
})
.on('confirmation', function(confirmationNumber, receipt){console.log("receipt,",receipt)})
.then(function(newContractInstance){
    console.log(newContractInstance.options.address) // instance with the new contract address
});			

```

### 13.4. ERC20 Example

通过 Web3 操作代币转账

```

fs = require('fs');
const Web3 = require('web3');
const web3 = new Web3('http://localhost:8545');
web3.version
const abi = fs.readFileSync('output/TokenERC20.abi', 'utf-8');

const contractAddress = "0x05A97632C197a0496bc939C4e666c2E03Cb95DD4";
const toAddress = "0x2C687bfF93677D69bd20808a36E4BC2999B4767C";

var coinbase;

web3.eth.getCoinbase().then(function (address){
  coinbase = address;
  console.log(address);
});

const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});

contract.methods.balanceOf('0x5c18a33DF2cc41a1bedDC91133b8422e89f041B7').call().then(console.log).catch(console.error);
contract.methods.balanceOf('0x2C687bfF93677D69bd20808a36E4BC2999B4767C').call().then(console.log).catch(console.error);

web3.eth.personal.unlockAccount(coinbase, "netkiller").then(console.log);
contract.methods.transfer('0x2C687bfF93677D69bd20808a36E4BC2999B4767C', 100).send().then(console.log).catch(console.error);

contract.methods.balanceOf('0x2C687bfF93677D69bd20808a36E4BC2999B4767C').call().then(console.log).catch(console.error);

```

## 14. HD Wallet(Hierarchical Deterministic wallet)

BIP32 定义 Hierarchical Deterministic wallet (简称 "HD Wallet")，是一个系统可以从单个 seed 产生树状结构储存多组 keypairs（私钥和公钥）

BIP39 定义钱包助记词和 seed 生成规则，一般由 12 -24 个单字组成，称为 mnemonic。助记词列表，https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt

BIP44 基于 BIP32 的系统，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支援多币种、多帐户等 （btc 一般是 m/44'/0'/0’/0，eth 一般是 m/44'/60'/0'/0）

```

npm install bip39 ethereumjs-wallet ethereumjs-util --save

```

### 14.1. 创建项目

导入开发包

```

var bip39 = require('bip39')
var hdkey = require('ethereumjs-wallet/hdkey')
var util = require('ethereumjs-util')

```

生成 mnemonic code

```

var mnemonic = bip39.generateMnemonic()

```

生成 HD Wallet 首先将 mnemonic code 转成 binary 二进制的 seed

```

var seed = bip39.mnemonicToSeed(mnemonic)

```

生成 Master Key 地址 "m/44'/60'/0'/0/0" 使用 seed 生成 HD Wallet。

```

var hdwallet = hdkey.fromMasterSeed(seed)

```

从路径 m/44'/60'/0'/0/0 导入 Master Key 并生成 Wallet 中第一个帐户的第一组 keypair。

```

var key1 = hdwallet.derivePath("m/44'/60'/0'/0/0")

```

使用 keypair 中的公钥产生 address。

```

var address1 = util.pubToAddress(key1._hdkey._publicKey, true)

```

获得以太坊钱包地址

```

address1 = util.toChecksumAddress(address1.toString('hex'))

```

操作演示

```

[ethereum@netkiller web3.js]$ node
> var bip39 = require('bip39')
undefined
> var hdkey = require('ethereumjs-wallet/hdkey')
undefined
> var util = require('ethereumjs-util')
undefined
> var mnemonic = bip39.generateMnemonic()
undefined
> mnemonic
'client dune unfair assume level width bind control mad member old crystal'
> var seed = bip39.mnemonicToSeed(mnemonic)
undefined
> seed
<Buffer 51 12 a3 47 f3 bb b9 24 80 ac 05 6c ce 8c 9f dd b2 98 c8 d3 06 8f 4d 0b 6c 90 86 aa d4 b6 41 36 35 5f b4 42 89 b5 e4 6d 43 9b cf 8d 6a d7 9b 45 3e 5a ... >
> var hdwallet = hdkey.fromMasterSeed(seed)
undefined
> hdwallet
EthereumHDKey {
  _hdkey:
   HDKey {
     versions: { private: 76066276, public: 76067358 },
     depth: 0,
     index: 0,
     _privateKey: <Buffer 1c 37 00 1b f7 1d a5 de 3a 8a 4c e8 54 2d 69 78 81 f3 aa a9 d5 3e 64 74 bd ea 76 28 44 07 d3 04>,
     _publicKey: <Buffer 03 77 fc 6b c7 f3 e3 51 01 db 95 0a a9 0f c0 7f 31 40 af 75 f8 7a 4f 5a c3 4c 93 ac cb 44 a3 20 5f>,
     chainCode: <Buffer 51 fe 32 23 a0 ab aa 10 5d ff 90 28 26 dc fc 86 fc 5f 8c dc 1b b7 39 31 7e 2d b8 a4 77 33 45 3a>,
     _fingerprint: 1056395940,
     parentFingerprint: 0,
     _identifier: <Buffer 3e f7 52 a4 ed 86 00 f7 ac 4d 1a b4 15 1c 0d 87 cd 7d fe de> } }
> var key1 = hdwallet.derivePath("m/44'/60'/0'/0/0")
undefined
> key1
EthereumHDKey {
  _hdkey:
   HDKey {
     versions: { private: 76066276, public: 76067358 },
     depth: 5,
     index: 0,
     _privateKey: <Buffer f5 92 b7 bf 06 ca 9f d7 69 6b a9 5d 6e d8 e3 57 de 6a 23 79 b6 d5 fe 1f fd 53 c6 b4 b0 63 cd 4a>,
     _publicKey: <Buffer 02 99 ff bb ea 3d 80 e1 8c d5 54 a1 6e 6a ca b2 4b 7e 69 3d 1d 2d 8a 68 f8 61 bf 18 dc 4a f8 d0 26>,
     chainCode: <Buffer 5a 9b b2 0e 7a 62 07 b0 82 db e5 5a 1f 17 4b 47 8a 64 cf 40 67 d5 49 09 89 da aa 33 66 00 d7 e6>,
     _fingerprint: 3510386860,
     parentFingerprint: 1205114865,
     _identifier: <Buffer d1 3c 40 ac 09 92 fc d7 a4 14 8e d8 91 d1 a7 21 55 7e b8 e3> } }
> var address1 = util.pubToAddress(key1._hdkey._publicKey, true)
undefined
> address1
<Buffer 37 2f da 02 e8 a1 ec a5 13 f2 ee 59 01 dc 55 b8 b5 dd 74 11>
> address1.toString('hex')
'372fda02e8a1eca513f2ee5901dc55b8b5dd7411'

```

### 14.2. 生成第二个钱包

只需递增最后一位数即可 "m/44'/60'/0'/0/1"， "m/44'/60'/0'/0/2"，"m/44'/60'/0'/0/3"

```

var key2 = hdwallet.derivePath("m/44'/60'/0'/0/1")

```

使用 keypair 中的公钥产生 address。

```

var address2 = util.pubToAddress(key2._hdkey._publicKey, true)

```

获得以太坊钱包地址

```

address2 = util.toChecksumAddress(address2.toString('hex'))

```

### 14.3. Mnemonic Code Converter

[`iancoleman.io/bip39/`](https://iancoleman.io/bip39/)

输入 mnemonic，选择 ETH - Ethereum

| ![](img/mnemonic.png) |

系统将计算出钱包地址

| ![](img/walletpath.png) |

### 14.4. HD Wallet 例子

```

var bip39 = require('bip39');
var hdkey = require('ethereumjs-wallet/hdkey');
var util = require('ethereumjs-util');

mnemonic = 'client dune unfair assume level width bind control mad member old crystal';
var seed = bip39.mnemonicToSeed(mnemonic);
var hdwallet = hdkey.fromMasterSeed(seed);
var key1 = hdwallet.derivePath("m/44'/60'/0'/0/0");
var address1 = util.pubToAddress(key1._hdkey._publicKey, true);
var address = util.toChecksumAddress(address1.toString('hex'));

coinbase = "0xaa96686a050e4916afbe9f6d8c5107062fa646dd";
contractAddress = "0x9ABcF16f6685fE1F79168534b1D30056c90B8A8A"

console.log(address);

fs = require('fs');
const Web3 = require('web3');
const HDWalletProvider = require("truffle-hdwallet-provider");

const web3 = new Web3(new HDWalletProvider(mnemonic,'http://localhost:8545'));
console.log(web3.version)

web3.eth.getBalance("0xaa96686a050e4916afbe9f6d8c5107062fa646dd").then(function(balance){
      console.log( web3.utils.fromWei(balance) );
});

web3.eth.getBalance(address).then(function(balance){
      console.log( web3.utils.fromWei(balance) );
});

const abi = fs.readFileSync('output/NetkillerToken.abi', 'utf-8');
const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: address, gas: 100000});

contract.methods.balanceOf(coinbase).call().then(console.log).catch(console.log);
contract.methods.balanceOf(address).call().then(console.log).catch(console.log);

```

### 14.5. 获得钱包地址和私钥

```

const bip39 = require('bip39');
const hdkey = require('ethereumjs-wallet/hdkey');

const mnemonic = 'client dune unfair assume level width bind control mad member old crystal';
const hdwallet = hdkey.fromMasterSeed(bip39.mnemonicToSeed(mnemonic));
const path = "m/44'/60'/0'/0/0";
const wallet = hdwallet.derivePath(path).getWallet();

const address = `0x${wallet.getAddress().toString('hex')}`;
const privateKey = wallet.getPrivateKey().toString('hex');
// wallet._privKey.toString('hex');
console.log(`Address: ${address}`);
console.log(`Private Key: ${privateKey}`);

```

### 14.6. truffle.js 例子

```

npm install truffle-hdwallet-provider

```

```

var HDWalletProvider = require("truffle-hdwallet-provider");

var mnemonic = "opinion destroy betray ...";

module.exports = {
  networks: {
    development: {
      host: "localhost",
      port: 8545,
      network_id: "*" // Match any network id
    },
    ropsten: {
      provider: new HDWalletProvider(mnemonic, "https://ropsten.infura.io/"),
      network_id: 3
    }
  }
};

```

### 14.7. Mnemonic To Seed 加密

没有加密 seed 是很不安全的，任何人都能通过 Mnemonic 还原出公钥和私钥。

```

var bip39 = require('bip39')
var hdkey = require('ethereumjs-wallet/hdkey')
var util = require('ethereumjs-util')
var mnemonic = bip39.generateMnemonic()

var password = "http://www.netkiller.cn"
var seed = bip39.mnemonicToSeed(mnemonic, password)
var hdwallet = hdkey.fromMasterSeed(seed)
var key1 = hdwallet.derivePath("m/44'/60'/0'/0/0")
var address1 = util.pubToAddress(key1._hdkey._publicKey, true)
address1 = util.toChecksumAddress(address1.toString('hex'))

```

### 14.8. 中文助记词

```

var bip39 = require('bip39')
var mnemonic = bip39.generateMnemonic(128, null, bip39.wordlists.chinese_simplified)
console.log(mnemonic)

var seed = bip39.mnemonicToSeed(mnemonic)
var hdwallet = hdkey.fromMasterSeed(seed)
var key1 = hdwallet.derivePath("m/44'/60'/0'/0/0")
var address1 = util.pubToAddress(key1._hdkey._publicKey, true)
address1 = util.toChecksumAddress(address1.toString('hex'))

```

演示

```

> var bip39 = require('bip39')
undefined

> var mnemonic = bip39.generateMnemonic(128, bip39.randomBytes, bip39.wordlists.chinese_simplified)
undefined

> console.log(mnemonic)
俄 判 菌 诗 仪 偏 方 都 激 输 失 稀
undefined

```

### 14.9. 代币转账

## 15. 从 .ethereum/keystore 文件导入私钥

```

[ethereum@netkiller web3.example]$ npm install keythereum

```

代码

```

var keyth=require('keythereum')
// Mac
// keystore = './Appdata/roaming/ethereum';
// Ubuntu 
// keystore = '~/.ethereum';
keystore = '../.ethereum';
var keyobj=keyth.importFromFile('0x372fda02e8a1eca513f2ee5901dc55b8b5dd7411',keystore)
var privateKey=keyth.recover('12345678',keyobj)
privateKey.toString('hex')

```

操作演示

```

> var keyth=require('keythereum')
undefined
> keystore = '../.ethereum';
'../.ethereum'
> var keyobj=keyth.importFromFile('0x372fda02e8a1eca513f2ee5901dc55b8b5dd7411',keystore)
undefined
> var privateKey=keyth.recover('12345678',keyobj)
undefined
> privateKey.toString('hex')
'f592b7bf06ca9fd7696ba95d6ed8e357de6a2379b6d5fe1ffd53c6b4b063cd4a'

```

## 16. Express + web3.js 实现简单网页钱包

下面的例子，实现查询余额，创建账号，ETH 转账，代币转账。

### 16.1. 创建项目

安装以太坊环境

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/gcc/gcc.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/golang/golang-1.10.2.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/centos/go-ethereum-1.8.8.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/systemd/private.sh | bash

curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/node.js/binrary/node-v10.1.0.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/lang/node.js/binrary/profile.d.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/blockchain/ethereum/truffle/truffle.sh | bash

```

安装开发包

```

npm install express
npm install web3
npm install ejs

```

### 16.2. 主程序 main.js

```

var express = require('express');
var app = express();

app.use(express.static('public'));
app.set("view engine","ejs");
app.set('views', __dirname + '/views');  

var async = require('async');

fs = require('fs');
var net = require('net');
var Web3 = require('web3');
var web3 = new Web3('/home/ethereum/.ethereum/geth.ipc', net);
const abi = fs.readFileSync( __dirname + '/abi/NKC.abi', 'utf-8');
const coinbase = "0xaa96686a050e4916afbe9f6d62fa646dd8c51070"
const contractAddress = "0x5F75DA091aBb25e055B91172C04371Ff4Dd563a0";

console.log(web3.version)

app.get('/', function (req, res) {
  //  res.send('Hello World');
   res.render("index",{}); 
})

app.get('/account.html', function (req, res) {
  var accounts;
  web3.eth.getAccounts(function(err, acc) {
    accounts = acc
    res.render("account",{"accounts":accounts}); 
  });
})

app.get('/new', function (req, res) {
  web3.eth.personal.newAccount(req.query.password).then(function(){
    res.redirect('/account.html');
  });
})

app.get('/balance.html', function (req, res) {

  web3.eth.getAccounts(function(err, accounts) {
    res.render("balance",{"accounts":accounts}); 
  });
})
app.post('/showbalance.html', function (req, res) {
  // web3.eth.getBalance(req.query.account).then(function(balance){
  //   res.render("transfer",{"account":req.query.account, "balance": balance}); 
  // });

  res.render("showbalance",{"account": "sss", "balance": 1000}); 
})

app.get('/getbalance.html', function (req, res) {
  var contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});
  web3.eth.getBalance(req.query.account).then(function(balance){
    contract.methods.balanceOf(req.query.account).call().then(function(token){
      // console.log(contract.symbol.call());
      // contract.methods.symbol().call().then(console.log);
      contract.methods.symbol().call().then(function(name){
        res.render("showbalance",{"account":req.query.account, "balance": web3.utils.fromWei(balance, 'ether'), "token": token, "name": name}); 
      });

    });

  });
})

app.get('/transfer.html', function (req, res) {
  var contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});
  web3.eth.getAccounts(function(err, accounts) {
    contract.methods.symbol().call().then(function(symbol){
      res.render("transfer",{"accounts":accounts, "symbol": symbol}); 
    });
  });
})

app.get('/send', function (req, res) {
  // console.log(req.query)
  web3.eth.personal.unlockAccount(req.query.from, req.query.password).then(function(error){
    if(req.query.token == "ETH"){  
      web3.eth.sendTransaction({
        from: req.query.from,
        to: req.query.to,
        value: web3.utils.toWei(req.query.amount ,'ether')
      },
      function(error, result){
          if(!error) {
              console.log("#" + result + "#")
              res.render("done",{"hash":result}); 
          } else {
              console.error(error);
          }
      });

    }else{
      var contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: req.query.from , gas: 1000000});
      contract.methods.transfer(req.query.to, req.query.amount).send().then(function(hash){
        console.log(hash)
        res.render("done",{"hash":hash.transactionHash}); 
      });
    }
  });
})

var server = app.listen(8080, function () {

  var host = server.address().address
  var port = server.address().port

  console.log("应用实例，访问地址为 http://%s:%s", host, port)

})

```

### 16.3. ABI 文件 abi/NKC.abi

```

[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_value","type":"uint256"}],"name":"burn","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_value","type":"uint256"}],"name":"burnFrom","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"},{"name":"_extraData","type":"bytes"}],"name":"approveAndCall","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"initialSupply","type":"uint256"},{"name":"tokenName","type":"string"},{"name":"tokenSymbol","type":"string"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Burn","type":"event"}]			

```

### 16.4. 页面视图

#### 16.4.1. views/account.ejs

```

<%- include header.ejs %>

<h1>Users</h1>
<ul id="accounts">
    <% accounts.forEach(function(account, index){ %>
    <li><%= index %>, <%= account %></li>
    <% }) %>
</ul>

<p>
新建账号
<form method="get" action="/new">
    密码：<input type="password" name="password" />
    <input type="submit" value="新建账号" />
</form>
</p>

```

#### 16.4.2. views/balance.ejs

```

<%- include header.ejs %>

<h1>Account</h1>
<form method="get" action="/getbalance.html">

    <select name="account">
        <% accounts.forEach(function(account, index){ %>
        <option value ="<%= account %>"><%= account %></option>
        <% }) %>
    </select>
    <input type="submit" value="Submit" />
</form>

```

#### 16.4.3. views/done.ejs

```

<%- include header.ejs %>

<p>转账完成</p>
<p>查看交易
<a href="https://etherscan.io/tx/<%= hash %>" target="etherscan">主网<%= hash %></a> <br />
</p>

```

#### 16.4.4. views/header.ejs

```

<a href="/account.html">账号</a> | <a href="/balance.html">余额</a> | <a href="/transfer.html">转账</a>
<br /> 
<hr />

```

#### 16.4.5. views/index.ejs

```

<%- include header.ejs %>

Welcome !!!

```

#### 16.4.6. views/showbalance.ejs

```

<%- include header.ejs %>
<p>
<h1>Account: <%= account %>, Balance: <%= balance %></h1>
</p>

<p>
    Token: <%= token%> <%= name%> 
</p>

```

#### 16.4.7. views/transfer.ejs

```

<%- include header.ejs %>

<h1>Account</h1>
<form method="get" action="/send">
    From：
    <select name="from">
        <% accounts.forEach(function(account, index){ %>
        <option value ="<%= account %>"><%= account %></option>
        <% }) %>
    </select>
    <br />
    To:
    <select name="to">
        <% accounts.forEach(function(account, index){ %>
        <option value ="<%= account %>"><%= account %></option>
        <% }) %>
    </select>

    <select name="token">
        <option value ="ETH">ETH</option>
        <option value ="<%= symbol %>"><%= symbol %></option>
    </select>

    <br />
    金额: <input type="text" name="amount" /> ETH
    <br />
    密码：<input type="password" name="password" />
    <br />
    <input type="submit" value="Submit" />
</form>

```

### 16.5. 启动 Node 服务

```

neo@MacBook-Pro ~/example % node main.js

```

浏览器访问 http://localhost:8080/ 可以进入钱包

## 第 17 章 web3j v3.4.0 - Jave Client

官方网站 [`web3j.io`](https://web3j.io)

文档 [`github.com/web3j/web3j/tree/master/docs/source`](https://github.com/web3j/web3j/tree/master/docs/source)

Java 客户端与 Server 之间采用 json-rpc 协议连接。

## 1. 安装命令行工具

web3j 命令用于将 sol 合约文件转换为 java 文件。

### 1.1. Mac OS

```

brew tap web3j/web3j
brew install web3j

neo@MacBook-Pro ~ % web3j

              _      _____ _     _        
             | |    |____ (_)   (_)       
__      _____| |__      / /_     _   ___  
\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \ 
 \ V  V /  __/ |_) |.___/ / | _ | || (_) |
  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/ 
                         _/ |             
                        |__/              

Usage: web3j version|wallet|solidity ...	

```

### 1.2. 二进制包安装

下载二进制文件 [`github.com/web3j/web3j/releases`](https://github.com/web3j/web3j/releases)

```

wget https://github.com/web3j/web3j/releases/download/v3.2.0/web3j-3.2.0.zip
unzip web3j-3.2.0.zip

$ ./web3j-3.2.0/bin/web3j

              _      _____ _     _
             | |    |____ (_)   (_)
__      _____| |__      / /_     _   ___
\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \
 \ V  V /  __/ |_) |.___/ / | _ | || (_) |
  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/
                         _/ |
                        |__/

Usage: web3j version|wallet|solidity ...

```

## 2. 启动以太坊

首先启动服务

```

neo@netkiller ~ % geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --nodiscover 
INFO [02-01|23:35:12] Starting peer-to-peer node               instance=Geth/v1.8.8-stable-4bb3c89d/linux-amd64/go1.10.2	
INFO [02-01|23:35:12] Allocated cache and file handles         database=/home/neo/.ethereum/geth/chaindata cache=128 handles=1024
INFO [02-01|23:35:12] Initialised chain configuration          config="{ChainID: 15 Homestead: 0 DAO: <nil> DAOSupport: false EIP150: <nil> EIP155: 0 EIP158: 0 Byzantium: <nil> Engine: unknown}"
INFO [02-01|23:35:12] Disk storage enabled for ethash caches   dir=/home/neo/.ethereum/geth/ethash count=3
INFO [02-01|23:35:12] Disk storage enabled for ethash DAGs     dir=/home/neo/.ethash               count=2
INFO [02-01|23:35:12] Initialising Ethereum protocol           versions="[63 62]" network=123456
INFO [02-01|23:35:12] Loaded most recent local header          number=719 hash=61330b…82786e td=108754979
INFO [02-01|23:35:12] Loaded most recent local full block      number=719 hash=61330b…82786e td=108754979
INFO [02-01|23:35:12] Loaded most recent local fast block      number=719 hash=61330b…82786e td=108754979
INFO [02-01|23:35:12] Loaded local transaction journal         transactions=0 dropped=0
INFO [02-01|23:35:12] Regenerated local transaction journal    transactions=0 accounts=0
WARN [02-01|23:35:12] Blockchain not empty, fast sync disabled 
INFO [02-01|23:35:12] Starting P2P networking 
INFO [02-01|23:35:12] RLPx listener up                         self="enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@[::]:30303?discport=0"
INFO [02-01|23:35:12] IPC endpoint opened: /home/neo/.ethereum/geth.ipc 
INFO [02-01|23:35:12] HTTP endpoint opened: http://0.0.0.0:8545 
INFO [02-01|23:35:15] Mapped network port                      proto=tcp extport=30303 intport=30303 interface="UPNP IGDv1-IP1"		

```

Web3j 将使用这个地址连接 HTTP endpoint opened: http://your_ip_address:8545

## 3. Maven pom.xml 文件

```

<project  
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>cn.netkiller</groupId>
	<artifactId>ethereum</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>ethereum</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.web3j</groupId>
			<artifactId>core</artifactId>
			<version>3.4.0</version>
		</dependency>
	</dependencies>
</project>

```

## 4. Java 与 Solidity 数据类型映射关系

```

boolean -> bool
BigInteger -> uint/int
byte[] -> bytes
String -> string and address types
List<> -> dynamic/static array			

```

## 5. 常量

```

DefaultBlockParameterName.LATEST	当前块地址
DefaultBlockParameterName.PENDING	处理中块地址		

```

### 5.1. 默认 Gas

获取默认 GAS Transaction.DEFAULT_GAS

]

```

package cn.netkiller.wallet.ethereum;

import org.web3j.protocol.core.methods.request.Transaction;

public class Test {

	public Test() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(Transaction.DEFAULT_GAS);

	}

}

```

### 5.2. 默认 gaslimit gasprice

已经废弃

```

BigInteger gasLimit = Contract.GAS_LIMIT;
BigInteger gasPrice = Contract.GAS_PRICE;			

```

推荐使用

```

			BigInteger gasPrice = BigInteger.ZERO;
			BigInteger gasLimit = BigInteger.ZERO;

			gasPrice = DefaultGasProvider.GAS_PRICE;
			gasLimit = DefaultGasProvider.GAS_LIMIT;

			System.out.println("gasPrice: " + gasPrice.toString());
			System.out.println("gasLimit: " + gasLimit.toString());			

```

## 6. 连接到服务器获取版本号

```

package cn.netkiller.ethereum;

import java.io.IOException;

import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;
import org.web3j.protocol.http.HttpService;

public class Web3JClient {
	// TODO Auto-generated method stub

	public static void main(String[] args) {
		String url = "http://172.16.0.1:8545/";
		Web3j web3j = Web3j.build(new HttpService(url)); // defaults to http://localhost:8545/

		try {
			Web3ClientVersion web3ClientVersion = web3j.web3ClientVersion().send();
			String clientVersion = web3ClientVersion.getWeb3ClientVersion();
			System.out.println(clientVersion);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}

```

运行结果

```

Geth/v1.8.8-stable-4bb3c89d/linux-amd64/go1.10.2				

```

除了 TCP 方式连接，还支持 IPC 方式。这种方式比较少用，可以使用 localhost 替代。

```

// OS X/Linux/Unix:
Web3j web3 = Web3j.build(new UnixIpcService("/path/to/socketfile"));
...

// Windows
Web3j web3 = Web3j.build(new WindowsIpcService("/path/to/namedpipefile"));
...			

```

## 7. 获得以太坊状态信息

### 7.1. 获取客户端版本

```

			Web3ClientVersion web3ClientVersion = web3j.web3ClientVersion().send();
			String clientVersion = web3ClientVersion.getWeb3ClientVersion();
			System.out.println("客户端版本: " + clientVersion);			

```

### 7.2. 协议版本

```

			EthProtocolVersion ethProtocolVersion = web3j.ethProtocolVersion().send();
			String protocolVersion = ethProtocolVersion.getProtocolVersion();
			System.out.println("协议版本" + protocolVersion);

```

### 7.3. 查看当前区块

```

			EthBlockNumber ethBlockNumber = web3j.ethBlockNumber().send();
			BigInteger blockNumber = ethBlockNumber.getBlockNumber();
			System.out.println("当前区块：" + blockNumber);			

```

### 7.4. 同步状态

```

			EthSyncing ethSyncing = web3j.ethSyncing().send();
			boolean isSyncing = ethSyncing.isSyncing();
			System.out.println("同步状态：" + isSyncing);

```

### 7.5. 挖矿状态

```

			EthMining ethMining = web3j.ethMining().send();
			boolean isMining = ethMining.isMining();
			System.out.println("挖矿状态：" + isMining);

```

### 7.6. 矿工账号

```

			EthCoinbase ethCoinbase = web3j.ethCoinbase().send();
			String coinbase = ethCoinbase.getAddress();
			System.out.println("矿工账号：" + coinbase);

```

### 7.7. 挖矿速度

```

			EthHashrate ethHashrate = web3j.ethHashrate().send();
			BigInteger hashRate = ethHashrate.getHashrate();
			System.out.println("挖矿速度：" + hashRate);

```

### 7.8. Gas 价格

```

			EthGasPrice ethGasPrice = web3j.ethGasPrice().send();
			BigInteger gasPrice = ethGasPrice.getGasPrice();
			System.out.println("Gas 价格：" + gasPrice);

```

### 7.9. 评估 GAS

```

	EthEstimateGas ethEstimateGas = web3.ethEstimateGas(Transaction.createEthCallTransaction(credentials.getAddress(), null, encodedFunction)).sendAsync().get();
	BigInteger estimateGas = ethEstimateGas.getAmountUsed();
	System.out.println(estimateGas);			

    ethEstimateGas.getAmountUsed().divide(BigInteger.valueOf(100));

```

### 7.10. 节点数量

```

			NetPeerCount netPeerCount = web3j.netPeerCount().send();
			BigInteger peerCount = netPeerCount.getQuantity();
			System.out.println("节点数量：" + peerCount);

```

## 8. 单位转换

### 8.1. GWEI to WEI

GWEI 转化为 WEI

```

BigInteger wei = Convert.toWei(BigDecimal.valueOf(0.001), Convert.Unit.GWEI).toBigInteger();

BigInteger value = Convert.toWei("1.0", Convert.Unit.ETHER).toBigInteger();

```

## 9. 账号管理

### 9.1. 获得账号列表

```

	public List<String> getAccountlist() {

		try {
			return web3j.ethAccounts().send().getAccounts();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}				

```

### 9.2. 获得账号信息

```

	public String getAccount(int index) {
		String account = null;

		try {
			account = web3j.ethAccounts().send().getAccounts().get(index);

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return account;
	}				

```

### 9.3. 创建账号

```

package cn.netkiller.example.ethereum.account;

import java.io.IOException;
import java.math.BigInteger;
import java.util.List;

import org.web3j.protocol.admin.Admin;
import org.web3j.protocol.admin.methods.response.NewAccountIdentifier;
import org.web3j.protocol.admin.methods.response.PersonalListAccounts;
import org.web3j.protocol.admin.methods.response.PersonalUnlockAccount;
//import org.web3j.protocol.http.HttpService;
import org.web3j.protocol.ipc.UnixIpcService;

public class AccountTest {
	private static Admin admin;

	public AccountTest() {
		// TODO Auto-generated constructor stub
		// admin = Admin.build(new HttpService("http://127.0.0.1:8545"));
		admin = Admin.build(new UnixIpcService("/Users/neo/Library/Ethereum/geth.ipc"));

	}

	private void createAccount() throws IOException {
		String password = "12345678";
		NewAccountIdentifier newAccountIdentifier = admin.personalNewAccount(password).send();
		String address = newAccountIdentifier.getAccountId();
		System.out.println("New account address: " + address);
	}

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		AccountTest account = new AccountTest();
		account.createAccount();
	}

}

```

### 9.4. 解锁账号

```

Admin web3j = Admin.build(new HttpService());  // defaults to http://localhost:8545/
PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount("0x000...", "a password").sendAsync().get();
if (personalUnlockAccount.accountUnlocked()) {
    // send a transaction
}				

```

```

package cn.netkiller.example.ethereum.account;

import java.io.IOException;
import java.math.BigInteger;
import java.util.List;

import org.web3j.protocol.admin.Admin;
import org.web3j.protocol.admin.methods.response.NewAccountIdentifier;
import org.web3j.protocol.admin.methods.response.PersonalListAccounts;
import org.web3j.protocol.admin.methods.response.PersonalUnlockAccount;
//import org.web3j.protocol.http.HttpService;
import org.web3j.protocol.ipc.UnixIpcService;

public class AccountTest {
	private static Admin admin;

	public AccountTest() {
		// TODO Auto-generated constructor stub
		// admin = Admin.build(new HttpService("http://127.0.0.1:8545"));
		admin = Admin.build(new UnixIpcService("/Users/neo/Library/Ethereum/geth.ipc"));

	}

	private void unlockAccount() {
		String address = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";
		String password = "12345678";
		// 账号解锁持续时间 单位秒 缺省值 300 秒
		BigInteger unlockDuration = BigInteger.valueOf(60L);
		try {
			PersonalUnlockAccount personalUnlockAccount = admin.personalUnlockAccount(address, password, unlockDuration).send();
			Boolean isUnlocked = personalUnlockAccount.accountUnlocked();
			System.out.println("Account unlock " + isUnlocked);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		AccountTest account = new AccountTest();
		account.unlockAccount();
	}

}

```

## 10. Credentials

```

package cn.netkiller.ethereum.credentials;

import java.io.IOException;
import java.math.BigInteger;

import org.web3j.crypto.Credentials;
import org.web3j.crypto.ECKeyPair;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.http.HttpService;

public class CredentialsTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		String url = "http://172.16.0.1:8545/";
		Web3j web3j = Web3j.build(new HttpService(url)); // defaults to http://localhost:8545/

		try {
			String account = web3j.ethAccounts().send().getAccounts().get(0);
			Credentials credentials = Credentials.create(account);
			ECKeyPair keyPair = credentials.getEcKeyPair();
			BigInteger privateKey = keyPair.getPrivateKey();
			BigInteger publicKey = keyPair.getPublicKey();

			System.out.println(privateKey);
			System.out.println("---");
			System.out.println(publicKey);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}

```

## 11. 交易

### 11.1. 获取余额

```

	public BigInteger getBalance(String account) throws IOException {

		EthGetBalance ethGetBalance = web3j.ethGetBalance(account, DefaultBlockParameterName.LATEST).send();
		BigInteger balance = ethGetBalance.getBalance();
		return balance;

	}				

```

### 11.2. 通过 Keystore 转账

```

	public void transfer(String account, float coin)
			throws InterruptedException, IOException, TransactionException, Exception {
		String password = "";
		String walletfile = "/Users/neo/netkiller/UTC--2018-01-20T04-04-06.786586541Z--83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6";
		Credentials credentials = WalletUtils.loadCredentials(password, walletfile);
		TransactionReceipt transactionReceipt = Transfer.sendFunds(web3j, credentials, account, BigDecimal.valueOf(coin), Unit.ETHER).send();
		System.out.println(transactionReceipt.getStatus());
	}

```

### 11.3. 通过私钥转账

```

package cn.netkiller.ethereum.transaction;

import org.web3j.crypto.Credentials;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.TransactionReceipt;
import org.web3j.protocol.http.HttpService;
import org.web3j.tx.Transfer;
import org.web3j.utils.Convert;

import java.math.BigDecimal;

public class TransactionTest {
	public static void main(String[] args) throws Exception {
		Web3j web3j = Web3j.build(new HttpService("https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d"));
		String toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";
		Credentials credentials = Credentials.create("16690967F2BADABE13A067066558537228D8AF63ECCB022FFBDC970EC717BC3A");

		TransactionReceipt transactionReceipt = Transfer.sendFunds(web3j, credentials, toAddress, BigDecimal.valueOf(0.002), Convert.Unit.ETHER).send();

		System.out.println(transactionReceipt.getTransactionHash());
	}
}

```

### 11.4. 指定 gas 费用

```

package cn.netkiller.ethereum.transaction;

import org.web3j.crypto.Credentials;
import org.web3j.crypto.TransactionEncoder;
import org.web3j.crypto.RawTransaction;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.http.HttpService;
import org.web3j.utils.Convert;
import org.web3j.utils.Numeric;

import java.math.BigInteger;
import java.util.concurrent.ExecutionException;

public class RawTransactionTest {

	public static void main(String[] args) throws InterruptedException, ExecutionException {
		// TODO Auto-generated method stub
		// 设置需要的矿工费
		BigInteger gasPrice = BigInteger.valueOf(18_000_000_000L);
		BigInteger gasLimit = BigInteger.valueOf(4_300_000);
		// System.out.println(gasPrice);

		// 连接 ropsten 测试环境，这里使用的是 infura 这个客户端
		Web3j web3j = Web3j.build(new HttpService("https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d"));
		// 转出账户地址
		String fromAddress = "0x22c57F0537414FD95b9f0f08f1E51d8b96F14029";
		// 接收账户地址
		String toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";
		// 转账人的私钥
		Credentials credentials = Credentials.create("16697AC066558537CADABF68BDE13A06790967F2BC3A228DB022FF0EC717B3EC");

		// Nonce 就相当于数据中 PK 主键，每次 Nonce 会做 +1 操作
		EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount(fromAddress, DefaultBlockParameterName.LATEST).sendAsync().get();
		BigInteger nonce = ethGetTransactionCount.getTransactionCount();

		// 创建交易并转 0.05 个以太币
		BigInteger value = Convert.toWei("0.05", Convert.Unit.ETHER).toBigInteger();
		RawTransaction rawTransaction = RawTransaction.createEtherTransaction(nonce, gasPrice, gasLimit, toAddress, value);

		// 对交易做签名
		byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);
		String hexValue = Numeric.toHexString(signedMessage);

		// 发送交易
		EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).sendAsync().get();
		String transactionHash = ethSendTransaction.getTransactionHash();

		// 获得到 transactionHash 后就可以到以太坊的网站上查询这笔交易的状态了
		System.out.println("https://ropsten.etherscan.io/tx/" + transactionHash);

	}

}

```

### 11.5. 查询 Transaction Information

```

	public TransactionReceipt getTransactionReceipt(String transactionHash) throws InterruptedException, ExecutionException {
		EthGetTransactionReceipt ethGetTransactionReceipt = web3.ethGetTransactionReceipt(transactionHash).sendAsync().get();
		return ethGetTransactionReceipt.getResult();
	}			

```

执行返回结果

```

TransactionReceipt{
	transactionHash='0xece52bdbc6d4fa0c8eba7578a7c6e537883265199fa07ef8e5b1038e4bcdefb9', 
	transactionIndex='0x13', blockHash='0x2642b35670872a0e024d30ab2393b6bd4f7dab449bf4fc3eac067e2677cbc085', 
	blockNumber='0x344a79', cumulativeGasUsed='0x806f54', gasUsed='0x8fee', contractAddress='null', root='null', 
	status='0x1', from='0x22c57f0537414fd95b9f0f08f1e51d8b96f14029', to='0xb3cedc76e75fcd278c988b22963c2f35c99c10b7', l
	ogs=[Log{removed=false, logIndex='0xa', transactionIndex='0x13', transactionHash='0xece52bdbc6d4fa0c8eba7578a7c6e537883265199fa07ef8e5b1038e4bcdefb9', 
	blockHash='0x2642b35670872a0e024d30ab2393b6bd4f7dab449bf4fc3eac067e2677cbc085', blockNumber='0x344a79', 
	address='0xb3cedc76e75fcd278c988b22963c2f35c99c10b7', data='0x000000000000000000000000000000000000000000000000000000000000000a', 
	type='null', topics=[0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, 0x00000000000000000000000022c57f0537414fd95b9f0f08f1e51d8b96f14029, 0x000000000000000000000000cdf0253d8362d6c3334c8f28a6bfd74c90d03d92]}], 
	logsBloom='0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000008020000001000000000000000000000000000800000000000000000000000000000000000000000000000000000000010000000000000000000004000000000000000000000000000800000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000002000000000000000400000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
}

```

注意：该函数只能返回 TxReceipt Status: Success 状态数据，无法返回 Pending 状态的数据。

### 11.6. 交易结果查询

```

EthTransaction transaction = web3.ethGetTransactionByHash("TRANSACTION_HASH").sendAsync().get();
System.out.println(transaction.getResult());				

```

### 11.7. RawTransaction 编码与解码

```

		String hexTransaction = Numeric.toHexString(TransactionEncoder.encode(rawTransaction));
		RawTransaction tx1 = TransactionDecoder.decode(hexTransaction);			

```

## 12. 钱包

### 12.1. 创建钱包

```

package cn.netkiller.ethereum.wallet;

import java.io.File;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;

import org.web3j.crypto.CipherException;
import org.web3j.crypto.WalletUtils;

public class WalletMain {

	public void createWallet() throws NoSuchAlgorithmException, NoSuchProviderException,
			InvalidAlgorithmParameterException, CipherException, IOException {

		File file = new File("/tmp/ethereum/keystore");
		String password = "passw0rd";
		String fileName = WalletUtils.generateFullNewWalletFile(password, file);
		System.out.println(fileName);

	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		WalletMain wallet = new WalletMain();
		try {
			wallet.createWallet();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}

```

运行结果

```

neo@MacBook-Pro ~ % mkdir -p /tmp/ethereum/keystore
neo@MacBook-Pro ~ % ll /tmp/ethereum/keystore
total 8
-rw-r--r--  1 neo  wheel   491B Feb  4 18:30 UTC--2018-02-04T10-30-58.476000000Z--75d01e920d6e018445dae504058ce4d968fd2a58.json

neo@MacBook-Pro ~ % cat /tmp/ethereum/keystore/UTC--2018-02-04T10-30-58.476000000Z--75d01e920d6e018445dae504058ce4d968fd2a58.json 
{"address":"75d01e920d6e018445dae504058ce4d968fd2a58","id":"80700448-69bc-475a-aaf9-f2b836f17b13","version":3,"crypto":{"cipher":"aes-128-ctr","ciphertext":"fe86f5dbd61d15d092f9d6870e70bff7ed99a7925703ea71eef23669c8e3ec62","cipherparams":{"iv":"d058819ab660cd062080b405591ba143"},"kdf":"scrypt","kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"f69c535137b08667dbac53b8001313f5b43f81fce67a5d0e94b518c97d212d14"},"mac":"c247e34760bc838c3a4c8b2da286ccc6acec244bbc13fc6cc9ce28e88a7319d5"}}

```

### 12.2. 从钱包取出账号

```

package cn.netkiller.ethereum.wallet;

import java.io.File;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;

import org.web3j.crypto.CipherException;
import org.web3j.crypto.Credentials;
import org.web3j.crypto.WalletUtils;

public class WalletMain {

	public void walletAddress() throws IOException, CipherException {

		File file = new File(
				"/tmp/ethereum/keystore/UTC--2018-02-04T10-43-27.339000000Z--7cab470df532710d13078c5cdc0812a27f70cf51.json");
		String password = "passw0rd";
		Credentials credentials = WalletUtils.loadCredentials(password, file);
		System.out.println(credentials.getAddress());

	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		WalletMain wallet = new WalletMain();
		try {
			wallet.walletAddress();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}

```

运行结果

```

0x7cab470df532710d13078c5cdc0812a27f70cf51				

```

### 12.3. 生成助记词钱包

```

		String keystore = WalletUtils.getDefaultKeyDirectory();
		System.out.println("生成 keystore 文件的默认目录：" + keystore);
		// 通过密码及 keystore 目录生成钱包
		Bip39Wallet wallet = WalletUtils.generateBip39Wallet("yourpassword", new File(keystore));
		// keystore 文件名
		System.out.println(wallet.getFilename());
		// 12 个单词的助记词
		System.out.println(wallet.getMnemonic());			

```

### 12.4. 随机产生助记词

```

package cn.netkiller.example.ethereum.mnemonic;

import java.security.SecureRandom;
import org.web3j.crypto.MnemonicUtils;

public class MnemonicUtilsTest {

	public MnemonicUtilsTest() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {

		// TODO Auto-generated method stub
		byte[] initialEntropy = new byte[16];
		SecureRandom secureRandom = new SecureRandom();
		secureRandom.nextBytes(initialEntropy);

		String mnemonic = MnemonicUtils.generateMnemonic(initialEntropy);
		System.out.println(mnemonic);

	}

}

```

### 12.5. 导入 BIP39 钱包

```

		Credentials credentials = WalletUtils.loadBip39Credentials("password", "spoon crisp length scrub train scrap initial inherit airport that answer tornado");
		// 钱包地址
		System.out.println(credentials.getAddress());
		// 公钥 16 进制字符串表示
		System.out.println(credentials.getEcKeyPair().getPublicKey().toString(16));
		// 私钥 16 进制字符串表示
		System.out.println(credentials.getEcKeyPair().getPrivateKey().toString(16));			

```

## 13. 智能合约

```

neo@netkiller ~/ethereum/solidity % cat netkiller.sol 
pragma solidity ⁰.4.18;

contract Netkiller {
    string name;
    int num;
    function Netkiller() public{
        name = "default";
        num = 1;
    }
    function setName(string _name) public{
        name = _name;
    }
    function getName() public view returns(string){
        return name;
    }
    function setNum(int n) public{
        num = n;
    }
    function addNum(int m) public view returns(int res){
        res = m + num;
    }
}

```

编译智能合约

```

$ solc /path/to/<smart-contract>.sol --bin --abi --optimize -o output/
$ web3j solidity generate /path/to/<smart-contract>.bin /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name			

```

```

$ solc netkiller.sol --bin --abi --optimize -o output/
$ web3j solidity generate output/Netkiller.bin output/Netkiller.abi -p cn.netkiller.ethereum.contract -o java

              _      _____ _     _        
             | |    |____ (_)   (_)       
__      _____| |__      / /_     _   ___  
\ \ /\ / / _ \ '_ \     \ \ |   | | / _ \ 
 \ V  V /  __/ |_) |.___/ / | _ | || (_) |
  \_/\_/ \___|_.__/ \____/| |(_)|_| \___/ 
                         _/ |             
                        |__/              

Generating cn.netkiller.ethereum.contract.Netkiller ... File written to java	

neo@netkiller ~/ethereum/solidity % ll java/cn/netkiller/ethereum/contract/Netkiller.java 
-rw-rw-r-- 1 neo neo 5.9K Feb  3 23:02 java/cn/netkiller/ethereum/contract/Netkiller.java

```

启动以太坊，并开始挖矿。注意参数 --mine --minerthreads 1 ，你也可以启动后在 JavaScript 控制台钟启动挖矿。

```

neo@netkiller ~ % geth --networkid 123456 --rpc --rpcaddr="0.0.0.0" --rpccorsdomain "*" --mine --minerthreads 1	

```

```

package cn.netkiller.ethereum;

import java.math.BigInteger;

import org.web3j.crypto.Credentials;
import org.web3j.crypto.WalletUtils;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.http.HttpService;
import org.web3j.tx.Contract;
import org.web3j.tx.ManagedTransaction;

import cn.netkiller.ethereum.contract.Netkiller;

public class ContractTest {

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub

		String walletfile = "/Users/neo/Downloads/UTC--2018-01-20T04-04-06.786586541Z--83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6";

		Web3j web3j = Web3j.build(new HttpService("http://172.16.0.1:8545"));
		Credentials credentials = WalletUtils.loadCredentials("", walletfile);

		Netkiller contract = Netkiller.deploy(web3j, credentials, ManagedTransaction.GAS_PRICE, Contract.GAS_LIMIT).send();

		System.out.println(contract.isValid());
		if (contract.isValid()) {
			System.out.println("---");
			String contractAddress = contract.getContractAddress();
			System.out.println(contractAddress);
			System.out.println("---");
			String result = contract.getName().send();
			System.out.println(result);

			contract.setName("Netkiller").send();
			System.out.println(contract.getName().send());
			System.out.println("---");
			contract.setNum(BigInteger.valueOf(8)).send();
			System.out.println(contract.addNum(BigInteger.valueOf(8)).send());
			System.out.println("---");
		} else {
			System.out.println("Deploy ERROR !!!");
		}
	}

}

```

运行结果

```

true
---
0xef872f1b344a4b7c765c7d765a3cc82b741777a9
---
default
Netkiller
---
16
---

```

在程序运行是，去看 geth 打印的日志，有如下记录打印

```

INFO [02-04|00:04:43] Submitted transaction                    fullhash=0x9f70ccb600294d2dd6dda08d090362131b107d42a692f27dd4a3b7548dbaf22c recipient=0xEF872F1b344a4B7C765c7D765a3cC82b741777a9			

```

### 13.1. 载入合约

```

HelloWorld contract = HelloWorld.load(contractAddress,web3j,credentials, ManagedTransaction.GAS_PRICE, Contract.GAS_LIMIT);				

```

## 14. ERC20 合约

### 14.1. balanceOf

```

	@SuppressWarnings("rawtypes")
	public BigInteger getTokenBalance(String account, String contractAddress) throws InterruptedException, ExecutionException {
		Function function = new Function("balanceOf", Arrays.<Type>asList(new Address(account)), Arrays.<TypeReference<?>>asList(new TypeReference<Uint256>() {
		}));

		String encodedFunction = FunctionEncoder.encode(function);

		EthCall response = web3.ethCall(Transaction.createEthCallTransaction(account, contractAddress, encodedFunction), DefaultBlockParameterName.LATEST).sendAsync().get();

		List<Type> result = FunctionReturnDecoder.decode(response.getValue(), function.getOutputParameters());

		BigInteger balance = BigInteger.ZERO;
		if (result.size() == 1) {
			balance = (BigInteger) result.get(0).getValue();
		}
		return balance;
	}				

```

合约 balance 是不含小数点的，因为不同合约采用的小数点位数不同，无法使用以太坊单位直接换算。可以使用下面方法添加小数：

```

	public BigDecimal formatBalance(BigInteger balance, int decimal) {
		BigDecimal value = new BigDecimal(balance);
		value = value.divide(BigDecimal.TEN.pow(decimal));
		return value;
	}			

```

### 14.2. name

```

		 String methodName = "name"; 
		 String fromAddr = emptyAddress; 
		 List<Type> inputParameters = new ArrayList<>(); 
		 List<TypeReference<?>> outputParameters = new ArrayList<>(); 
		 TypeReference<Utf8String> typeReference = new TypeReference<Utf8String>() {}; outputParameters.add(typeReference);

		 Function function = new Function(methodName, inputParameters,outputParameters);

```

```

@SuppressWarnings("rawtypes")
	public String getName(String contractAddress) {
		String name = null;

		Function function = new Function("name", Arrays.<Type>asList(), Arrays.<TypeReference<?>>asList(new TypeReference<Utf8String>() {
		}));

		String data = FunctionEncoder.encode(function);
		Transaction transaction = Transaction.createEthCallTransaction(null, contractAddress, data);

		EthCall ethCall;
		try {
			ethCall = web3.ethCall(transaction, DefaultBlockParameterName.LATEST).sendAsync().get();
			List<Type> results = FunctionReturnDecoder.decode(ethCall.getValue(), function.getOutputParameters());
			name = results.get(0).getValue().toString();
		} catch (InterruptedException | ExecutionException e) {
			e.printStackTrace();
		}
		return name;
	}			

```

### 14.3. 合约转账

```

	@SuppressWarnings("rawtypes")
	public String sendTokenTransaction(String fromAddress, String password, String toAddress, BigInteger amount) {
		String txHash = null;

		try {

			PersonalUnlockAccount personalUnlockAccount = admin.personalUnlockAccount(fromAddress, password, BigInteger.valueOf(10)).send();
			if (personalUnlockAccount.accountUnlocked()) {
				String methodName = "transfer";
				List<Type> inputParameters = new ArrayList<>();
				List<TypeReference<?>> outputParameters = new ArrayList<>();

				Address tAddress = new Address(toAddress);

				Uint256 value = new Uint256(amount);
				inputParameters.add(tAddress);
				inputParameters.add(value);

				TypeReference<Bool> typeReference = new TypeReference<Bool>() {
				};
				outputParameters.add(typeReference);

				Function function = new Function(methodName, inputParameters, outputParameters);

				String data = FunctionEncoder.encode(function);

				EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(fromAddress, DefaultBlockParameterName.PENDING).sendAsync().get();
				BigInteger nonce = ethGetTransactionCount.getTransactionCount();
				BigInteger gasPrice = Convert.toWei(BigDecimal.valueOf(5), Convert.Unit.GWEI).toBigInteger();

				Transaction transaction = Transaction.createFunctionCallTransaction(fromAddress, nonce, gasPrice, BigInteger.valueOf(60000), this.contractAddress, data);

				EthSendTransaction ethSendTransaction = web3.ethSendTransaction(transaction).sendAsync().get();
				txHash = ethSendTransaction.getTransactionHash();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		return txHash;
	}

```

### 14.4. 完整的 ERC20 代币开发库

这是一个万能的代币接口，只要知道合约地址，即可操作该合约。传统做法是使用 web3j 命令将 .sol 编译成 Java Class 但这种类只能操作自己的合约。

```

package cn.netkiller.wallet.ethereum;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.concurrent.ExecutionException;

import org.web3j.protocol.core.methods.request.Transaction;
import org.web3j.protocol.core.methods.response.TransactionReceipt;
import org.web3j.tx.Contract;

public class TestToken {

	public TestToken() {
		// TODO Auto-generated constructor stub
	}

	@SuppressWarnings("deprecation")
	public static void main(String[] args) {
		// TODO Auto-generated method stub

		try {
			Token token = new Token("0xb3cedc76e75fcd278c988b22963c2f35c99c10b7", "166970EDB022C717B3ECCADAB6558537228FFBDE1F68AC063A06790967F2BC3A");
			String owner = token.getOwner();
			System.out.println("代币创建者：" + owner);

			String name = token.getName();
			System.out.println("代币名称：" + name);

			String symbol = token.getSymbol();
			System.out.println("代币符号：" + symbol);

			int decimal = token.getDecimals();
			System.out.println("小数位数：" + decimal);

			BigInteger totalSupply = token.getTotalSupply();
			System.out.println("发行总量：" + totalSupply);

			BigInteger tokenBalance = token.getTokenBalance("0x22c57F0537414FD95b9f0f08f1E51d8b96F14029");
			System.out.println("代币余额:" + tokenBalance);

			BigDecimal val = token.formatBalance(tokenBalance, decimal);
			System.out.println("格式化后：" + val);

			String transactionHash = token.sendTransaction("0xCdF0253d8362d6c3334c8F28A6BFd74c90d03d92", BigInteger.valueOf(10));
			System.out.println("代币转账：" + transactionHash);
			TransactionReceipt transactionReceipt = token.getTransactionReceipt("0xece52bdbc6d4fa0c8eba7578a7c6e537883265199fa07ef8e5b1038e4bcdefb9");
			System.out.println("转账状态：" + transactionReceipt.toString());

			String hash = token.setApprove("0xCdF0253d8362d6c3334c8F28A6BFd74c90d03d92", BigInteger.valueOf(100));
			System.out.println("设置授信：" + hash);

			BigInteger value = token.getAllowance("0x22c57F0537414FD95b9f0f08f1E51d8b96F14029", "0xCdF0253d8362d6c3334c8F28A6BFd74c90d03d92");
			System.out.println("查询授信：" + value);

			Token token1 = new Token("0xb3cedc76e75fcd278c988b22963c2f35c99c10b7", "8D160B668E63CC04CEE44C398C184121D63C3F5D189671D985A6FB3719FB1B5E");
			System.out.println("授信转出：" + token1.sendTransactionFrom("0x22c57F0537414FD95b9f0f08f1E51d8b96F14029", "0xCdF0253d8362d6c3334c8F28A6BFd74c90d03d92", BigInteger.valueOf(20)));

			// System.out.println(token1.getAllowance("0x22c57F0537414FD95b9f0f08f1E51d8b96F14029", "0xCdF0253d8362d6c3334c8F28A6BFd74c90d03d92"));
		} catch (InterruptedException | ExecutionException | IOException e) {
			e.printStackTrace();

		}

	}

}

```

运行结果

```

代币创建者：0x22c57f0537414fd95b9f0f08f1e51d8b96f14029
代币名称：Netkiller Test Coin
代币符号：NTC
小数位数：4
发行总量：1000000000000
代币余额:999999999430
格式化后：99999999.943
代币转账：0xe851f682457672f2ca5ddbc3ad276dd9fa56ea81e838cf9a4b1eb8c97d0d98fd
转账状态：TransactionReceipt{transactionHash='0xece52bdbc6d4fa0c8eba7578a7c6e537883265199fa07ef8e5b1038e4bcdefb9', transactionIndex='0x13', blockHash='0x2642b35670872a0e024d30ab2393b6bd4f7dab449bf4fc3eac067e2677cbc085', blockNumber='0x344a79', cumulativeGasUsed='0x806f54', gasUsed='0x8fee', contractAddress='null', root='null', status='0x1', from='0x22c57f0537414fd95b9f0f08f1e51d8b96f14029', to='0xb3cedc76e75fcd278c988b22963c2f35c99c10b7', logs=[Log{removed=false, logIndex='0xa', transactionIndex='0x13', transactionHash='0xece52bdbc6d4fa0c8eba7578a7c6e537883265199fa07ef8e5b1038e4bcdefb9', blockHash='0x2642b35670872a0e024d30ab2393b6bd4f7dab449bf4fc3eac067e2677cbc085', blockNumber='0x344a79', address='0xb3cedc76e75fcd278c988b22963c2f35c99c10b7', data='0x000000000000000000000000000000000000000000000000000000000000000a', type='null', topics=[0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef, 0x00000000000000000000000022c57f0537414fd95b9f0f08f1e51d8b96f14029, 0x000000000000000000000000cdf0253d8362d6c3334c8f28a6bfd74c90d03d92]}], logsBloom='0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000008020000001000000000000000000000000000800000000000000000000000000000000000000000000000000000000010000000000000000000004000000000000000000000000000800000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000002000000000000000400000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'}
设置授信：0x2a6c32b5939de91d9f06f7b73913433ee0b28642a3afc095454a7dcd59da3234
查询授信：100
授信转出：0x29f4824b35c47a0fc18adf2d8c72c902a3c518f249bc4235aace804e5a9f17df			

```

如需代码，有偿提供，请联系作者。

## 15. Infura

```

package cn.netkiller.ethereum.infura;

import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;
import org.web3j.protocol.http.HttpService;

public class Infura {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		try {
			Web3j web3 = Web3j.build(new HttpService("https://rinkeby.infura.io/CsS9shwaAab0z7B4LP2d"));
			Web3ClientVersion web3ClientVersion = web3.web3ClientVersion().send();
			System.out.println(web3ClientVersion.getWeb3ClientVersion());
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

```

## 16. 助记词

### 16.1. 获取随机助记词

```

package cn.netkiller.ethereum.mnemonic;

import java.io.IOException;
import java.security.SecureRandom;
import java.util.List;

import org.bitcoinj.wallet.DeterministicSeed;
import org.bitcoinj.wallet.UnreadableWalletException;

public class MnemonicTest {
	public static void main(String[] args) throws UnreadableWalletException, IOException {
		// TODO Auto-generated method stub

		String passphrase = "";
		SecureRandom secureRandom = new SecureRandom();
		long creationTimeSeconds = System.currentTimeMillis() / 1000;
		DeterministicSeed deterministicSeed = new DeterministicSeed(secureRandom, 128, passphrase, creationTimeSeconds);
		List<String> mnemonicCode = deterministicSeed.getMnemonicCode();
		System.out.println(String.join(" ", mnemonicCode));

	}
}

```

输出

```

romance rhythm session oyster upgrade include hammer chimney float bridge autumn accident

```

### 16.2. 助记词导出公钥和私钥

```

package cn.netkiller.ethereum.mnemonic;

import java.math.BigInteger;
import java.util.List;

import org.bitcoinj.crypto.ChildNumber;
import org.bitcoinj.crypto.DeterministicKey;
import org.bitcoinj.crypto.HDUtils;
import org.bitcoinj.wallet.DeterministicKeyChain;
import org.bitcoinj.wallet.DeterministicSeed;
import org.bitcoinj.wallet.UnreadableWalletException;
import org.web3j.crypto.Credentials;

public class Test {

	public static void main(String[] args) throws UnreadableWalletException {
		// TODO Auto-generated method stub
		String seedCode = "client dune unfair assume level width bind control mad member old crystal";

		// BitcoinJ
		DeterministicSeed seed = new DeterministicSeed(seedCode, null, "", 1409478661L);
		DeterministicKeyChain chain = DeterministicKeyChain.builder().seed(seed).build();
		List<ChildNumber> keyPath = HDUtils.parsePath("M/44H/60H/0H/0/0");
		DeterministicKey key = chain.getKeyByPath(keyPath, true);
		BigInteger privKey = key.getPrivKey();

		// Web3j

		Credentials credentials = Credentials.create(privKey.toString(16));
		String address = credentials.getAddress();
		String privateKey = privKey.toString(16);
		System.out.println(address);
		System.out.println(privateKey);
	}
}			

```

输出

```

0x372fda02e8a1eca513f2ee5901dc55b8b5dd7411
f592b7bf06ca9fd7696ba95d6ed8e357de6a2379b6d5fe1ffd53c6b4b063cd4a

```

## 17. 过滤器 (Filter)

## 18. Subscription

在区块链上发生的事件时，能不通知到订阅事件者。

### 提示

主意 https://docs.web3j.io/filters.html 有一段话：

Note: filters are not supported on Infura.

目前 Infura 不支持。

### 18.1. 接收所有添加到区块链的新区块

```

Subscription subscription = web3j.blockObservable(false).subscribe(block -> {
    ...
});

```

### 18.2. 接收所有添加到区块链的新交易

```

Subscription subscription = web3j.transactionObservable().subscribe(tx -> {
    ...
});

```

### 18.3. 接收所有待处理的事务

```

Subscription subscription = web3j.pendingTransactionObservable().subscribe(tx -> {
    ...
});

```

测试环境 Mac, 首先启动 Ethereum Wallet，然后启动下面程序，回到 Ethereum Wallet 中做一笔转账。

```

package cn.netkiller.example.ethereum.subscription;

import org.web3j.protocol.Web3j;
import org.web3j.protocol.ipc.UnixIpcService;

import rx.Subscription;

public class PendingTest {

	public PendingTest() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("Subscription Starting...");
		Web3j web3 = Web3j.build(new UnixIpcService("/Users/neo/Library/Ethereum/geth.ipc"));
		Subscription subscription = web3.pendingTransactionObservable().subscribe(block -> {
			// System.out.println(block.toString());
			System.out.println("block number: " + block.getBlockHash());
		});
		// subscription.unsubscribe();
	}

}

```

输出

```

block number: 0x74f7dd053dadcf01599dc85d4abf60662695e78ce7531335f44dc03f49dee326

```

### 18.4. 将区块块重放到当前的当前位置

```

Subscription subscription = catchUpToLatestAndSubscribeToNewBlocksObservable(
        <startBlockNumber>, <fullTxObjects>)
        .subscribe(block -> {
            ...
});

作者：ChainBoard 链博科技
链接：https://www.jianshu.com/p/c7c5556a436b
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。			

```

### 18.5. 过滤主题

```

EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST, <contract-address>).addSingleTopic(...)|.addOptionalTopics(..., ...)|...;

web3j.ethLogObservable(filter).subscribe(log -> {
    ...
});		

```

### 18.6. 停止订阅 Subscriptions

```

subscription.unsubscribe();

```

### 18.7. 

```

Web3j web3 = Web3j.build(new HttpService("http://127.0.0.1:8080"));
        System.out.println("Connected to Ethereum client version: "
                + web3.toString());
        subscription = web3.blockObservable(false)
                .subscribe(tx -> {
                    System.out.println("observation tx:" + tx.getRawResponse());
                });
        txSubscription = web3.transactionObservable().subscribe((tx) -> {
            System.out.println("txSubscription hash:" + tx.getHash() + ":::::address:" + tx.getTo());
            if (!ValidationUtil.isEmpty(tx.getTo())) {
                System.out.println("getBlockNumber:" + tx.getBlockNumber().longValue());
                System.out.println("getValue:" + tx.getValue());
                System.out.println("getTo:" + tx.getTo());
                System.out.println("getFrom:" + tx.getFrom());
                System.out.println("getHash:" + tx.getHash());
            }
        });
        pendingSubscription = web3.pendingTransactionObservable().subscribe(tx -> {
            System.out.println("pending hash:" + tx.getHash() + ":::::address:" + tx.getTo());
        });
        latestSubscription = web3.catchUpToLatestTransactionObservable(new DefaultBlockParameterNumber(2576860)).subscribe(block ->
                System.out.println("*+observer+getblock" + block.getBlockNumber())
        );			

```

## 19. 解锁账号

```

Admin admin = Admin.build(new HttpService());  // defaults to http://localhost:8545/
PersonalUnlockAccount personalUnlockAccount = admin.personalUnlockAccount("0x000...", "a password").sendAsync().get();
if (personalUnlockAccount.accountUnlocked()) {
    // send a transaction
}		

```

## 20. IBAN (International Bank Account Number)

[`github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol`](https://github.com/ethereum/wiki/wiki/ICAP:-Inter-exchange-Client-Address-Protocol)

```

iban:XE4214YF25M7C0Q6QFUF989GYBCR29987SX?amount=100&token=ETH	

```

[`github.com/arturmkrtchyan/iban4j`](https://github.com/arturmkrtchyan/iban4j)

## 21. Springboot with Ethereum (web3j)

### 21.1. Maven

```

		<dependency>
			<groupId>org.web3j</groupId>
			<artifactId>web3j-spring-boot-starter</artifactId>
			<version>1.6.0</version>
		</dependency>			

```

### 21.2. application.properties

```

web3j.client-address=https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d
web3j.admin-client=true			

```

### 21.3. TestRestController

```

package cn.netkiller.wallet.restful;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;

@RestController
public class TestRestController {
	private static final Logger logger = LoggerFactory.getLogger(TestRestController.class);

	@Autowired
	private Web3j web3j;

	public TestRestController() {
		// TODO Auto-generated constructor stub
	}

	@GetMapping("/version")
	public String version() throws IOException {
		Web3ClientVersion web3ClientVersion = web3j.web3ClientVersion().send();
		String clientVersion = web3ClientVersion.getWeb3ClientVersion();
		logger.info(clientVersion);
		return clientVersion;
	}

}

```

### 21.4. 测试

```

neo@MacBook-Pro ~ % curl http://localhost:8080/version
Geth/v1.8.3-stable/linux-amd64/go1.10

```

## 第 18 章 web3.py - A python interface for interacting with the Ethereum blockchain and ecosystem.

文档地址 [`web3py.readthedocs.io/`](http://web3py.readthedocs.io/)

## 1. 安装 web3.py 开发环境

### 1.1. CentOS

```

[root@iZj6c39y62jl5b1wmfv6u8Z ~]# yum install python34-pip

[root@iZj6c39y62jl5b1wmfv6u8Z ~]# pip3 install --upgrade pip
Collecting pip
  Downloading http://mirrors.aliyun.com/pypi/packages/0f/74/ecd13431bcc456ed390b44c8a6e917c1820365cbebcb6a8974d1cd045ab4/pip-10.0.1-py2.py3-none-any.whl (1.3MB)
    100% |████████████████████████████████| 1.3MB 68.9MB/s 
Installing collected packages: pip
  Found existing installation: pip 8.1.2
    Uninstalling pip-8.1.2:
      Successfully uninstalled pip-8.1.2
Successfully installed pip-10.0.1

```

```

python3.6 -m venv env --without-pip
source env/bin/activate
curl https://bootstrap.pypa.io/get-pip.py | python3
python3.6 -m pip install web3			

```

### 1.2. MAC OS

首先去 python.org 官网下载 Python 3.6.5 dmg 格式，安装后进入终端。

```

You should consider upgrading via the 'pip install --upgrade pip' command.
neo@MacBook-Pro ~/ethereum/web3.py % pip3.6 install --upgrade pip
Cache entry deserialization failed, entry ignored
Collecting pip
  Using cached https://files.pythonhosted.org/packages/0f/74/ecd13431bcc456ed390b44c8a6e917c1820365cbebcb6a8974d1cd045ab4/pip-10.0.1-py2.py3-none-any.whl
Installing collected packages: pip
  Found existing installation: pip 9.0.3
    Uninstalling pip-9.0.3:
      Successfully uninstalled pip-9.0.3
Successfully installed pip-10.0.1

neo@MacBook-Pro ~/ethereum/web3.py % pip3.6 install web3

```

## 2. 连接到以太坊节点

### 2.1. HTTP

```

>>> from web3 import Web3
>>> web3 = Web3(Web3.HTTPProvider("http://127.0.0.1:8545")

```

### 2.2. IPC

```

>>> from web3 import Web3
>>> web3 = Web3(Web3.IPCProvider("~/Library/Ethereum/geth.ipc"))	

```

### 2.3. Websocket

```

>>> from web3 import Web3
>>> web3 = Web3(Web3.WebsocketProvider("ws://127.0.0.1:8546")			

```

## 3. 交易

### 3.1. 发送 ETH

```

from web3 import Web3
web3 = Web3(Web3.IPCProvider("~/Library/Ethereum/geth.ipc"))	

fromAddress = '0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA'
toAddress = '0x997e5CA600E19447D0B82aFBf9c7F00De2B39B16'
value = 0.0001

web3.personal.unlockAccount(fromAddress, '12345678')
web3.eth.sendTransaction({'to': toAddress, 'from': fromAddress, 'value': value})

```

### 3.2. 签名发送 ETH

```

from web3 import Web3
web3 = Web3(Web3.HTTPProvider("https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d"))	

privateKey = '8D16063C3F665A6FB37195D18968E63CC04CEE4BFB1B98C184121D4C31D9875E'
fromAddress = "0xb3cedc76e75fcd278c988b22963c2f35c99c10b7"
toAddress = '0x997e5CA600E19447D0B82aFBf9c7F00De2B39B16'
amount = 0.0001

signed_txn = web3.eth.account.signTransaction(dict(
    nonce=web3.eth.getTransactionCount(fromAddress),
    gasPrice=web3.eth.gasPrice,
    gas=21000,
    to=toAddress,
    value=amount,
    data=b'',
  ),
  private_key,
)
web3.eth.sendRawTransaction(signed_txn.rawTransaction)

```

## 4. ERC20 代币合约

```

from web3 import Web3
web3 = Web3(Web3.HTTPProvider("https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d"))	

contract = web3.eth.contract(address='0x000000000000000000000000000000000000dead', abi=...)

contract.functions.balanceOf(address).call()

contract.functions.transfer(to, value).call()

```

### 4.1. 签名发送 ERC20 代币

```

from web3 import Web3
from web3 import Web3, HTTPProvider, IPCProvider
# w3 = Web3(Web3.IPCProvider("~/Library/Ethereum/geth.ipc"))	

w3 = Web3(HTTPProvider("https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d"))

fromAddress = '0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7'
toAddress = '0xCdF0253d8362d6c3334c8F28A6BFd74c90d03d92'
contractAddress='0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359'
private_key = b''

# '~/.ethereum/testnet/keystore/UTC--2018-03-02T12-12-51.966823000Z--b94054c174995ae2a9e7fcf6c7924635fba8ecf7'
with open('/Users/neo/Library/Ethereum/testnet/keystore/UTC--2018-03-02T12-12-51.966823000Z--b94054c174995ae2a9e7fcf6c7924635fba8ecf7') as keyfile:
    encrypted_key = keyfile.read()
    private_key = w3.eth.account.decrypt(encrypted_key, '')

print(private_key)

interface='[ { "constant": true, "inputs": [], "name": "name", "outputs": [ { "name": "", "type": "string" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_spender", "type": "address" }, { "name": "_value", "type": "uint256" } ], "name": "approve", "outputs": [ { "name": "success", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "name": "success", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [ { "name": "", "type": "uint8" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_value", "type": "uint256" } ], "name": "burn", "outputs": [ { "name": "success", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [ { "name": "", "type": "address" } ], "name": "balanceOf", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_from", "type": "address" }, { "name": "_value", "type": "uint256" } ], "name": "burnFrom", "outputs": [ { "name": "success", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [ { "name": "", "type": "string" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [ { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" } ], "name": "transfer", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [ { "name": "_spender", "type": "address" }, { "name": "_value", "type": "uint256" }, { "name": "_extraData", "type": "bytes" } ], "name": "approveAndCall", "outputs": [ { "name": "success", "type": "bool" } ], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [ { "name": "", "type": "address" }, { "name": "", "type": "address" } ], "name": "allowance", "outputs": [ { "name": "", "type": "uint256" } ], "payable": false, "stateMutability": "view", "type": "function" }, { "inputs": [ { "name": "initialSupply", "type": "uint256", "index": 0, "typeShort": "uint", "bits": "256", "displayName": "initial Supply", "template": "elements_input_uint", "value": "100000" }, { "name": "tokenName", "type": "string", "index": 1, "typeShort": "string", "bits": "", "displayName": "token Name", "template": "elements_input_string", "value": "NEO" }, { "name": "tokenSymbol", "type": "string", "index": 2, "typeShort": "string", "bits": "", "displayName": "token Symbol", "template": "elements_input_string", "value": "#" } ], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [ { "indexed": true, "name": "from", "type": "address" }, { "indexed": true, "name": "to", "type": "address" }, { "indexed": false, "name": "value", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "name": "from", "type": "address" }, { "indexed": false, "name": "value", "type": "uint256" } ], "name": "Burn", "type": "event" } ]'
contract = w3.eth.contract(address=contractAddress, abi=interface)

nonce = w3.eth.getTransactionCount(fromAddress)
print(nonce)

txn = contract.functions.transfer(toAddress,5,).buildTransaction({
    'chainId': 3,
    'gas': 30000,
    'gasPrice': w3.toWei('1', 'gwei'),
    'nonce': nonce,
    })

print(txn)

signed_txn = w3.eth.account.signTransaction(txn, private_key=private_key)
print(signed_txn.hash)
print(signed_txn.rawTransaction)

tmp = w3.eth.sendRawTransaction(signed_txn.rawTransaction)  

txhash = w3.toHex(w3.sha3(signed_txn.rawTransaction))

print("https://ropsten.etherscan.io/tx/"+txhash)		

```

## 第 19 章 Ethereum iOS

[`github.com/MercuryProtocol/web3.swift`](https://github.com/MercuryProtocol/web3.swift)

https://medium.com/mercuryprotocol/introducing-web3-swift-for-ethereum-ios-development-1e02212b662b

## 第 20 章 Ethereum Developer APIs

## 1. API Keys

https://etherscan.io/register

| ![](img/newaccount.png) |

前往邮箱查看以太坊发出的确认邮件，并点击里面链接地址。

| ![](img/email.png) |

登陆

| ![](img/login.png) |

创建 API Key

| ![](img/api-keys-create.png) |

| ![](img/api-keys-token.png) |

创建完成

| ![](img/api-keys-successfully.png) |

## 2. 账号

### 2.1. 余额

获得账号的余额

```

https://api.etherscan.io/api?module=account&action=balance&address=0xddbd2b932c763ba5b1b7ae3b362eac3e8d40121a&tag=latest&apikey=JFZWPE88I3TZFZWXKVHJ32INUIYQRRINJ9

```

### 2.2. 查询区块

```

http://api.etherscan.io/api?module=account&action=txlist&address=0x3e827461Cc53ed7c75A29187CfF39629FCAE3661&startblock=0&endblock=99999999&sort=asc&apikey=RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N

```

Spring boot 2.0.2 实现交易记录查询

```

package cn.netkiller.api.restful;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class TransactionsRestController {
	private static final Logger logger = LoggerFactory.getLogger(TransactionsRestController.class);

	private static final String url = "http://api.etherscan.io/api?module={module}&action={action}&address={address}&startblock={startblock}&endblock={endblock}&sort={sort}&apikey={apikey}";

	@Autowired
	public TestRestController() {
		// TODO Auto-generated constructor stub
	}

	@GetMapping("/block/{startblock}/{endblock}/{address}")
	public TransactionsResponse block(@PathVariable String startblock, @PathVariable String endblock, @PathVariable String address) {
		return this.getTransactionsByAddress(startblock, endblock, address);
	}

	private TransactionsResponse getTransactionsByAddress(String startblock, String endblock, String address) {
		Map<String, String> params = new HashMap<String, String>();
		params.put("module", "account");
		params.put("action", "txlist");
		params.put("address", address);
		params.put("startblock", startblock);
		params.put("endblock", endblock);
		params.put("sort", "asc");
		params.put("apikey", "RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N");
		RestTemplate restTemplate = new RestTemplate();
		TransactionsResponse result = restTemplate.getForObject(url, TransactionsResponse.class, params);
		logger.info(params.toString());
		logger.info(result.toString());
		return result;
	}
}

class Transactions {

	private String blockNumber;
	private String timeStamp;
	private String hash;
	private String nonce;
	private String blockHash;
	private String transactionIndex;
	private String from;
	private String to;
	private String value;
	private String gas;
	private String gasPrice;
	private String isError;
	private String txreceipt_status;
	private String input;
	private String contractAddress;
	private String cumulativeGasUsed;
	private String gasUsed;
	private String confirmations;

	public Transactions() {
	}

	public String getBlockNumber() {
		return blockNumber;
	}

	public void setBlockNumber(String blockNumber) {
		this.blockNumber = blockNumber;
	}

	public String getTimeStamp() {
		return timeStamp;
	}

	public void setTimeStamp(String timeStamp) {
		this.timeStamp = timeStamp;
	}

	public String getHash() {
		return hash;
	}

	public void setHash(String hash) {
		this.hash = hash;
	}

	public String getNonce() {
		return nonce;
	}

	public void setNonce(String nonce) {
		this.nonce = nonce;
	}

	public String getBlockHash() {
		return blockHash;
	}

	public void setBlockHash(String blockHash) {
		this.blockHash = blockHash;
	}

	public String getTransactionIndex() {
		return transactionIndex;
	}

	public void setTransactionIndex(String transactionIndex) {
		this.transactionIndex = transactionIndex;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}

	public String getTo() {
		return to;
	}

	public void setTo(String to) {
		this.to = to;
	}

	public String getValue() {
		return value;
	}

	public void setValue(String value) {
		this.value = value;
	}

	public String getGas() {
		return gas;
	}

	public void setGas(String gas) {
		this.gas = gas;
	}

	public String getGasPrice() {
		return gasPrice;
	}

	public void setGasPrice(String gasPrice) {
		this.gasPrice = gasPrice;
	}

	public String getIsError() {
		return isError;
	}

	public void setIsError(String isError) {
		this.isError = isError;
	}

	public String getTxreceipt_status() {
		return txreceipt_status;
	}

	public void setTxreceipt_status(String txreceipt_status) {
		this.txreceipt_status = txreceipt_status;
	}

	public String getInput() {
		return input;
	}

	public void setInput(String input) {
		this.input = input;
	}

	public String getContractAddress() {
		return contractAddress;
	}

	public void setContractAddress(String contractAddress) {
		this.contractAddress = contractAddress;
	}

	public String getCumulativeGasUsed() {
		return cumulativeGasUsed;
	}

	public void setCumulativeGasUsed(String cumulativeGasUsed) {
		this.cumulativeGasUsed = cumulativeGasUsed;
	}

	public String getGasUsed() {
		return gasUsed;
	}

	public void setGasUsed(String gasUsed) {
		this.gasUsed = gasUsed;
	}

	public String getConfirmations() {
		return confirmations;
	}

	public void setConfirmations(String confirmations) {
		this.confirmations = confirmations;
	}

	@Override
	public String toString() {
		return "Transactions [blockNumber=" + blockNumber + ", timeStamp=" + timeStamp + ", hash=" + hash + ", nonce=" + nonce + ", blockHash=" + blockHash + ", transactionIndex=" + transactionIndex + ", from=" + from + ", to=" + to + ", value=" + value + ", gas=" + gas + ", gasPrice=" + gasPrice + ", isError=" + isError + ", txreceipt_status=" + txreceipt_status + ", input=" + input + ", contractAddress=" + contractAddress + ", cumulativeGasUsed=" + cumulativeGasUsed + ", gasUsed=" + gasUsed + ", confirmations=" + confirmations + "]";
	}

}

class TransactionsResponse {
	private String status;
	private String message;
	private List<Transactions> result = new ArrayList<Transactions>();

	public TransactionsResponse() {
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public List<Transactions> getResult() {
		return result;
	}

	public void setResult(List<Transactions> result) {
		this.result = result;
	}

	@Override
	public String toString() {
		return "TransactionsResponse [status=" + status + ", message=" + message + ", result=" + result + "]";
	}

}			

```

### 2.3. 查询区块

```

http://api.etherscan.io/api?module=account&action=txlistinternal&address=0x3e827461Cc53ed7c75A29187CfF39629FCAE3661&startblock=0&endblock=99999999&sort=asc&apikey=RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N			

```

## 3. 查询交易

### 3.1. 检查合约执行状态

```

https://api.etherscan.io/api?module=transaction&action=getstatus&txhash=0x6cec54f03e6d9271f2c51e0696de03df4bba82171f2aff464c63554614915500&apikey=RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N

```

## 4. Geth/Parity Proxy APIs

### 4.1. 

```

https://api.etherscan.io/api?module=proxy&action=eth_blockNumber&apikey=RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N			

```

```

	private String getBlockNumber() {
		final String url = "https://api.etherscan.io/api?module=proxy&action=eth_blockNumber&apikey=RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N";
		Map<String, String> params = new HashMap<String, String>();
		params.put("module", "proxy");
		params.put("action", "eth_blockNumber");
		params.put("apikey", "RT5JW37AKEZVSW3C91Z86IGI2FF7JDPF1N");
		RestTemplate restTemplate = new RestTemplate();
		JsonRpc result = restTemplate.getForObject(url, JsonRpc.class, params);

		return Integer.valueOf(result.getResult().substring(2), 16).toString();
	}			

```

## 5. JSON RPC 原生交口调用

JSON RPC 文档 [`github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getlogs)

```

neo@MacBook-Pro ~ % curl -XPOST -H "Accept: application/json" -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"eth_getBalance","params":["0x5c18a33df2cc41a1beddc91133b8422e89f041b7", "latest"],"id":1}' http://localhost:8545 
{"jsonrpc":"2.0","id":1,"result":"0x153e5f3aeb667075800"}		

```

```

curl -X POST --data '{"jsonrpc":"2.0","method":"eth_accounts","params":[],"id":1}'		

curl -X POST --data '{"jsonrpc":"2.0","method":"eth_getBalance","params":["0x407d73d8a49eeb85d32cf465507dd71d507100c1", "latest"],"id":1}'

```

## 第 21 章 infura

[`infura.io/`](https://infura.io/)

SCALABLE BLOCKCHAIN INFRASTRUCTURE

We provide secure, reliable, and scalable access to Ethereum and IPFS.

## 1. Infura 3.0

注册 Infura 3.0

| ![](img/infura-1.png) |

邮件确认

| ![](img/infura-2.png) |

登录

| ![](img/infura-3.png) |

点击 SKIP 按钮，跳过教学模式

| ![](img/infura-4.png) |

创建项目

| ![](img/infura-5.png) |

输入项目名称

| ![](img/infura-6.png) |

添加合约到白名单

| ![](img/infura-7.png) |

添加完成

| ![](img/infura-8.png) |

复制 Infura 地址:

```

https://mainnet.infura.io/v3/ee07e33cb6414781a72deaf3b303ca3b
https://ropsten.infura.io/v3/ee07e33cb6414781a72deaf3b303ca3b

```

## 2. websocket

```

wss://mainnet.infura.io/ws
wss://ropsten.infura.io/ws
wss://rinkeby.infura.io/ws

```

### 2.1. 订阅 newBlockHeaders

```

#!/usr/bin/env node
const Web3 = require('web3');

const web3 = new Web3(new Web3.providers.WebsocketProvider('wss://mainnet.infura.io/ws'));

const subscription = web3.eth.subscribe('newBlockHeaders', (error, blockHeader) => {
  if (error) return console.error(error);

  console.log('Successfully subscribed!', blockHeader);
}).on('data', (blockHeader) => {
  console.log('data: ', blockHeader);
});

// unsubscribes the subscription
subscription.unsubscribe((error, success) => {
  if (error) return console.error(error);

  console.log('Successfully unsubscribed!');
});			

```

## 3. 配置 Truffle

安装 truffle-hdwallet-provider

```

$ npm install truffle-hdwallet-provider			

```

修改 truffle.js 文件

```

var HDWalletProvider = require("truffle-hdwallet-provider"); 

// infura 为你提供的 apikey 请与你申请到的 key 保持一致
var infura_apikey = "CsS9shwaAab0z7B4LP2d";

// 你以太坊钱包地址 进入 MetaMask -> Settings -> reveal seed words 复制到此处
var mnemonic = "drill hunt food team moment mistake bird attitude tunnel ecology sister resist"; 

module.exports = {
  networks: {
    development: {
      host: "127.0.0.1",
      port: 7545,
      network_id: "*"
    },
    private: {
      host: "localhost",
      port: 8545,
      network_id: "*" // Match any network id
    },
    ropsten: {
      provider: new HDWalletProvider(mnemonic, "https://ropsten.infura.io/"+infura_apikey),
      network_id: 3,
      gas: 3012388,
      gasPrice: 30000000000
    },
    main: {
      provider: new HDWalletProvider(mnemonic, "https://mainnet.infura.io/"+infura_apikey),
      network_id: 3,
      gas: 3012388,
      gasPrice: 1000000000
    }
  }
};

```

部署合约到 ropsten 测试网， 在命令行输入如下命令，通过 --network 设置发布的目标网络：

```

truffle migrate --network ropsten			

```

主网络发布

```

truffle migrate --network main

```

## 4. infura.io web3.js 开发

### 4.1. Web3 通过 infura 连接到 Ropsten 测试网络

```

fs = require('fs');
const Web3 = require('web3');
const web3 = new Web3('https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d');
console.log(web3.version)
const abi = fs.readFileSync('output/TokenERC20.abi', 'utf-8');

const contractAddress = "0x70682386d0dE84B1e549DC3c4305CCB2D261b2a8";
const coinbase = "0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7";
const toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";

balanceWei = web3.eth.getBalance(coinbase);
console.log(balanceWei);

const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});

contract.methods.balanceOf(coinbase).call().then(console.log).catch(console.error);
contract.methods.balanceOf(toAddress).call().then(console.log).catch(console.error);	

```

### 4.2. 使用 truffle-hdwallet-provider 连接到 https://ropsten.infura.io

```

fs = require('fs');
const Web3 = require('web3');
const HDWalletProvider = require("truffle-hdwallet-provider");
const mnemonic = "drill hunt food team moment mistake bird attitude tunnel ecology sister resist";
const web3 = new Web3(new HDWalletProvider(mnemonic,'https://ropsten.infura.io/CsS8shwaCab0a7B4LP2d'));
console.log(web3.version)
const abi = fs.readFileSync('output/TokenERC20.abi', 'utf-8');

const contractAddress = "0x70682386d0dE84B1e549DC3c4305CCB2D261b2a8";
const coinbase = "0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7";
const toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";

balanceWei = web3.eth.getBalance(coinbase);
console.log(balanceWei);

const contract = new web3.eth.Contract(JSON.parse(abi), contractAddress, { from: coinbase , gas: 100000});

contract.methods.balanceOf(coinbase).call().then(console.log).catch(console.log);
contract.methods.balanceOf(toAddress).call().then(console.log).catch(console.log);

```

### 4.3. 转账

```

	const coinbase = "0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7";
	const toAddress = "0xf56b81a2bcb964D2806071e9Be4289A5559BB0fA";			
	const privateKey = "e33ea581d88e0bd2270c0fd109604039a3de59671b6d69882b4cb4688d3dcffd"

	var nonce = await web3.eth.getTransactionCount(coinbase);
	var gasPrice = await web3.eth.getGasPrice();
	console.log(`gasPrice: ${gasPrice}\n`)
    var gasLimit = 1000000;
	var transferAmount = 1000;
    var chainId = 1;

    var rawTransaction = {
        "from": coinbase,
        "nonce":  web3.utils.toHex(count),
        "gasPrice": web3.utils.toHex(gasPrice),
        "gasLimit": web3.utils.toHex(gasLimit),
        "to": toAddress,
        "value": "100",
        "data": "0x0",
        "chainId": web3.utils.toHex(chainId)
    };

    var privateKey = new Buffer(privateKey, 'hex');
    var tx = new Tx(rawTransaction);
    tx.sign(privateKey);
    var serializedTx = tx.serialize();

    web3.eth.sendSignedTransaction('0x' + serializedTx.toString('hex')).on('receipt', console.log);

```

```

'use strict';
const Web3 = require('web3');

const wsAddress = 'wss://rinkeby.infura.io/ws';
const contractJson = '(taken from solc or remix online compiler)';
const privateKey = '0xOOOX';
const contractAddress = '0xOOOX';
const walletAddress = '0xOOOX';

const webSocketProvider = new Web3.providers.WebsocketProvider(wsAddress);
const web3 = new Web3(new Web3.providers.WebsocketProvider(webSocketProvider));
const contract = new web3.eth.Contract(
  JSON.parse(contractJson),
  contractAddress
);
// change this to whatever contract method you are trying to call, E.G. SimpleStore("Hello World")
const query = contract.methods.SimpleStore('Hello World');
const encodedABI = query.encodeABI();
const tx = {
  from: walletAddress,
  to: contractAddress,
  gas: 2000000,
  data: encodedABI,
};

const account = web3.eth.accounts.privateKeyToAccount(privateKey);
console.log(account);
web3.eth.getBalance(walletAddress).then(console.log);

web3.eth.accounts.signTransaction(tx, privateKey).then(signed => {
  const tran = web3.eth
    .sendSignedTransaction(signed.rawTransaction)
    .on('confirmation', (confirmationNumber, receipt) => {
      console.log('=> confirmation: ' + confirmationNumber);
    })
    .on('transactionHash', hash => {
      console.log('=> hash');
      console.log(hash);
    })
    .on('receipt', receipt => {
      console.log('=> reciept');
      console.log(receipt);
    })
    .on('error', console.error);
});

```

### 4.4. 执行合约

```

const fs = require('fs');
const Web3 = require('web3');
const web3 = new Web3("https://mainnet.infura.io/CsS9shwaAab0z7B4LP2d");
const Tx = require('ethereumjs-tx');

const abi = [{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_status","type":"bool"}],"name":"setAirdropStatus","outputs":[{"name":"status","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"airdropStatus","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_mintedAmount","type":"uint256"}],"name":"mintAirdropToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_value","type":"uint256"}],"name":"burn","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_lock","type":"bool"}],"name":"setLock","outputs":[{"name":"status","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_address","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"airdropCurrentTotal","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"target","type":"address"},{"name":"mintedAmount","type":"uint256"}],"name":"mintToken","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_value","type":"uint256"}],"name":"burnFrom","outputs":[{"name":"success","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_amount","type":"uint256"}],"name":"setAirdropAmount","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"frozenAccount","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"airdropTotalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"touched","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"target","type":"address"},{"name":"freeze","type":"bool"}],"name":"freezeAccount","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"lock","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"airdropAmount","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"initialSupply","type":"uint256"},{"name":"tokenName","type":"string"},{"name":"tokenSymbol","type":"string"},{"name":"decimalUnits","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"target","type":"address"},{"indexed":false,"name":"frozen","type":"bool"}],"name":"FrozenFunds","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"target","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"AirDrop","type":"event"}];
const address = "0x3e827461Cc53CAE366175A291ed7c629F87CfF39";
const key = "19A57E4F6274AF1E0B9C3F8F7E3503876A850AFEE1912B8B9C5D9358EDEA0362"

const contractAddress = "0x44cCf3d1601427Fe0B0f7588eD058216830cd13C";
const contract = new web3.eth.Contract(abi, contractAddress, { "from": address});

contract.methods.balanceOf(address).call().then(function(balance){
    console.log(balance)
});

contract.methods.decimals().call().then(function(decimals){
    console.log(decimals)
});

web3.eth.getGasPrice().then(function(gasPrice){
    var price = Number(gasPrice);

    web3.eth.getTransactionCount(address).then(function(nonce){
        var amount = "1000000";
        contract.methods.mintAirdropToken(amount).estimateGas().then(function(gas){
            var rawTransaction = {
                "nonce": web3.utils.toHex(nonce),
                "from": address,
                "to": contractAddress,
                "gas": web3.utils.toHex(gas),
                "gasPrice": web3.utils.toHex(price),
                // "gasLimit": this.web3.utils.toHex(gasLimit.gasLimit),
                "value": "0x0",
                "data": contract.methods.mintAirdropToken(amount).encodeABI()
            };

            console.log(rawTransaction);

            var privateKey = new Buffer.from(key, 'hex');
            var tx = new Tx(rawTransaction);
            tx.sign(privateKey);
            var serializedTx = tx.serialize();

            web3.eth.sendSignedTransaction('0x' + serializedTx.toString('hex')).on('receipt', function(txhash){
                console.log(txhash);
            }); 
        });
    });
});

web3.eth.getGasPrice().then(function(gasPrice){
    var price = Number(gasPrice);

    web3.eth.getTransactionCount(address).then(function(nonce){
        var amount = "10";
        contract.methods.setAirdropAmount(amount).estimateGas().then(function(gas){
            var rawTransaction = {
                "nonce": web3.utils.toHex(nonce),
                "from": address,
                "to": contractAddress,
                "gas": web3.utils.toHex(gas),
                "gasPrice": web3.utils.toHex(price),
                "value": "0x0",
                "data": contract.methods.setAirdropAmount(amount).encodeABI()
            };

            console.log(rawTransaction);

            var privateKey = new Buffer.from(key, 'hex');
            var tx = new Tx(rawTransaction);
            tx.sign(privateKey);
            var serializedTx = tx.serialize();

            web3.eth.sendSignedTransaction('0x' + serializedTx.toString('hex')).on('receipt', function(txhash){
                console.log(txhash);
            }); 
        });
    });
});

web3.eth.getGasPrice().then(function(gasPrice){
    var price = Number(gasPrice);

    web3.eth.getTransactionCount(address).then(function(nonce){
        var status = true;
        contract.methods.setAirdropStatus(status).estimateGas().then(function(gas){
            var rawTransaction = {
                "nonce": web3.utils.toHex(nonce),
                "from": address,
                "to": contractAddress,
                "gas": web3.utils.toHex(gas),
                "gasPrice": web3.utils.toHex(price),
                "value": "0x0",
                "data": contract.methods.setAirdropStatus(status).encodeABI()
            };
            console.log(rawTransaction);

            var privateKey = new Buffer.from(key, 'hex');
            var tx = new Tx(rawTransaction);
            tx.sign(privateKey);
            var serializedTx = tx.serialize();

            web3.eth.sendSignedTransaction('0x' + serializedTx.toString('hex')).on('receipt', function(txhash){
                console.log(txhash);
            }); 
        });
    });
});			

```

## 5. Infura IPFS

### 5.1. 上传文件

```

neo@MacBook-Pro /tmp % cat hello.txt 
http://www.netkiller.cn

neo@MacBook-Pro /tmp % curl "https://ipfs.infura.io:5001/api/v0/add?pin=false" \
    -X POST \
    -H "Content-Type: multipart/form-data" \
    -F file=@"hello.txt"          
{"Name":"hello.txt","Hash":"QmToi4pgQH4LQX8wGMt5H8EV2dA7hD8S2EccRpd8YGUgac","Size":"32"}

```

### 5.2. 查看文件

```

neo@MacBook-Pro /tmp % curl "https://ipfs.infura.io:5001/api/v0/cat?arg=QmToi4pgQH4LQX8wGMt5H8EV2dA7hD8S2EccRpd8YGUgac" 
http://www.netkiller.cn

```

### 5.3. 下载文件

```

neo@MacBook-Pro /tmp % curl -s "https://ipfs.infura.io:5001/api/v0/get?arg=QmToi4pgQH4LQX8wGMt5H8EV2dA7hD8S2EccRpd8YGUgac&archive=true" -o hello.tgz

neo@MacBook-Pro /tmp % tar zxvf hello.tgz 
x QmToi4pgQH4LQX8wGMt5H8EV2dA7hD8S2EccRpd8YGUgac

neo@MacBook-Pro /tmp % cat QmToi4pgQH4LQX8wGMt5H8EV2dA7hD8S2EccRpd8YGUgac
http://www.netkiller.cn			

```

### 5.4. 创建目录

```

neo@MacBook-Pro /tmp % curl "https://ipfs.infura.io:5001/api/v0/files/mkdir?arg=/netkiller"

neo@MacBook-Pro /tmp % curl "https://ipfs.infura.io:5001/api/v0/files/stat?arg=/netkiller"        
{"Hash":"QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn","Size":0,"CumulativeSize":4,"Blocks":0,"Type":"directory"}			

```

### 5.5. 查看文件状态

```

neo@MacBook-Pro /tmp % curl "https://ipfs.infura.io:5001/api/v0/files/stat?arg=/netkiller"        
{"Hash":"QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn","Size":0,"CumulativeSize":4,"Blocks":0,"Type":"directory"}			

```

### 5.6. 查看 IPFS 版本号

```

neo@MacBook-Pro ~/workspace % curl "https://ipfs.infura.io:5001/api/v0/version"
{"Version":"0.4.14","Commit":"","Repo":"6","System":"amd64/linux","Golang":"go1.10"}			

```

## 6. Infura 2.0 (已经废弃)

### 6.1. 注册账号

[`infura.io/signup`](https://infura.io/signup)

输入用户名和邮箱即可注册

| ![](img/signup.png) |

这些地址你需要牢记

| ![](img/network.png) |

NETWORK DESCRIPTION URL
Mainnet production network https://mainnet.infura.io/CsS9shwaAab0z7B4LP2d
Ropsten test network https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d
INFURAnet test network https://infuranet.infura.io/CsS9shwaAab0z7B4LP2d
Kovan test network https://kovan.infura.io/CsS9shwaAab0z7B4LP2d
Rinkeby test network https://rinkeby.infura.io/CsS9shwaAab0z7B4LP2d
IPFS gateway https://ipfs.infura.io

这是你的 api key CsS9shwaAab0z7B4LP2d 请保存好

Mainnet 是以太坊主网

IPFS 是一个分布式区中心化的文件系统。

### 6.2. infura 接口

#### 6.2.1. jsonrpc

JSONRPC 文档 [`github.com/INFURA/infura/blob/master/docs/source/index.html.md#choosing-a-client-to-handle-your-request`](https://github.com/INFURA/infura/blob/master/docs/source/index.html.md#choosing-a-client-to-handle-your-request)

```

$ curl -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber", "params": []}' \
  "https://mainnet.infura.io/CsS9shwaAab0z7B4LP2d"

```

#### 6.2.2. INFURA API

```

https://api.infura.io/v1/jsonrpc/mainnet/eth_blockNumber?token=CsS9shwaAab0z7B4LP2d				

```

## 第 22 章 以太坊案例

## 1. EtherDelta

[`github.com/etherdelta/smart_contract`](https://github.com/etherdelta/smart_contract)

## 2. 以太猫（CryptoKitties）

首先你要拥有以太币，可以去交易所购买，然后使用谷歌浏览器进入下面网站，点击“Start meow” 按钮，再点击 “I Installed MetaMask” 安装浏览器插件，

以太猫官网 [`www.cryptokitties.co`](https://www.cryptokitties.co)

合约源码地址

[`etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code`](https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code)

下面是以太猫智能合约：

```

pragma solidity ⁰.4.11;

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)
contract ERC721 {
    // Required methods
    function totalSupply() public view returns (uint256 total);
    function balanceOf(address _owner) public view returns (uint256 balance);
    function ownerOf(uint256 _tokenId) external view returns (address owner);
    function approve(address _to, uint256 _tokenId) external;
    function transfer(address _to, uint256 _tokenId) external;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    // Events
    event Transfer(address from, address to, uint256 tokenId);
    event Approval(address owner, address approved, uint256 tokenId);

    // Optional
    // function name() public view returns (string name);
    // function symbol() public view returns (string symbol);
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);

    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)
    function supportsInterface(bytes4 _interfaceID) external view returns (bool);
}

// // Auction wrapper functions

// Auction wrapper functions

/// @title SEKRETOOOO
contract GeneScienceInterface {
    /// @dev simply a boolean to indicate this is the contract we expect to be
    function isGeneScience() public pure returns (bool);

    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor
    /// @param genes1 genes of mom
    /// @param genes2 genes of sire
    /// @return the genes that are supposed to be passed down the child
    function mixGenes(uint256 genes1, uint256 genes2, uint256 targetBlock) public returns (uint256);
}

/// @title A facet of KittyCore that manages special access privileges.
/// @author Axiom Zen (https://www.axiomzen.co)
/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.
contract KittyAccessControl {
    // This facet controls access control for CryptoKitties. There are four roles managed here:
    //
    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart
    //         contracts. It is also the only role that can unpause the smart contract. It is initially
    //         set to the address that created the smart contract in the KittyCore constructor.
    //
    //     - The CFO: The CFO can withdraw funds from KittyCore and its auction contracts.
    //
    //     - The COO: The COO can release gen0 kitties to auction, and mint promo cats.
    //
    // It should be noted that these roles are distinct without overlap in their access abilities, the
    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any
    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This
    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of
    // convenience. The less we use an address, the less likely it is that we somehow compromise the
    // account.

    /// @dev Emited when contract is upgraded - See README.md for updgrade plan
    event ContractUpgrade(address newContract);

    // The addresses of the accounts (or contracts) that can execute actions within each roles.
    address public ceoAddress;
    address public cfoAddress;
    address public cooAddress;

    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked
    bool public paused = false;

    /// @dev Access modifier for CEO-only functionality
    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    /// @dev Access modifier for CFO-only functionality
    modifier onlyCFO() {
        require(msg.sender == cfoAddress);
        _;
    }

    /// @dev Access modifier for COO-only functionality
    modifier onlyCOO() {
        require(msg.sender == cooAddress);
        _;
    }

    modifier onlyCLevel() {
        require(
            msg.sender == cooAddress ||
            msg.sender == ceoAddress ||
            msg.sender == cfoAddress
        );
        _;
    }

    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.
    /// @param _newCEO The address of the new CEO
    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));

        ceoAddress = _newCEO;
    }

    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.
    /// @param _newCFO The address of the new CFO
    function setCFO(address _newCFO) external onlyCEO {
        require(_newCFO != address(0));

        cfoAddress = _newCFO;
    }

    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.
    /// @param _newCOO The address of the new COO
    function setCOO(address _newCOO) external onlyCEO {
        require(_newCOO != address(0));

        cooAddress = _newCOO;
    }

    /*** Pausable functionality adapted from OpenZeppelin ***/

    /// @dev Modifier to allow actions only when the contract IS NOT paused
    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    /// @dev Modifier to allow actions only when the contract IS paused
    modifier whenPaused {
        require(paused);
        _;
    }

    /// @dev Called by any "C-level" role to pause the contract. Used only when
    ///  a bug or exploit is detected and we need to limit damage.
    function pause() external onlyCLevel whenNotPaused {
        paused = true;
    }

    /// @dev Unpauses the smart contract. Can only be called by the CEO, since
    ///  one reason we may pause the contract is when CFO or COO accounts are
    ///  compromised.
    /// @notice This is public rather than external so it can be called by
    ///  derived contracts.
    function unpause() public onlyCEO whenPaused {
        // can't unpause if contract was upgraded
        paused = false;
    }
}

/// @title Base contract for CryptoKitties. Holds all common structs, events and base variables.
/// @author Axiom Zen (https://www.axiomzen.co)
/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.
contract KittyBase is KittyAccessControl {
    /*** EVENTS ***/

    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously
    ///  includes any time a cat is created through the giveBirth method, but it is also called
    ///  when a new gen0 cat is created.
    event Birth(address owner, uint256 kittyId, uint256 matronId, uint256 sireId, uint256 genes);

    /// @dev Transfer event as defined in current draft of ERC721\. Emitted every time a kitten
    ///  ownership is assigned, including births.
    event Transfer(address from, address to, uint256 tokenId);

    /*** DATA TYPES ***/

    /// @dev The main Kitty struct. Every cat in CryptoKitties is represented by a copy
    ///  of this structure, so great care was taken to ensure that it fits neatly into
    ///  exactly two 256-bit words. Note that the order of the members in this structure
    ///  is important because of the byte-packing rules used by Ethereum.
    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html
    struct Kitty {
        // The Kitty's genetic code is packed into these 256-bits, the format is
        // sooper-sekret! A cat's genes never change.
        uint256 genes;

        // The timestamp from the block when this cat came into existence.
        uint64 birthTime;

        // The minimum timestamp after which this cat can engage in breeding
        // activities again. This same timestamp is used for the pregnancy
        // timer (for matrons) as well as the siring cooldown.
        uint64 cooldownEndBlock;

        // The ID of the parents of this kitty, set to 0 for gen0 cats.
        // Note that using 32-bit unsigned integers limits us to a "mere"
        // 4 billion cats. This number might seem small until you realize
        // that Ethereum currently has a limit of about 500 million
        // transactions per year! So, this definitely won't be a problem
        // for several years (even as Ethereum learns to scale).
        uint32 matronId;
        uint32 sireId;

        // Set to the ID of the sire cat for matrons that are pregnant,
        // zero otherwise. A non-zero value here is how we know a cat
        // is pregnant. Used to retrieve the genetic material for the new
        // kitten when the birth transpires.
        uint32 siringWithId;

        // Set to the index in the cooldown array (see below) that represents
        // the current cooldown duration for this Kitty. This starts at zero
        // for gen0 cats, and is initialized to floor(generation/2) for others.
        // Incremented by one for each successful breeding action, regardless
        // of whether this cat is acting as matron or sire.
        uint16 cooldownIndex;

        // The "generation number" of this cat. Cats minted by the CK contract
        // for sale are called "gen0" and have a generation number of 0\. The
        // generation number of all other cats is the larger of the two generation
        // numbers of their parents, plus one.
        // (i.e. max(matron.generation, sire.generation) + 1)
        uint16 generation;
    }

    /*** CONSTANTS ***/

    /// @dev A lookup table indicating the cooldown duration after any successful
    ///  breeding action, called "pregnancy time" for matrons and "siring cooldown"
    ///  for sires. Designed such that the cooldown roughly doubles each time a cat
    ///  is bred, encouraging owners not to just keep breeding the same cat over
    ///  and over again. Caps out at one week (a cat can breed an unbounded number
    ///  of times, and the maximum cooldown is always seven days).
    uint32[14] public cooldowns = [
        uint32(1 minutes),
        uint32(2 minutes),
        uint32(5 minutes),
        uint32(10 minutes),
        uint32(30 minutes),
        uint32(1 hours),
        uint32(2 hours),
        uint32(4 hours),
        uint32(8 hours),
        uint32(16 hours),
        uint32(1 days),
        uint32(2 days),
        uint32(4 days),
        uint32(7 days)
    ];

    // An approximation of currently how many seconds are in between blocks.
    uint256 public secondsPerBlock = 15;

    /*** STORAGE ***/

    /// @dev An array containing the Kitty struct for all Kitties in existence. The ID
    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,
    ///  the unKitty, the mythical beast that is the parent of all gen0 cats. A bizarre
    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.
    ///  In other words, cat ID 0 is invalid... ;-)
    Kitty[] kitties;

    /// @dev A mapping from cat IDs to the address that owns them. All cats have
    ///  some valid owner address, even gen0 cats are created with a non-zero owner.
    mapping (uint256 => address) public kittyIndexToOwner;

    // @dev A mapping from owner address to count of tokens that address owns.
    //  Used internally inside balanceOf() to resolve ownership count.
    mapping (address => uint256) ownershipTokenCount;

    /// @dev A mapping from KittyIDs to an address that has been approved to call
    ///  transferFrom(). Each Kitty can only have one approved address for transfer
    ///  at any time. A zero value means no approval is outstanding.
    mapping (uint256 => address) public kittyIndexToApproved;

    /// @dev A mapping from KittyIDs to an address that has been approved to use
    ///  this Kitty for siring via breedWith(). Each Kitty can only have one approved
    ///  address for siring at any time. A zero value means no approval is outstanding.
    mapping (uint256 => address) public sireAllowedToAddress;

    /// @dev The address of the ClockAuction contract that handles sales of Kitties. This
    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are
    ///  initiated every 15 minutes.
    SaleClockAuction public saleAuction;

    /// @dev The address of a custom ClockAuction subclassed contract that handles siring
    ///  auctions. Needs to be separate from saleAuction because the actions taken on success
    ///  after a sales and siring auction are quite different.
    SiringClockAuction public siringAuction;

    /// @dev Assigns ownership of a specific Kitty to an address.
    function _transfer(address _from, address _to, uint256 _tokenId) internal {
        // Since the number of kittens is capped to 2³² we can't overflow this
        ownershipTokenCount[_to]++;
        // transfer ownership
        kittyIndexToOwner[_tokenId] = _to;
        // When creating new kittens _from is 0x0, but we can't account that address.
        if (_from != address(0)) {
            ownershipTokenCount[_from]--;
            // once the kitten is transferred also clear sire allowances
            delete sireAllowedToAddress[_tokenId];
            // clear any previously approved ownership exchange
            delete kittyIndexToApproved[_tokenId];
        }
        // Emit the transfer event.
        Transfer(_from, _to, _tokenId);
    }

    /// @dev An internal method that creates a new kitty and stores it. This
    ///  method doesn't do any checking and should only be called when the
    ///  input data is known to be valid. Will generate both a Birth event
    ///  and a Transfer event.
    /// @param _matronId The kitty ID of the matron of this cat (zero for gen0)
    /// @param _sireId The kitty ID of the sire of this cat (zero for gen0)
    /// @param _generation The generation number of this cat, must be computed by caller.
    /// @param _genes The kitty's genetic code.
    /// @param _owner The inital owner of this cat, must be non-zero (except for the unKitty, ID 0)
    function _createKitty(
        uint256 _matronId,
        uint256 _sireId,
        uint256 _generation,
        uint256 _genes,
        address _owner
    )
        internal
        returns (uint)
    {
        // These requires are not strictly necessary, our calling code should make
        // sure that these conditions are never broken. However! _createKitty() is already
        // an expensive call (for storage), and it doesn't hurt to be especially careful
        // to ensure our data structures are always valid.
        require(_matronId == uint256(uint32(_matronId)));
        require(_sireId == uint256(uint32(_sireId)));
        require(_generation == uint256(uint16(_generation)));

        // New kitty starts with the same cooldown as parent gen/2
        uint16 cooldownIndex = uint16(_generation / 2);
        if (cooldownIndex > 13) {
            cooldownIndex = 13;
        }

        Kitty memory _kitty = Kitty({
            genes: _genes,
            birthTime: uint64(now),
            cooldownEndBlock: 0,
            matronId: uint32(_matronId),
            sireId: uint32(_sireId),
            siringWithId: 0,
            cooldownIndex: cooldownIndex,
            generation: uint16(_generation)
        });
        uint256 newKittenId = kitties.push(_kitty) - 1;

        // It's probably never going to happen, 4 billion cats is A LOT, but
        // let's just be 100% sure we never let this happen.
        require(newKittenId == uint256(uint32(newKittenId)));

        // emit the birth event
        Birth(
            _owner,
            newKittenId,
            uint256(_kitty.matronId),
            uint256(_kitty.sireId),
            _kitty.genes
        );

        // This will assign ownership, and also emit the Transfer event as
        // per ERC721 draft
        _transfer(0, _owner, newKittenId);

        return newKittenId;
    }

    // Any C-level can fix how many seconds per blocks are currently observed.
    function setSecondsPerBlock(uint256 secs) external onlyCLevel {
        require(secs < cooldowns[0]);
        secondsPerBlock = secs;
    }
}

/// @title The external contract that is responsible for generating metadata for the kitties,
///  it has one function that will return the data as bytes.
contract ERC721Metadata {
    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.
    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {
        if (_tokenId == 1) {
            buffer[0] = "Hello World! :D";
            count = 15;
        } else if (_tokenId == 2) {
            buffer[0] = "I would definitely choose a medi";
            buffer[1] = "um length string.";
            count = 49;
        } else if (_tokenId == 3) {
            buffer[0] = "Lorem ipsum dolor sit amet, mi e";
            buffer[1] = "st accumsan dapibus augue lorem,";
            buffer[2] = " tristique vestibulum id, libero";
            buffer[3] = " suscipit varius sapien aliquam.";
            count = 128;
        }
    }
}

/// @title The facet of the CryptoKitties core contract that manages ownership, ERC-721 (draft) compliant.
/// @author Axiom Zen (https://www.axiomzen.co)
/// @dev Ref: https://github.com/ethereum/EIPs/issues/721
///  See the KittyCore contract documentation to understand how the various contract facets are arranged.
contract KittyOwnership is KittyBase, ERC721 {

    /// @notice Name and symbol of the non fungible token, as defined in ERC721.
    string public constant name = "CryptoKitties";
    string public constant symbol = "CK";

    // The contract that will return kitty metadata
    ERC721Metadata public erc721Metadata;

    bytes4 constant InterfaceSignature_ERC165 =
        bytes4(keccak256('supportsInterface(bytes4)'));

    bytes4 constant InterfaceSignature_ERC721 =
        bytes4(keccak256('name()')) ^
        bytes4(keccak256('symbol()')) ^
        bytes4(keccak256('totalSupply()')) ^
        bytes4(keccak256('balanceOf(address)')) ^
        bytes4(keccak256('ownerOf(uint256)')) ^
        bytes4(keccak256('approve(address,uint256)')) ^
        bytes4(keccak256('transfer(address,uint256)')) ^
        bytes4(keccak256('transferFrom(address,address,uint256)')) ^
        bytes4(keccak256('tokensOfOwner(address)')) ^
        bytes4(keccak256('tokenMetadata(uint256,string)'));

    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).
    ///  Returns true for any standardized interfaces implemented by this contract. We implement
    ///  ERC-165 (obviously!) and ERC-721.
    function supportsInterface(bytes4 _interfaceID) external view returns (bool)
    {
        // DEBUG ONLY
        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));

        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));
    }

    /// @dev Set the address of the sibling contract that tracks metadata.
    ///  CEO only.
    function setMetadataAddress(address _contractAddress) public onlyCEO {
        erc721Metadata = ERC721Metadata(_contractAddress);
    }

    // Internal utility functions: These functions all assume that their input arguments
    // are valid. We leave it to public methods to sanitize their inputs and follow
    // the required logic.

    /// @dev Checks if a given address is the current owner of a particular Kitty.
    /// @param _claimant the address we are validating against.
    /// @param _tokenId kitten id, only valid when > 0
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {
        return kittyIndexToOwner[_tokenId] == _claimant;
    }

    /// @dev Checks if a given address currently has transferApproval for a particular Kitty.
    /// @param _claimant the address we are confirming kitten is approved for.
    /// @param _tokenId kitten id, only valid when > 0
    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {
        return kittyIndexToApproved[_tokenId] == _claimant;
    }

    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous
    ///  approval. Setting _approved to address(0) clears all transfer approval.
    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because
    ///  _approve() and transferFrom() are used together for putting Kitties on auction, and
    ///  there is no value in spamming the log with Approval events in that case.
    function _approve(uint256 _tokenId, address _approved) internal {
        kittyIndexToApproved[_tokenId] = _approved;
    }

    /// @notice Returns the number of Kitties owned by a specific address.
    /// @param _owner The owner address to check.
    /// @dev Required for ERC-721 compliance
    function balanceOf(address _owner) public view returns (uint256 count) {
        return ownershipTokenCount[_owner];
    }

    /// @notice Transfers a Kitty to another address. If transferring to a smart
    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or
    ///  CryptoKitties specifically) or your Kitty may be lost forever. Seriously.
    /// @param _to The address of the recipient, can be a user or contract.
    /// @param _tokenId The ID of the Kitty to transfer.
    /// @dev Required for ERC-721 compliance.
    function transfer(
        address _to,
        uint256 _tokenId
    )
        external
        whenNotPaused
    {
        // Safety check to prevent against an unexpected 0x0 default.
        require(_to != address(0));
        // Disallow transfers to this contract to prevent accidental misuse.
        // The contract should never own any kitties (except very briefly
        // after a gen0 cat is created and before it goes on auction).
        require(_to != address(this));
        // Disallow transfers to the auction contracts to prevent accidental
        // misuse. Auction contracts should only take ownership of kitties
        // through the allow + transferFrom flow.
        require(_to != address(saleAuction));
        require(_to != address(siringAuction));

        // You can only send your own cat.
        require(_owns(msg.sender, _tokenId));

        // Reassign ownership, clear pending approvals, emit Transfer event.
        _transfer(msg.sender, _to, _tokenId);
    }

    /// @notice Grant another address the right to transfer a specific Kitty via
    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.
    /// @param _to The address to be granted transfer approval. Pass address(0) to
    ///  clear all approvals.
    /// @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.
    /// @dev Required for ERC-721 compliance.
    function approve(
        address _to,
        uint256 _tokenId
    )
        external
        whenNotPaused
    {
        // Only an owner can grant transfer approval.
        require(_owns(msg.sender, _tokenId));

        // Register the approval (replacing any previous approval).
        _approve(_tokenId, _to);

        // Emit approval event.
        Approval(msg.sender, _to, _tokenId);
    }

    /// @notice Transfer a Kitty owned by another address, for which the calling address
    ///  has previously been granted transfer approval by the owner.
    /// @param _from The address that owns the Kitty to be transfered.
    /// @param _to The address that should take ownership of the Kitty. Can be any address,
    ///  including the caller.
    /// @param _tokenId The ID of the Kitty to be transferred.
    /// @dev Required for ERC-721 compliance.
    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    )
        external
        whenNotPaused
    {
        // Safety check to prevent against an unexpected 0x0 default.
        require(_to != address(0));
        // Disallow transfers to this contract to prevent accidental misuse.
        // The contract should never own any kitties (except very briefly
        // after a gen0 cat is created and before it goes on auction).
        require(_to != address(this));
        // Check for approval and valid ownership
        require(_approvedFor(msg.sender, _tokenId));
        require(_owns(_from, _tokenId));

        // Reassign ownership (also clears pending approvals and emits Transfer event).
        _transfer(_from, _to, _tokenId);
    }

    /// @notice Returns the total number of Kitties currently in existence.
    /// @dev Required for ERC-721 compliance.
    function totalSupply() public view returns (uint) {
        return kitties.length - 1;
    }

    /// @notice Returns the address currently assigned ownership of a given Kitty.
    /// @dev Required for ERC-721 compliance.
    function ownerOf(uint256 _tokenId)
        external
        view
        returns (address owner)
    {
        owner = kittyIndexToOwner[_tokenId];

        require(owner != address(0));
    }

    /// @notice Returns a list of all Kitty IDs assigned to an address.
    /// @param _owner The owner whose Kitties we are interested in.
    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly
    ///  expensive (it walks the entire Kitty array looking for cats belonging to owner),
    ///  but it also returns a dynamic array, which is only supported for web3 calls, and
    ///  not contract-to-contract calls.
    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {
        uint256 tokenCount = balanceOf(_owner);

        if (tokenCount == 0) {
            // Return an empty array
            return new uint256[](0);
        } else {
            uint256[] memory result = new uint256[](tokenCount);
            uint256 totalCats = totalSupply();
            uint256 resultIndex = 0;

            // We count on the fact that all cats have IDs starting at 1 and increasing
            // sequentially up to the totalCat count.
            uint256 catId;

            for (catId = 1; catId <= totalCats; catId++) {
                if (kittyIndexToOwner[catId] == _owner) {
                    result[resultIndex] = catId;
                    resultIndex++;
                }
            }

            return result;
        }
    }

    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)
    ///  This method is licenced under the Apache License.
    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol
    function _memcpy(uint _dest, uint _src, uint _len) private view {
        // Copy word-length chunks while possible
        for(; _len >= 32; _len -= 32) {
            assembly {
                mstore(_dest, mload(_src))
            }
            _dest += 32;
            _src += 32;
        }

        // Copy remaining bytes
        uint256 mask = 256 ** (32 - _len) - 1;
        assembly {
            let srcpart := and(mload(_src), not(mask))
            let destpart := and(mload(_dest), mask)
            mstore(_dest, or(destpart, srcpart))
        }
    }

    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)
    ///  This method is licenced under the Apache License.
    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol
    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {
        var outputString = new string(_stringLength);
        uint256 outputPtr;
        uint256 bytesPtr;

        assembly {
            outputPtr := add(outputString, 32)
            bytesPtr := _rawBytes
        }

        _memcpy(outputPtr, bytesPtr, _stringLength);

        return outputString;
    }

    /// @notice Returns a URI pointing to a metadata package for this token conforming to
    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)
    /// @param _tokenId The ID number of the Kitty whose metadata should be returned.
    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {
        require(erc721Metadata != address(0));
        bytes32[4] memory buffer;
        uint256 count;
        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);

        return _toString(buffer, count);
    }
}

/// @title A facet of KittyCore that manages Kitty siring, gestation, and birth.
/// @author Axiom Zen (https://www.axiomzen.co)
/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.
contract KittyBreeding is KittyOwnership {

    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy
    ///  timer begins for the matron.
    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);

    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards
    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by
    ///  the COO role as the gas price changes.
    uint256 public autoBirthFee = 2 finney;

    // Keeps track of number of pregnant kitties.
    uint256 public pregnantKitties;

    /// @dev The address of the sibling contract that is used to implement the sooper-sekret
    ///  genetic combination algorithm.
    GeneScienceInterface public geneScience;

    /// @dev Update the address of the genetic contract, can only be called by the CEO.
    /// @param _address An address of a GeneScience contract instance to be used from this point forward.
    function setGeneScienceAddress(address _address) external onlyCEO {
        GeneScienceInterface candidateContract = GeneScienceInterface(_address);

        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117
        require(candidateContract.isGeneScience());

        // Set the new contract address
        geneScience = candidateContract;
    }

    /// @dev Checks that a given kitten is able to breed. Requires that the
    ///  current cooldown is finished (for sires) and also checks that there is
    ///  no pending pregnancy.
    function _isReadyToBreed(Kitty _kit) internal view returns (bool) {
        // In addition to checking the cooldownEndBlock, we also need to check to see if
        // the cat has a pending birth; there can be some period of time between the end
        // of the pregnacy timer and the birth event.
        return (_kit.siringWithId == 0) && (_kit.cooldownEndBlock <= uint64(block.number));
    }

    /// @dev Check if a sire has authorized breeding with this matron. True if both sire
    ///  and matron have the same owner, or if the sire has given siring permission to
    ///  the matron's owner (via approveSiring()).
    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns (bool) {
        address matronOwner = kittyIndexToOwner[_matronId];
        address sireOwner = kittyIndexToOwner[_sireId];

        // Siring is okay if they have same owner, or if the matron's owner was given
        // permission to breed with this sire.
        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);
    }

    /// @dev Set the cooldownEndTime for the given Kitty, based on its current cooldownIndex.
    ///  Also increments the cooldownIndex (unless it has hit the cap).
    /// @param _kitten A reference to the Kitty in storage which needs its timer started.
    function _triggerCooldown(Kitty storage _kitten) internal {
        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).
        _kitten.cooldownEndBlock = uint64((cooldowns[_kitten.cooldownIndex]/secondsPerBlock) + block.number);

        // Increment the breeding count, clamping it at 13, which is the length of the
        // cooldowns array. We could check the array size dynamically, but hard-coding
        // this as a constant saves gas. Yay, Solidity!
        if (_kitten.cooldownIndex < 13) {
            _kitten.cooldownIndex += 1;
        }
    }

    /// @notice Grants approval to another user to sire with one of your Kitties.
    /// @param _addr The address that will be able to sire with your Kitty. Set to
    ///  address(0) to clear all siring approvals for this Kitty.
    /// @param _sireId A Kitty that you own that _addr will now be able to sire with.
    function approveSiring(address _addr, uint256 _sireId)
        external
        whenNotPaused
    {
        require(_owns(msg.sender, _sireId));
        sireAllowedToAddress[_sireId] = _addr;
    }

    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only
    ///  be called by the COO address. (This fee is used to offset the gas cost incurred
    ///  by the autobirth daemon).
    function setAutoBirthFee(uint256 val) external onlyCOO {
        autoBirthFee = val;
    }

    /// @dev Checks to see if a given Kitty is pregnant and (if so) if the gestation
    ///  period has passed.
    function _isReadyToGiveBirth(Kitty _matron) private view returns (bool) {
        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));
    }

    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or
    ///  in the middle of a siring cooldown).
    /// @param _kittyId reference the id of the kitten, any user can inquire about it
    function isReadyToBreed(uint256 _kittyId)
        public
        view
        returns (bool)
    {
        require(_kittyId > 0);
        Kitty storage kit = kitties[_kittyId];
        return _isReadyToBreed(kit);
    }

    /// @dev Checks whether a kitty is currently pregnant.
    /// @param _kittyId reference the id of the kitten, any user can inquire about it
    function isPregnant(uint256 _kittyId)
        public
        view
        returns (bool)
    {
        require(_kittyId > 0);
        // A kitty is pregnant if and only if this field is set
        return kitties[_kittyId].siringWithId != 0;
    }

    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT
    ///  check ownership permissions (that is up to the caller).
    /// @param _matron A reference to the Kitty struct of the potential matron.
    /// @param _matronId The matron's ID.
    /// @param _sire A reference to the Kitty struct of the potential sire.
    /// @param _sireId The sire's ID
    function _isValidMatingPair(
        Kitty storage _matron,
        uint256 _matronId,
        Kitty storage _sire,
        uint256 _sireId
    )
        private
        view
        returns(bool)
    {
        // A Kitty can't breed with itself!
        if (_matronId == _sireId) {
            return false;
        }

        // Kitties can't breed with their parents.
        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {
            return false;
        }
        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {
            return false;
        }

        // We can short circuit the sibling check (below) if either cat is
        // gen zero (has a matron ID of zero).
        if (_sire.matronId == 0 || _matron.matronId == 0) {
            return true;
        }

        // Kitties can't breed with full or half siblings.
        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {
            return false;
        }
        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {
            return false;
        }

        // Everything seems cool! Let's get DTF.
        return true;
    }

    /// @dev Internal check to see if a given sire and matron are a valid mating pair for
    ///  breeding via auction (i.e. skips ownership and siring approval checks).
    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)
        internal
        view
        returns (bool)
    {
        Kitty storage matron = kitties[_matronId];
        Kitty storage sire = kitties[_sireId];
        return _isValidMatingPair(matron, _matronId, sire, _sireId);
    }

    /// @notice Checks to see if two cats can breed together, including checks for
    ///  ownership and siring approvals. Does NOT check that both cats are ready for
    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).
    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?
    /// @param _matronId The ID of the proposed matron.
    /// @param _sireId The ID of the proposed sire.
    function canBreedWith(uint256 _matronId, uint256 _sireId)
        external
        view
        returns(bool)
    {
        require(_matronId > 0);
        require(_sireId > 0);
        Kitty storage matron = kitties[_matronId];
        Kitty storage sire = kitties[_sireId];
        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&
            _isSiringPermitted(_sireId, _matronId);
    }

    /// @dev Internal utility function to initiate breeding, assumes that all breeding
    ///  requirements have been checked.
    function _breedWith(uint256 _matronId, uint256 _sireId) internal {
        // Grab a reference to the Kitties from storage.
        Kitty storage sire = kitties[_sireId];
        Kitty storage matron = kitties[_matronId];

        // Mark the matron as pregnant, keeping track of who the sire is.
        matron.siringWithId = uint32(_sireId);

        // Trigger the cooldown for both parents.
        _triggerCooldown(sire);
        _triggerCooldown(matron);

        // Clear siring permission for both parents. This may not be strictly necessary
        // but it's likely to avoid confusion!
        delete sireAllowedToAddress[_matronId];
        delete sireAllowedToAddress[_sireId];

        // Every time a kitty gets pregnant, counter is incremented.
        pregnantKitties++;

        // Emit the pregnancy event.
        Pregnant(kittyIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);
    }

    /// @notice Breed a Kitty you own (as matron) with a sire that you own, or for which you
    ///  have previously been given Siring approval. Will either make your cat pregnant, or will
    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()
    /// @param _matronId The ID of the Kitty acting as matron (will end up pregnant if successful)
    /// @param _sireId The ID of the Kitty acting as sire (will begin its siring cooldown if successful)
    function breedWithAuto(uint256 _matronId, uint256 _sireId)
        external
        payable
        whenNotPaused
    {
        // Checks for payment.
        require(msg.value >= autoBirthFee);

        // Caller must own the matron.
        require(_owns(msg.sender, _matronId));

        // Neither sire nor matron are allowed to be on auction during a normal
        // breeding operation, but we don't need to check that explicitly.
        // For matron: The caller of this function can't be the owner of the matron
        //   because the owner of a Kitty on auction is the auction house, and the
        //   auction house will never call breedWith().
        // For sire: Similarly, a sire on auction will be owned by the auction house
        //   and the act of transferring ownership will have cleared any oustanding
        //   siring approval.
        // Thus we don't need to spend gas explicitly checking to see if either cat
        // is on auction.

        // Check that matron and sire are both owned by caller, or that the sire
        // has given siring permission to caller (i.e. matron's owner).
        // Will fail for _sireId = 0
        require(_isSiringPermitted(_sireId, _matronId));

        // Grab a reference to the potential matron
        Kitty storage matron = kitties[_matronId];

        // Make sure matron isn't pregnant, or in the middle of a siring cooldown
        require(_isReadyToBreed(matron));

        // Grab a reference to the potential sire
        Kitty storage sire = kitties[_sireId];

        // Make sure sire isn't pregnant, or in the middle of a siring cooldown
        require(_isReadyToBreed(sire));

        // Test that these cats are a valid mating pair.
        require(_isValidMatingPair(
            matron,
            _matronId,
            sire,
            _sireId
        ));

        // All checks passed, kitty gets pregnant!
        _breedWith(_matronId, _sireId);
    }

    /// @notice Have a pregnant Kitty give birth!
    /// @param _matronId A Kitty ready to give birth.
    /// @return The Kitty ID of the new kitten.
    /// @dev Looks at a given Kitty and, if pregnant and if the gestation period has passed,
    ///  combines the genes of the two parents to create a new kitten. The new Kitty is assigned
    ///  to the current owner of the matron. Upon successful completion, both the matron and the
    ///  new kitten will be ready to breed again. Note that anyone can call this function (if they
    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.
    function giveBirth(uint256 _matronId)
        external
        whenNotPaused
        returns(uint256)
    {
        // Grab a reference to the matron in storage.
        Kitty storage matron = kitties[_matronId];

        // Check that the matron is a valid cat.
        require(matron.birthTime != 0);

        // Check that the matron is pregnant, and that its time has come!
        require(_isReadyToGiveBirth(matron));

        // Grab a reference to the sire in storage.
        uint256 sireId = matron.siringWithId;
        Kitty storage sire = kitties[sireId];

        // Determine the higher generation number of the two parents
        uint16 parentGen = matron.generation;
        if (sire.generation > matron.generation) {
            parentGen = sire.generation;
        }

        // Call the sooper-sekret gene mixing operation.
        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);

        // Make the new kitten!
        address owner = kittyIndexToOwner[_matronId];
        uint256 kittenId = _createKitty(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);

        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId
        // set is what marks a matron as being pregnant.)
        delete matron.siringWithId;

        // Every time a kitty gives birth counter is decremented.
        pregnantKitties--;

        // Send the balance fee to the person who made birth happen.
        msg.sender.send(autoBirthFee);

        // return the new kitten's ID
        return kittenId;
    }
}

/// @title Auction Core
/// @dev Contains models, variables, and internal methods for the auction.
/// @notice We omit a fallback function to prevent accidental sends to this contract.
contract ClockAuctionBase {

    // Represents an auction on an NFT
    struct Auction {
        // Current owner of NFT
        address seller;
        // Price (in wei) at beginning of auction
        uint128 startingPrice;
        // Price (in wei) at end of auction
        uint128 endingPrice;
        // Duration (in seconds) of auction
        uint64 duration;
        // Time when auction started
        // NOTE: 0 if this auction has been concluded
        uint64 startedAt;
    }

    // Reference to contract tracking NFT ownership
    ERC721 public nonFungibleContract;

    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).
    // Values 0-10,000 map to 0%-100%
    uint256 public ownerCut;

    // Map from token ID to their corresponding auction.
    mapping (uint256 => Auction) tokenIdToAuction;

    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);
    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);
    event AuctionCancelled(uint256 tokenId);

    /// @dev Returns true if the claimant owns the token.
    /// @param _claimant - Address claiming to own the token.
    /// @param _tokenId - ID of token whose ownership to verify.
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {
        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);
    }

    /// @dev Escrows the NFT, assigning ownership to this contract.
    /// Throws if the escrow fails.
    /// @param _owner - Current owner address of token to escrow.
    /// @param _tokenId - ID of token whose approval to verify.
    function _escrow(address _owner, uint256 _tokenId) internal {
        // it will throw if transfer fails
        nonFungibleContract.transferFrom(_owner, this, _tokenId);
    }

    /// @dev Transfers an NFT owned by this contract to another address.
    /// Returns true if the transfer succeeds.
    /// @param _receiver - Address to transfer NFT to.
    /// @param _tokenId - ID of token to transfer.
    function _transfer(address _receiver, uint256 _tokenId) internal {
        // it will throw if transfer fails
        nonFungibleContract.transfer(_receiver, _tokenId);
    }

    /// @dev Adds an auction to the list of open auctions. Also fires the
    ///  AuctionCreated event.
    /// @param _tokenId The ID of the token to be put on auction.
    /// @param _auction Auction to add.
    function _addAuction(uint256 _tokenId, Auction _auction) internal {
        // Require that all auctions have a duration of
        // at least one minute. (Keeps our math from getting hairy!)
        require(_auction.duration >= 1 minutes);

        tokenIdToAuction[_tokenId] = _auction;

        AuctionCreated(
            uint256(_tokenId),
            uint256(_auction.startingPrice),
            uint256(_auction.endingPrice),
            uint256(_auction.duration)
        );
    }

    /// @dev Cancels an auction unconditionally.
    function _cancelAuction(uint256 _tokenId, address _seller) internal {
        _removeAuction(_tokenId);
        _transfer(_seller, _tokenId);
        AuctionCancelled(_tokenId);
    }

    /// @dev Computes the price and transfers winnings.
    /// Does NOT transfer ownership of token.
    function _bid(uint256 _tokenId, uint256 _bidAmount)
        internal
        returns (uint256)
    {
        // Get a reference to the auction struct
        Auction storage auction = tokenIdToAuction[_tokenId];

        // Explicitly check that this auction is currently live.
        // (Because of how Ethereum mappings work, we can't just count
        // on the lookup above failing. An invalid _tokenId will just
        // return an auction object that is all zeros.)
        require(_isOnAuction(auction));

        // Check that the bid is greater than or equal to the current price
        uint256 price = _currentPrice(auction);
        require(_bidAmount >= price);

        // Grab a reference to the seller before the auction struct
        // gets deleted.
        address seller = auction.seller;

        // The bid is good! Remove the auction before sending the fees
        // to the sender so we can't have a reentrancy attack.
        _removeAuction(_tokenId);

        // Transfer proceeds to seller (if there are any!)
        if (price > 0) {
            // Calculate the auctioneer's cut.
            // (NOTE: _computeCut() is guaranteed to return a
            // value <= price, so this subtraction can't go negative.)
            uint256 auctioneerCut = _computeCut(price);
            uint256 sellerProceeds = price - auctioneerCut;

            // NOTE: Doing a transfer() in the middle of a complex
            // method like this is generally discouraged because of
            // reentrancy attacks and DoS attacks if the seller is
            // a contract with an invalid fallback function. We explicitly
            // guard against reentrancy attacks by removing the auction
            // before calling transfer(), and the only thing the seller
            // can DoS is the sale of their own asset! (And if it's an
            // accident, they can call cancelAuction(). )
            seller.transfer(sellerProceeds);
        }

        // Calculate any excess funds included with the bid. If the excess
        // is anything worth worrying about, transfer it back to bidder.
        // NOTE: We checked above that the bid amount is greater than or
        // equal to the price so this cannot underflow.
        uint256 bidExcess = _bidAmount - price;

        // Return the funds. Similar to the previous transfer, this is
        // not susceptible to a re-entry attack because the auction is
        // removed before any transfers occur.
        msg.sender.transfer(bidExcess);

        // Tell the world!
        AuctionSuccessful(_tokenId, price, msg.sender);

        return price;
    }

    /// @dev Removes an auction from the list of open auctions.
    /// @param _tokenId - ID of NFT on auction.
    function _removeAuction(uint256 _tokenId) internal {
        delete tokenIdToAuction[_tokenId];
    }

    /// @dev Returns true if the NFT is on auction.
    /// @param _auction - Auction to check.
    function _isOnAuction(Auction storage _auction) internal view returns (bool) {
        return (_auction.startedAt > 0);
    }

    /// @dev Returns current price of an NFT on auction. Broken into two
    ///  functions (this one, that computes the duration from the auction
    ///  structure, and the other that does the price computation) so we
    ///  can easily test that the price computation works correctly.
    function _currentPrice(Auction storage _auction)
        internal
        view
        returns (uint256)
    {
        uint256 secondsPassed = 0;

        // A bit of insurance against negative values (or wraparound).
        // Probably not necessary (since Ethereum guarnatees that the
        // now variable doesn't ever go backwards).
        if (now > _auction.startedAt) {
            secondsPassed = now - _auction.startedAt;
        }

        return _computeCurrentPrice(
            _auction.startingPrice,
            _auction.endingPrice,
            _auction.duration,
            secondsPassed
        );
    }

    /// @dev Computes the current price of an auction. Factored out
    ///  from _currentPrice so we can run extensive unit tests.
    ///  When testing, make this function public and turn on
    ///  `Current price computation` test suite.
    function _computeCurrentPrice(
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration,
        uint256 _secondsPassed
    )
        internal
        pure
        returns (uint256)
    {
        // NOTE: We don't use SafeMath (or similar) in this function because
        //  all of our public functions carefully cap the maximum values for
        //  time (at 64-bits) and currency (at 128-bits). _duration is
        //  also known to be non-zero (see the require() statement in
        //  _addAuction())
        if (_secondsPassed >= _duration) {
            // We've reached the end of the dynamic pricing portion
            // of the auction, just return the end price.
            return _endingPrice;
        } else {
            // Starting price can be higher than ending price (and often is!), so
            // this delta can be negative.
            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);

            // This multiplication can't overflow, _secondsPassed will easily fit within
            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product
            // will always fit within 256-bits.
            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);

            // currentPriceChange can be negative, but if so, will have a magnitude
            // less that _startingPrice. Thus, this result will always end up positive.
            int256 currentPrice = int256(_startingPrice) + currentPriceChange;

            return uint256(currentPrice);
        }
    }

    /// @dev Computes owner's cut of a sale.
    /// @param _price - Sale price of NFT.
    function _computeCut(uint256 _price) internal view returns (uint256) {
        // NOTE: We don't use SafeMath (or similar) in this function because
        //  all of our entry functions carefully cap the maximum values for
        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()
        //  statement in the ClockAuction constructor). The result of this
        //  function is always guaranteed to be <= _price.
        return _price * ownerCut / 10000;
    }

}

/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;

  /**
   * @dev modifier to allow actions only when the contract IS paused
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev modifier to allow actions only when the contract IS NOT paused
   */
  modifier whenPaused {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}

/// @title Clock auction for non-fungible tokens.
/// @notice We omit a fallback function to prevent accidental sends to this contract.
contract ClockAuction is Pausable, ClockAuctionBase {

    /// @dev The ERC-165 interface signature for ERC-721.
    ///  Ref: https://github.com/ethereum/EIPs/issues/165
    ///  Ref: https://github.com/ethereum/EIPs/issues/721
    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);

    /// @dev Constructor creates a reference to the NFT ownership contract
    ///  and verifies the owner cut is in the valid range.
    /// @param _nftAddress - address of a deployed contract implementing
    ///  the Nonfungible Interface.
    /// @param _cut - percent cut the owner takes on each auction, must be
    ///  between 0-10,000.
    function ClockAuction(address _nftAddress, uint256 _cut) public {
        require(_cut <= 10000);
        ownerCut = _cut;

        ERC721 candidateContract = ERC721(_nftAddress);
        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));
        nonFungibleContract = candidateContract;
    }

    /// @dev Remove all Ether from the contract, which is the owner's cuts
    ///  as well as any Ether sent directly to the contract address.
    ///  Always transfers to the NFT contract, but can be called either by
    ///  the owner or the NFT contract.
    function withdrawBalance() external {
        address nftAddress = address(nonFungibleContract);

        require(
            msg.sender == owner ||
            msg.sender == nftAddress
        );
        // We are using this boolean method to make sure that even if one fails it will still work
        bool res = nftAddress.send(this.balance);
    }

    /// @dev Creates and begins a new auction.
    /// @param _tokenId - ID of token to auction, sender must be owner.
    /// @param _startingPrice - Price of item (in wei) at beginning of auction.
    /// @param _endingPrice - Price of item (in wei) at end of auction.
    /// @param _duration - Length of time to move between starting
    ///  price and ending price (in seconds).
    /// @param _seller - Seller, if not the message sender
    function createAuction(
        uint256 _tokenId,
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration,
        address _seller
    )
        external
        whenNotPaused
    {
        // Sanity check that no inputs overflow how many bits we've allocated
        // to store them in the auction struct.
        require(_startingPrice == uint256(uint128(_startingPrice)));
        require(_endingPrice == uint256(uint128(_endingPrice)));
        require(_duration == uint256(uint64(_duration)));

        require(_owns(msg.sender, _tokenId));
        _escrow(msg.sender, _tokenId);
        Auction memory auction = Auction(
            _seller,
            uint128(_startingPrice),
            uint128(_endingPrice),
            uint64(_duration),
            uint64(now)
        );
        _addAuction(_tokenId, auction);
    }

    /// @dev Bids on an open auction, completing the auction and transferring
    ///  ownership of the NFT if enough Ether is supplied.
    /// @param _tokenId - ID of token to bid on.
    function bid(uint256 _tokenId)
        external
        payable
        whenNotPaused
    {
        // _bid will throw if the bid or funds transfer fails
        _bid(_tokenId, msg.value);
        _transfer(msg.sender, _tokenId);
    }

    /// @dev Cancels an auction that hasn't been won yet.
    ///  Returns the NFT to original owner.
    /// @notice This is a state-modifying function that can
    ///  be called while the contract is paused.
    /// @param _tokenId - ID of token on auction
    function cancelAuction(uint256 _tokenId)
        external
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        address seller = auction.seller;
        require(msg.sender == seller);
        _cancelAuction(_tokenId, seller);
    }

    /// @dev Cancels an auction when the contract is paused.
    ///  Only the owner may do this, and NFTs are returned to
    ///  the seller. This should only be used in emergencies.
    /// @param _tokenId - ID of the NFT on auction to cancel.
    function cancelAuctionWhenPaused(uint256 _tokenId)
        whenPaused
        onlyOwner
        external
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        _cancelAuction(_tokenId, auction.seller);
    }

    /// @dev Returns auction info for an NFT on auction.
    /// @param _tokenId - ID of NFT on auction.
    function getAuction(uint256 _tokenId)
        external
        view
        returns
    (
        address seller,
        uint256 startingPrice,
        uint256 endingPrice,
        uint256 duration,
        uint256 startedAt
    ) {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return (
            auction.seller,
            auction.startingPrice,
            auction.endingPrice,
            auction.duration,
            auction.startedAt
        );
    }

    /// @dev Returns the current price of an auction.
    /// @param _tokenId - ID of the token price we are checking.
    function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }

}

/// @title Reverse auction modified for siring
/// @notice We omit a fallback function to prevent accidental sends to this contract.
contract SiringClockAuction is ClockAuction {

    // @dev Sanity check that allows us to ensure that we are pointing to the
    //  right auction in our setSiringAuctionAddress() call.
    bool public isSiringClockAuction = true;

    // Delegate constructor
    function SiringClockAuction(address _nftAddr, uint256 _cut) public
        ClockAuction(_nftAddr, _cut) {}

    /// @dev Creates and begins a new auction. Since this function is wrapped,
    /// require sender to be KittyCore contract.
    /// @param _tokenId - ID of token to auction, sender must be owner.
    /// @param _startingPrice - Price of item (in wei) at beginning of auction.
    /// @param _endingPrice - Price of item (in wei) at end of auction.
    /// @param _duration - Length of auction (in seconds).
    /// @param _seller - Seller, if not the message sender
    function createAuction(
        uint256 _tokenId,
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration,
        address _seller
    )
        external
    {
        // Sanity check that no inputs overflow how many bits we've allocated
        // to store them in the auction struct.
        require(_startingPrice == uint256(uint128(_startingPrice)));
        require(_endingPrice == uint256(uint128(_endingPrice)));
        require(_duration == uint256(uint64(_duration)));

        require(msg.sender == address(nonFungibleContract));
        _escrow(_seller, _tokenId);
        Auction memory auction = Auction(
            _seller,
            uint128(_startingPrice),
            uint128(_endingPrice),
            uint64(_duration),
            uint64(now)
        );
        _addAuction(_tokenId, auction);
    }

    /// @dev Places a bid for siring. Requires the sender
    /// is the KittyCore contract because all bid methods
    /// should be wrapped. Also returns the kitty to the
    /// seller rather than the winner.
    function bid(uint256 _tokenId)
        external
        payable
    {
        require(msg.sender == address(nonFungibleContract));
        address seller = tokenIdToAuction[_tokenId].seller;
        // _bid checks that token ID is valid and will throw if bid fails
        _bid(_tokenId, msg.value);
        // We transfer the kitty back to the seller, the winner will get
        // the offspring
        _transfer(seller, _tokenId);
    }

}

/// @title Clock auction modified for sale of kitties
/// @notice We omit a fallback function to prevent accidental sends to this contract.
contract SaleClockAuction is ClockAuction {

    // @dev Sanity check that allows us to ensure that we are pointing to the
    //  right auction in our setSaleAuctionAddress() call.
    bool public isSaleClockAuction = true;

    // Tracks last 5 sale price of gen0 kitty sales
    uint256 public gen0SaleCount;
    uint256[5] public lastGen0SalePrices;

    // Delegate constructor
    function SaleClockAuction(address _nftAddr, uint256 _cut) public
        ClockAuction(_nftAddr, _cut) {}

    /// @dev Creates and begins a new auction.
    /// @param _tokenId - ID of token to auction, sender must be owner.
    /// @param _startingPrice - Price of item (in wei) at beginning of auction.
    /// @param _endingPrice - Price of item (in wei) at end of auction.
    /// @param _duration - Length of auction (in seconds).
    /// @param _seller - Seller, if not the message sender
    function createAuction(
        uint256 _tokenId,
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration,
        address _seller
    )
        external
    {
        // Sanity check that no inputs overflow how many bits we've allocated
        // to store them in the auction struct.
        require(_startingPrice == uint256(uint128(_startingPrice)));
        require(_endingPrice == uint256(uint128(_endingPrice)));
        require(_duration == uint256(uint64(_duration)));

        require(msg.sender == address(nonFungibleContract));
        _escrow(_seller, _tokenId);
        Auction memory auction = Auction(
            _seller,
            uint128(_startingPrice),
            uint128(_endingPrice),
            uint64(_duration),
            uint64(now)
        );
        _addAuction(_tokenId, auction);
    }

    /// @dev Updates lastSalePrice if seller is the nft contract
    /// Otherwise, works the same as default bid method.
    function bid(uint256 _tokenId)
        external
        payable
    {
        // _bid verifies token ID size
        address seller = tokenIdToAuction[_tokenId].seller;
        uint256 price = _bid(_tokenId, msg.value);
        _transfer(msg.sender, _tokenId);

        // If not a gen0 auction, exit
        if (seller == address(nonFungibleContract)) {
            // Track gen0 sale prices
            lastGen0SalePrices[gen0SaleCount % 5] = price;
            gen0SaleCount++;
        }
    }

    function averageGen0SalePrice() external view returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < 5; i++) {
            sum += lastGen0SalePrices[i];
        }
        return sum / 5;
    }

}

/// @title Handles creating auctions for sale and siring of kitties.
///  This wrapper of ReverseAuction exists only so that users can create
///  auctions with only one transaction.
contract KittyAuction is KittyBreeding {

    // @notice The auction contract variables are defined in KittyBase to allow
    //  us to refer to them in KittyOwnership to prevent accidental transfers.
    // `saleAuction` refers to the auction for gen0 and p2p sale of kitties.
    // `siringAuction` refers to the auction for siring rights of kitties.

    /// @dev Sets the reference to the sale auction.
    /// @param _address - Address of sale contract.
    function setSaleAuctionAddress(address _address) external onlyCEO {
        SaleClockAuction candidateContract = SaleClockAuction(_address);

        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117
        require(candidateContract.isSaleClockAuction());

        // Set the new contract address
        saleAuction = candidateContract;
    }

    /// @dev Sets the reference to the siring auction.
    /// @param _address - Address of siring contract.
    function setSiringAuctionAddress(address _address) external onlyCEO {
        SiringClockAuction candidateContract = SiringClockAuction(_address);

        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117
        require(candidateContract.isSiringClockAuction());

        // Set the new contract address
        siringAuction = candidateContract;
    }

    /// @dev Put a kitty up for auction.
    ///  Does some ownership trickery to create auctions in one tx.
    function createSaleAuction(
        uint256 _kittyId,
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration
    )
        external
        whenNotPaused
    {
        // Auction contract checks input sizes
        // If kitty is already on any auction, this will throw
        // because it will be owned by the auction contract.
        require(_owns(msg.sender, _kittyId));
        // Ensure the kitty is not pregnant to prevent the auction
        // contract accidentally receiving ownership of the child.
        // NOTE: the kitty IS allowed to be in a cooldown.
        require(!isPregnant(_kittyId));
        _approve(_kittyId, saleAuction);
        // Sale auction throws if inputs are invalid and clears
        // transfer and sire approval after escrowing the kitty.
        saleAuction.createAuction(
            _kittyId,
            _startingPrice,
            _endingPrice,
            _duration,
            msg.sender
        );
    }

    /// @dev Put a kitty up for auction to be sire.
    ///  Performs checks to ensure the kitty can be sired, then
    ///  delegates to reverse auction.
    function createSiringAuction(
        uint256 _kittyId,
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration
    )
        external
        whenNotPaused
    {
        // Auction contract checks input sizes
        // If kitty is already on any auction, this will throw
        // because it will be owned by the auction contract.
        require(_owns(msg.sender, _kittyId));
        require(isReadyToBreed(_kittyId));
        _approve(_kittyId, siringAuction);
        // Siring auction throws if inputs are invalid and clears
        // transfer and sire approval after escrowing the kitty.
        siringAuction.createAuction(
            _kittyId,
            _startingPrice,
            _endingPrice,
            _duration,
            msg.sender
        );
    }

    /// @dev Completes a siring auction by bidding.
    ///  Immediately breeds the winning matron with the sire on auction.
    /// @param _sireId - ID of the sire on auction.
    /// @param _matronId - ID of the matron owned by the bidder.
    function bidOnSiringAuction(
        uint256 _sireId,
        uint256 _matronId
    )
        external
        payable
        whenNotPaused
    {
        // Auction contract checks input sizes
        require(_owns(msg.sender, _matronId));
        require(isReadyToBreed(_matronId));
        require(_canBreedWithViaAuction(_matronId, _sireId));

        // Define the current price of the auction.
        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);
        require(msg.value >= currentPrice + autoBirthFee);

        // Siring auction will throw if the bid fails.
        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);
        _breedWith(uint32(_matronId), uint32(_sireId));
    }

    /// @dev Transfers the balance of the sale auction contract
    /// to the KittyCore contract. We use two-step withdrawal to
    /// prevent two transfer calls in the auction bid function.
    function withdrawAuctionBalances() external onlyCLevel {
        saleAuction.withdrawBalance();
        siringAuction.withdrawBalance();
    }
}

/// @title all functions related to creating kittens
contract KittyMinting is KittyAuction {

    // Limits the number of cats the contract owner can ever create.
    uint256 public constant PROMO_CREATION_LIMIT = 5000;
    uint256 public constant GEN0_CREATION_LIMIT = 45000;

    // Constants for gen0 auctions.
    uint256 public constant GEN0_STARTING_PRICE = 10 finney;
    uint256 public constant GEN0_AUCTION_DURATION = 1 days;

    // Counts the number of cats the contract owner has created.
    uint256 public promoCreatedCount;
    uint256 public gen0CreatedCount;

    /// @dev we can create promo kittens, up to a limit. Only callable by COO
    /// @param _genes the encoded genes of the kitten to be created, any value is accepted
    /// @param _owner the future owner of the created kittens. Default to contract COO
    function createPromoKitty(uint256 _genes, address _owner) external onlyCOO {
        address kittyOwner = _owner;
        if (kittyOwner == address(0)) {
             kittyOwner = cooAddress;
        }
        require(promoCreatedCount < PROMO_CREATION_LIMIT);

        promoCreatedCount++;
        _createKitty(0, 0, 0, _genes, kittyOwner);
    }

    /// @dev Creates a new gen0 kitty with the given genes and
    ///  creates an auction for it.
    function createGen0Auction(uint256 _genes) external onlyCOO {
        require(gen0CreatedCount < GEN0_CREATION_LIMIT);

        uint256 kittyId = _createKitty(0, 0, 0, _genes, address(this));
        _approve(kittyId, saleAuction);

        saleAuction.createAuction(
            kittyId,
            _computeNextGen0Price(),
            0,
            GEN0_AUCTION_DURATION,
            address(this)
        );

        gen0CreatedCount++;
    }

    /// @dev Computes the next gen0 auction starting price, given
    ///  the average of the past 5 prices + 50%.
    function _computeNextGen0Price() internal view returns (uint256) {
        uint256 avePrice = saleAuction.averageGen0SalePrice();

        // Sanity check to ensure we don't overflow arithmetic
        require(avePrice == uint256(uint128(avePrice)));

        uint256 nextPrice = avePrice + (avePrice / 2);

        // We never auction for less than starting price
        if (nextPrice < GEN0_STARTING_PRICE) {
            nextPrice = GEN0_STARTING_PRICE;
        }

        return nextPrice;
    }
}

/// @title CryptoKitties: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.
/// @author Axiom Zen (https://www.axiomzen.co)
/// @dev The main CryptoKitties contract, keeps track of kittens so they don't wander around and get lost.
contract KittyCore is KittyMinting {

    // This is the main CryptoKitties contract. In order to keep our code seperated into logical sections,
    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts
    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are
    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping
    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks
    // kitty ownership. The genetic combination algorithm is kept seperate so we can open-source all of
    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.
    // Don't worry, I'm sure someone will reverse engineer it soon enough!
    //
    // Secondly, we break the core contract into multiple files using inheritence, one for each major
    // facet of functionality of CK. This allows us to keep related code bundled together while still
    // avoiding a single giant file with everything in it. The breakdown is as follows:
    //
    //      - KittyBase: This is where we define the most fundamental code shared throughout the core
    //             functionality. This includes our main data storage, constants and data types, plus
    //             internal functions for managing these items.
    //
    //      - KittyAccessControl: This contract manages the various addresses and constraints for operations
    //             that can be executed only by specific roles. Namely CEO, CFO and COO.
    //
    //      - KittyOwnership: This provides the methods required for basic non-fungible token
    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).
    //
    //      - KittyBreeding: This file contains the methods necessary to breed cats together, including
    //             keeping track of siring offers, and relies on an external genetic combination contract.
    //
    //      - KittyAuctions: Here we have the public methods for auctioning or bidding on cats or siring
    //             services. The actual auction functionality is handled in two sibling contracts (one
    //             for sales and one for siring), while auction creation and bidding is mostly mediated
    //             through this facet of the core contract.
    //
    //      - KittyMinting: This final facet contains the functionality we use for creating new gen0 cats.
    //             We can make up to 5000 "promo" cats that can be given away (especially important when
    //             the community is new), and all others can only be created and then immediately put up
    //             for auction via an algorithmically determined starting price. Regardless of how they
    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the
    //             community to breed, breed, breed!

    // Set in case the core contract is broken and an upgrade is required
    address public newContractAddress;

    /// @notice Creates the main CryptoKitties smart contract instance.
    function KittyCore() public {
        // Starts paused.
        paused = true;

        // the creator of the contract is the initial CEO
        ceoAddress = msg.sender;

        // the creator of the contract is also the initial COO
        cooAddress = msg.sender;

        // start with the mythical kitten 0 - so we don't have generation-0 parent issues
        _createKitty(0, 0, 0, uint256(-1), address(0));
    }

    /// @dev Used to mark the smart contract as upgraded, in case there is a serious
    ///  breaking bug. This method does nothing but keep track of the new contract and
    ///  emit a message indicating that the new address is set. It's up to clients of this
    ///  contract to update to the new contract address in that case. (This contract will
    ///  be paused indefinitely if such an upgrade takes place.)
    /// @param _v2Address new address
    function setNewAddress(address _v2Address) external onlyCEO whenPaused {
        // See README.md for updgrade plan
        newContractAddress = _v2Address;
        ContractUpgrade(_v2Address);
    }

    /// @notice No tipping!
    /// @dev Reject all Ether from being sent here, unless it's from one of the
    ///  two auction contracts. (Hopefully, we can prevent user accidents.)
    function() external payable {
        require(
            msg.sender == address(saleAuction) ||
            msg.sender == address(siringAuction)
        );
    }

    /// @notice Returns all the relevant information about a specific kitty.
    /// @param _id The ID of the kitty of interest.
    function getKitty(uint256 _id)
        external
        view
        returns (
        bool isGestating,
        bool isReady,
        uint256 cooldownIndex,
        uint256 nextActionAt,
        uint256 siringWithId,
        uint256 birthTime,
        uint256 matronId,
        uint256 sireId,
        uint256 generation,
        uint256 genes
    ) {
        Kitty storage kit = kitties[_id];

        // if this variable is 0 then it's not gestating
        isGestating = (kit.siringWithId != 0);
        isReady = (kit.cooldownEndBlock <= block.number);
        cooldownIndex = uint256(kit.cooldownIndex);
        nextActionAt = uint256(kit.cooldownEndBlock);
        siringWithId = uint256(kit.siringWithId);
        birthTime = uint256(kit.birthTime);
        matronId = uint256(kit.matronId);
        sireId = uint256(kit.sireId);
        generation = uint256(kit.generation);
        genes = kit.genes;
    }

    /// @dev Override unpause so it requires all external contract addresses
    ///  to be set before contract can be unpaused. Also, we can't have
    ///  newContractAddress set either, because then the contract was upgraded.
    /// @notice This is public rather than external so we can call super.unpause
    ///  without using an expensive CALL.
    function unpause() public onlyCEO whenPaused {
        require(saleAuction != address(0));
        require(siringAuction != address(0));
        require(geneScience != address(0));
        require(newContractAddress == address(0));

        // Actually unpause the contract.
        super.unpause();
    }

    // @dev Allows the CFO to capture the balance available to the contract.
    function withdrawBalance() external onlyCFO {
        uint256 balance = this.balance;
        // Subtract all the currently pregnant kittens we have, plus 1 of margin.
        uint256 subtractFees = (pregnantKitties + 1) * autoBirthFee;

        if (balance > subtractFees) {
            cfoAddress.send(balance - subtractFees);
        }
    }
}		

```

## 3. CryptoZombies

[`www.cryptozombies.io`](http://www.cryptozombies.io)

一款游戏

## 4. Augur Project

Augur 是建立在以太坊平台上的去中心化预测市场平台，也是以太坊平台上第一个众筹的应用，利用 Augur 任何人都可以为任何自己感兴趣的主题创建一个预测市场，并提供初始流动性。Augur 项目于 2015 年 8 月开启代币众筹，一共众筹到 500 万美元，代币名称为 REP。

https://www.augur.net

合约代码地址 https://github.com/AugurProject/augur-core

Token sale contract and tools: https://github.com/AugurProject/token-sale

## 5. Golem

Golem 是一个去中心化的全球算力市场。Golem 于 2016 年 11 月 11 日开启众筹，约半个小时完成众筹上限 82 万 ETH，以当日 ETH71 元人民币的收盘价计算，共筹得约 5822 万元人民币，每枚代币成本约为 0.071 元人民币，代币名称为 GNT。

Golem ICO 众筹合约代码由 Token.sol 和 GNTAllocation.sol 两个文件组成，其中 GNTAllocation.sol 中定义了分配给 Golem 公司和开发者的 Token 数量，主要部分的合约写在 Token.sol 中。

合约源码地址： [`github.com/golemfactory/golem-crowdfunding`](https://github.com/golemfactory/golem-crowdfunding)

## 6. FirstBlood

第一滴血是一个可以让玩家随时随地参与竞赛并且获得赏金的去中心化电竞平台。第一滴血 ICO 于 2016 年 9 月 26 日开始，达成众筹额度仅耗费两分钟，共筹得约 465，313ETH，发放代币 1SF 约 7910 万枚，每枚代币成本约为 0.5 元人民币。

合约源码地址：https://github.com/Firstbloodio/token

## 7. Bancor

Bancor 协议是一种基于以太坊的底层货币协议，通过区块链技术和智能合约实现小型加密数字货币之间的连续流动性和异步价格发现。Bancor 于 2017 年 6 月 13 日开启众筹，数据显示，在 ICO 于 18:00 结束时已经筹集了超过 39 万个以太，发行了将近 8000 万的 BNT。

合约源码地址： [`github.com/bancorprotocol/contracts`](https://github.com/bancorprotocol/contracts)

## 第 23 章 FAQ

## 1. Error: etherbase missing: etherbase address must be explicitly specified

```

ERROR[02-10|16:12:45] Cannot start mining without etherbase    err="etherbase address must be explicitly specified"
Error: etherbase missing: etherbase address must be explicitly specified
    at web3.js:3143:20
    at web3.js:6347:15
    at web3.js:5081:36
    at <anonymous>:1:1		

```

原因是当前环境没有账户，需要建立一个账户

```

> personal.newAccount("chen")
"0x1b94732fca6f62a4f74fb2f7c80bfc89d567fdfb"

```

现在启动挖矿就不会出现问题了

## 第 23 章 FAQ

## 1. Error: etherbase missing: etherbase address must be explicitly specified

```

ERROR[02-10|16:12:45] Cannot start mining without etherbase    err="etherbase address must be explicitly specified"
Error: etherbase missing: etherbase address must be explicitly specified
    at web3.js:3143:20
    at web3.js:6347:15
    at web3.js:5081:36
    at <anonymous>:1:1		

```

原因是当前环境没有账户，需要建立一个账户

```

> personal.newAccount("chen")
"0x1b94732fca6f62a4f74fb2f7c80bfc89d567fdfb"

```

现在启动挖矿就不会出现问题了

## 3. Error: authentication needed: password or unlock

```

> eth.sendTransaction({from: '0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6', to: '0xe8abf98484325fd6afc59b804ac15804b978e607', value: web3.toWei(1, "ether")})
Error: authentication needed: password or unlock
    at web3.js:3143:20
    at web3.js:6347:15
    at web3.js:5081:36
    at <anonymous>:1:1			

```

解锁转出账号

```

> personal.unlockAccount("0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6", "your_password", 300)
true
> eth.sendTransaction({from: '0x83fda0ba7e6cfa8d7319d78fa0e6b753a2bcb5a6', to: '0xe8abf98484325fd6afc59b804ac15804b978e607', value: web3.toWei(1, "ether")})
"0xd9e8c8fdc71e24ee8052048de4ff0acd7157b872393f37344c8ec2083f3fe48f"			

```

## 4. 新增节点后不生效

新增节点显示 true ,但是使用 admin.peers 查看不到。

```

> admin.addPeer("enode://c4586276391b3c88ec23889d1bc825d0c7d69bd5765d4545686f835608068b8dc48799d2686a04ea0f9e17aed099bf9b56935679fa6493e9b17151624a320714@172.16.0.17:30303")
true
> admin.peers
[]			

```

查看节点，如果发现 ip: "::" 同时 discovery: 0

```

> admin.nodeInfo
{
  enode: "enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@[::]:30303?discport=0",
  id: "9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527",
  ip: "::",
  listenAddr: "[::]:30303",
  name: "Geth/v1.7.3-stable-4bb3c89d/linux-amd64/go1.9.1",
  ports: {
    discovery: 0,
    listener: 30303
  },
  protocols: {
    eth: {
      difficulty: 131072,
      genesis: "0x611596e7979cd4e7ca1531260fa706093a5492ecbdf58f20a39545397e424d04",
      head: "0x611596e7979cd4e7ca1531260fa706093a5492ecbdf58f20a39545397e424d04",
      network: 123456
    }
  }
}
> 

```

解决方案启动时可能增加了 --nodiscover 参数，去掉参数后可以解决。

有三种方法新增节点

第一种，启动指定

```

geth --bootnodes enode://pubkey1@ip1:port1,enode://pubkey2@ip2:port2,enode://pubkey3@ip3:port3

```

第二种，在控制台中添加

```

> admin.addPeer('enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@172.16.0.1:30303')				

```

第三种，在文件 ~/.ethereum/geth/static-nodes.json 中添加节点数据

```

[
  "enode://9f6490ffb5236f2ddc5710ae73d47c740e0a3644bbd2d67029cf4a6c4693d2f470b642fd2cc3507f7e851df60aaeb730a1270b7a477f91ec5b6b17a8a4b40527@172.16.0.17:30303",
  "enode://pubkey@ip:port"
]

```

这个文件内容是一个数组，类似 ["","",""] 。

## 5. Unhandled rejection Error: Returned error: The method personal_unlockAccount does not exist/is not available

```

> Unhandled rejection Error: Returned error: The method personal_unlockAccount does not exist/is not available
    at Object.ErrorResponse (/Users/neo/ethereum/web3/node_modules/web3-core-helpers/src/errors.js:29:16)
    at /Users/neo/ethereum/web3/node_modules/web3-core-requestmanager/src/index.js:137:36
    at XMLHttpRequest.request.onreadystatechange (/Users/neo/ethereum/web3/node_modules/web3-providers-http/src/index.js:77:13)
    at XMLHttpRequestEventTarget.dispatchEvent (/Users/neo/ethereum/web3/node_modules/xhr2/lib/xhr2.js:64:18)
    at XMLHttpRequest._setReadyState (/Users/neo/ethereum/web3/node_modules/xhr2/lib/xhr2.js:354:12)
    at XMLHttpRequest._onHttpResponseEnd (/Users/neo/ethereum/web3/node_modules/xhr2/lib/xhr2.js:509:12)
    at IncomingMessage.<anonymous> (/Users/neo/ethereum/web3/node_modules/xhr2/lib/xhr2.js:469:24)
    at IncomingMessage.emit (events.js:165:20)
    at endReadableNT (_stream_readable.js:1101:12)
    at process._tickCallback (internal/process/next_tick.js:152:19)

```

解决方法

```

$ geth --rpc --rpcapi personal,db,eth,net,web3

```

在 --rpcapi 选项中增加 personal

## 6. Error: exceeds block gas limit

```

neo@MacBook-Pro ~/ethereum/truffle/Conference % truffle migrate --reset
\Using network 'development'.

Running migration: 1_initial_conference.js
  Deploying Conference...
  ... undefined
Error encountered, bailing. Network state unknown. Review successful transactions manually.
Error: exceeds block gas limit
    at Object.InvalidResponse (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1)
    at /usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/requestmanager.js:86:1
    at /usr/local/lib/node_modules/truffle/build/webpack:/~/truffle-migrate/index.js:225:1
    at /usr/local/lib/node_modules/truffle/build/webpack:/~/truffle-provider/wrapper.js:134:1
    at XMLHttpRequest.request.onreadystatechange (/usr/local/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/httpprovider.js:128:1)
    at XMLHttpRequestEventTarget.dispatchEvent (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:64:1)
    at XMLHttpRequest._setReadyState (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:354:1)
    at XMLHttpRequest._onHttpResponseEnd (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:509:1)
    at IncomingMessage.<anonymous> (/usr/local/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:469:1)
    at IncomingMessage.emit (events.js:165:20)

```

```

neo@MacBook-Pro ~/ethereum/truffle/contracts % geth attach            
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.1-stable/darwin-amd64/go1.10
coinbase: 0x5c18a33df2cc41a1beddc91133b8422e89f041b7
at block: 5381 (Wed, 28 Feb 2018 23:20:05 CST)
 datadir: /Users/neo/Library/Ethereum
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

> web3.eth.getBlock("pending").gasLimit
4712388		

```

或者

```

$ truffle console
truffle(development)> web3.eth.getBlock("pending").gasLimit
6712390

```

修改 truffle.js 文件，加入 gas 值为上面所查询的值:

```

module.exports = {
  networks: {
    development: {
      host: "localhost",
      port: 8545,
      gas: 6712390,
      network_id: "*" // Match any network id
    }
  }
};			

```

## 7. Migrations.sol:11:3: Warning: Defining constructors as functions with the same name as the contract is deprecated. Use "constructor(...) { ... }" instead.

Solidity 0.4.23 合约构造方法与之前的版本不同

```

[ethereum@netkiller truffle]$ cat contracts/Migrations.sol
pragma solidity ⁰.4.17;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function Migrations() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}

```

```

[ethereum@netkiller truffle]$ cat contracts/Migrations.sol
pragma solidity ⁰.4.17;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  constructor() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}

```

## 8. Exception in thread "main" rx.exceptions.OnErrorNotImplementedException: Invalid response received: okhttp3.internal.http.RealResponseBody@6c25e6c4

异常出现在 Subscription 订阅的时候，原因是 web3j Subscription 操作只能使用 ipc, rpc， infura.io 不支持该操作。

```

Exception in thread "main" rx.exceptions.OnErrorNotImplementedException: Invalid response received: okhttp3.internal.http.RealResponseBody@6c25e6c4
	at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:386)
	at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:383)
	at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)
	at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:153)
	at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:115)
	at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)
	at rx.internal.operators.OnSubscribeFilter$FilterSubscriber.onError(OnSubscribeFilter.java:90)
	at rx.internal.operators.OperatorMerge$MergeSubscriber.reportError(OperatorMerge.java:266)
	at rx.internal.operators.OperatorMerge$MergeSubscriber.checkTerminate(OperatorMerge.java:818)
	at rx.internal.operators.OperatorMerge$MergeSubscriber.emitLoop(OperatorMerge.java:579)
	at rx.internal.operators.OperatorMerge$MergeSubscriber.emit(OperatorMerge.java:568)
	at rx.internal.operators.OperatorMerge$MergeSubscriber.onError(OperatorMerge.java:276)
	at rx.internal.operators.OnSubscribeMap$MapSubscriber.onError(OnSubscribeMap.java:88)
	at rx.Observable.unsafeSubscribe(Observable.java:10334)
	at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)
	at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)
	at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48)
	at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30)
	at rx.Observable.unsafeSubscribe(Observable.java:10327)
	at rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:45)
	at rx.internal.operators.OnSubscribeFilter.call(OnSubscribeFilter.java:30)
	at rx.Observable.unsafeSubscribe(Observable.java:10327)
	at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48)
	at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33)
	at rx.Observable.subscribe(Observable.java:10423)
	at rx.Observable.subscribe(Observable.java:10390)
	at rx.Observable.subscribe(Observable.java:10195)
	at cn.netkiller.example.ethereum.subscription.PendingTest.main(PendingTest.java:20)
Caused by: org.web3j.protocol.exceptions.ClientConnectionException: Invalid response received: okhttp3.internal.http.RealResponseBody@6c25e6c4
	at org.web3j.protocol.http.HttpService.performIO(HttpService.java:114)
	at org.web3j.protocol.Service.send(Service.java:31)
	at org.web3j.protocol.core.Request.send(Request.java:71)
	at org.web3j.protocol.core.filters.PendingTransactionFilter.sendRequest(PendingTransactionFilter.java:24)
	at org.web3j.protocol.core.filters.Filter.run(Filter.java:45)
	at org.web3j.protocol.rx.JsonRpc2_0Rx.run(JsonRpc2_0Rx.java:73)
	at org.web3j.protocol.rx.JsonRpc2_0Rx.lambda$ethPendingTransactionHashObservable$1(JsonRpc2_0Rx.java:55)
	at rx.Observable.unsafeSubscribe(Observable.java:10327)
	... 14 more

```