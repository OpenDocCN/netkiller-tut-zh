# 部分 VI. PostgreSQL

PostgreSQL 实用实例参考

## 第 59 章 PostgreSQL 安装

## Ubuntu 12.04.1 LTS 安装

安装环境

PostgreSQL 9.1

**$ sudo apt-get install postgresql**

```
$ sudo apt-get install postgresql

```

更改 postgres 管理员用户密码

```
$ sudo passwd postgres
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully

```

然后切换到 postgres 用户环境

```
$ su - postgres
Password:
Added user postgres.

```

进入 psql 客户款, PostgreSQL 的 psql 命令相当于 sqlplus,mysql 命令

```
$ psql
psql (9.1.6)
Type "help" for help.

postgres=#

```

退出\q

```
postgres=# \q

```

## YUM 默认源安装

```
# yum search postgresql | grep ^postgresql
postgresql-odbc.x86_64 : PostgreSQL ODBC driver
postgresql.i686 : PostgreSQL client programs
postgresql.x86_64 : PostgreSQL client programs
postgresql-contrib.x86_64 : Contributed modules distributed with PostgreSQL
postgresql-devel.i686 : PostgreSQL development header files and libraries
postgresql-devel.x86_64 : PostgreSQL development header files and libraries
postgresql-docs.x86_64 : Extra documentation for PostgreSQL
postgresql-ip4r.x86_64 : IPv4 and IPv4 range index types for PostgreSQL
postgresql-jdbc.noarch : JDBC driver for PostgreSQL
postgresql-libs.i686 : The shared libraries required for any PostgreSQL clients
postgresql-libs.x86_64 : The shared libraries required for any PostgreSQL
postgresql-pgpool-II.i686 : Pgpool is a connection pooling/replication server
postgresql-pgpool-II.x86_64 : Pgpool is a connection pooling/replication server
postgresql-pgpool-II-recovery.x86_64 : PGPool recovery add-on for PostgreSQL
postgresql-plparrot.x86_64 : A PostgreSQL procedural language for the Parrot
postgresql-plperl.x86_64 : The Perl procedural language for PostgreSQL
postgresql-plpython.x86_64 : The Python procedural language for PostgreSQL
postgresql-plruby.x86_64 : PostgreSQL Ruby Procedural Language
postgresql-pltcl.x86_64 : The Tcl procedural language for PostgreSQL
postgresql-server.x86_64 : The programs needed to create and run a PostgreSQL
postgresql-test.x86_64 : The test suite distributed with PostgreSQL
postgresql_autodoc.noarch : PostgreSQL AutoDoc Utility
postgresql-pgpool-II-devel.i686 : The development files for pgpool-II
postgresql-pgpool-II-devel.x86_64 : The development files for pgpool-II
postgresql-plruby-doc.x86_64 : Documentation for plruby

```

默认 YUM 源上面只有 8.4.13

```
# yum info postgresql-server
Loaded plugins: fastestmirror, presto, refresh-packagekit
Loading mirror speeds from cached hostfile
 * base: centos.uhost.hk
 * epel: mirror01.idc.hinet.net
 * extras: centos.uhost.hk
 * updates: centos.uhost.hk
Installed Packages
Name        : postgresql-server
Arch        : x86_64
Version     : 8.4.13
Release     : 1.el6_3
Size        : 14 M
Repo        : installed
From repo   : base
Summary     : The programs needed to create and run a PostgreSQL server
URL         : http://www.postgresql.org/
License     : PostgreSQL
Description : The postgresql-server package includes the programs needed to create
            : and run a PostgreSQL server, which will in turn allow you to create
            : and maintain PostgreSQL databases.  PostgreSQL is an advanced
            : Object-Relational database management system (DBMS) that supports
            : almost all SQL constructs (including transactions, subselects and
            : user-defined types and functions). You should install
            : postgresql-server if you want to create and maintain your own
            : PostgreSQL databases and/or your own PostgreSQL server. You also need
            : to install the postgresql package.

```

```
# yum install postgresql-server

# chkconfig postgresql on
# service postgresql initdb
# service postgresql start

```

## PostgreSQL 官方 YUM 源安装

CentOS 6.4 环境 YUM 地址 http://yum.postgresql.org/

### 9.2

```
# yum install http://yum.postgresql.org/9.2/redhat/rhel-6-x86_64/pgdg-centos92-9.2-6.noarch.rpm
# yum list postgres*

# yum install postgresql92-server postgresql92

chkconfig postgresql-9.2 on
service postgresql-9.2 initdb
service postgresql-9.2 start

```

配置文件的位置

```
# ls /var/lib/pgsql/9.2/data/*.conf
/var/lib/pgsql/9.2/data/pg_hba.conf  /var/lib/pgsql/9.2/data/pg_ident.conf  /var/lib/pgsql/9.2/data/postgresql.conf

```

### 9.3

```
# yum install http://yum.postgresql.org/9.3/redhat/rhel-6-x86_64/pgdg-centos93-9.3-1.noarch.rpm
# yum install postgresql93-server postgresql93

```

```
# chkconfig postgresql-9.3 on
# service postgresql-9.3 initdb
# service postgresql-9.3 start			

```

9.2 升级到 9.3

备份数据库

```
# su - postgres
$ pg_dump -f wechat.sql wechat

```

升级数据库

关闭 9.2，启动 9。3

```
# chkconfig postgresql-9.2 off
# service postgresql-9.2 stop

# service postgresql-9.3 start

```

回复数据库

```
# su - postgres
$ createuser -r -s -P dba
$ createuser -P wechat
$ createdb -E UTF8 -O wechat wechat
$ cat wechat.sql | psql wechat

```

合并配置文件

```
$ cp 9.3/data/postgresql.conf{,.original}
$ cp 9.3/data/pg_hba.conf{,.original}
$ vimdiff 9.2/data/postgresql.conf 9.3/data/postgresql.conf
$ vimdiff 9.2/data/pg_hba.conf 9.3/data/pg_hba.conf

```

注意 vimdiff 命令是文件对比于合并工具，建议你选择你比较熟悉的工具。

```
# service postgresql-9.3 restart

```

### 9.4

CentOS 6

https://github.com/oscm/shell/blob/master/database/postgresql/postgresql93-centos6.sh

CentOS 7

https://github.com/oscm/shell/blob/master/database/postgresql/postgresql93-centos7.sh

```

#!/bin/bash

# CentOS 7
yum install -y https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm
yum install -y postgresql96-server postgresql96-contrib

systemctl initdb postgresql-9.6
chkconfig postgresql-9.6 on

cp /var/lib/pgsql/9.6/data/postgresql.conf{,.original}
cp /var/lib/pgsql/9.6/data/pg_hba.conf{,.original}
cp /var/lib/pgsql/9.6/data/pg_ident.conf{,.original}

sed -i "s/#listen_addresses = 'localhost'/listen_addresses = '*'/" /var/lib/pgsql/9.6/data/postgresql.conf

systemctl start postgresql-9.6

iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 5432 -j ACCEPT
systemctl save iptables			

```

一键安装

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/database/postgresql/postgresql93-centos7.sh | bash

```

### 9.6

https://github.com/oscm/shell/blob/master/database/postgresql/postgresql96-centos7.sh

一键安装

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/database/postgresql/postgresql96-centos7.sh | bash

```

### PostgreSQL 10

一键安装 PostgreSQL 10

```

curl -s https://raw.githubusercontent.com/oscm/shell/master/database/postgresql/10/repository.sh | bash
curl -s https://raw.githubusercontent.com/oscm/shell/master/database/postgresql/10/postgresql-server.sh | bash

```

监听所有适配器地址

```
curl -s https://raw.githubusercontent.com/oscm/shell/master/database/postgresql/10/listen_addresses.all.sh | bash

```

创建数据库

```
CREATE ROLE test LOGIN PASSWORD 'test' NOSUPERUSER NOINHERIT NOCREATEDB NOCREATEROLE;
CREATE DATABASE test WITH OWNER = test ENCODING = 'UTF8' TABLESPACE = pg_default;

```

配置访问控制列表 /var/lib/pgsql/10/data/pg_hba.conf 加入

```
# vim /var/lib/pgsql/10/data/pg_hba.conf
host    *               dba         0.0.0.0/0       md5     
host    test            test        0.0.0.0/0       md5

```

确认防火墙已经放行 5432 端口

# cat /etc/sysconfig/iptables | grep 5432 -A INPUT -s 172.16.0.0/24 -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT

例 59.1. Example for /var/lib/pgsql/10/data/pg_hba.conf

```
# cat /var/lib/pgsql/10/data/pg_hba.conf
# PostgreSQL Client Authentication Configuration File
# ===================================================
#
# Refer to the "Client Authentication" section in the PostgreSQL
# documentation for a complete description of this file.  A short
# synopsis follows.
#
# This file controls: which hosts are allowed to connect, how clients
# are authenticated, which PostgreSQL user names they can use, which
# databases they can access.  Records take one of these forms:
#
# local      DATABASE  USER  METHOD  [OPTIONS]
# host       DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostssl    DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
# hostnossl  DATABASE  USER  ADDRESS  METHOD  [OPTIONS]
#
# (The uppercase items must be replaced by actual values.)
#
# The first field is the connection type: "local" is a Unix-domain
# socket, "host" is either a plain or SSL-encrypted TCP/IP socket,
# "hostssl" is an SSL-encrypted TCP/IP socket, and "hostnossl" is a
# plain TCP/IP socket.
#
# DATABASE can be "all", "sameuser", "samerole", "replication", a
# database name, or a comma-separated list thereof. The "all"
# keyword does not match "replication". Access to replication
# must be enabled in a separate record (see example below).
#
# USER can be "all", a user name, a group name prefixed with "+", or a
# comma-separated list thereof.  In both the DATABASE and USER fields
# you can also write a file name prefixed with "@" to include names
# from a separate file.
#
# ADDRESS specifies the set of hosts the record matches.  It can be a
# host name, or it is made up of an IP address and a CIDR mask that is
# an integer (between 0 and 32 (IPv4) or 128 (IPv6) inclusive) that
# specifies the number of significant bits in the mask.  A host name
# that starts with a dot (.) matches a suffix of the actual host name.
# Alternatively, you can write an IP address and netmask in separate
# columns to specify the set of hosts.  Instead of a CIDR-address, you
# can write "samehost" to match any of the server's own IP addresses,
# or "samenet" to match any address in any subnet that the server is
# directly connected to.
#
# METHOD can be "trust", "reject", "md5", "password", "scram-sha-256",
# "gss", "sspi", "ident", "peer", "pam", "ldap", "radius" or "cert".
# Note that "password" sends passwords in clear text; "md5" or
# "scram-sha-256" are preferred since they send encrypted passwords.
#
# OPTIONS are a set of options for the authentication in the format
# NAME=VALUE.  The available options depend on the different
# authentication methods -- refer to the "Client Authentication"
# section in the documentation for a list of which options are
# available for which authentication methods.
#
# Database and user names containing spaces, commas, quotes and other
# special characters must be quoted.  Quoting one of the keywords
# "all", "sameuser", "samerole" or "replication" makes the name lose
# its special character, and just match a database or username with
# that name.
#
# This file is read on server startup and when the server receives a
# SIGHUP signal.  If you edit the file on a running system, you have to
# SIGHUP the server for the changes to take effect, run "pg_ctl reload",
# or execute "SELECT pg_reload_conf()".
#
# Put your actual configuration here
# ----------------------------------
#
# If you want to allow non-local connections, you need to add more
# "host" records.  In that case you will also need to make PostgreSQL
# listen on a non-local interface via the listen_addresses
# configuration parameter, or via the -i or -h command line switches.

# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    *		dba         0.0.0.0/0       md5
host    test		test        0.0.0.0/0       md5

# "local" is for Unix domain socket connections only
local   all             all                                     peer
# IPv4 local connections:
host    all             all             127.0.0.1/32            ident
# IPv6 local connections:
host    all             all             ::1/128                 ident
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                                     peer
host    replication     all             127.0.0.1/32            ident
host    replication     all             ::1/128                 ident				

```

## PostgreSQL 配置

su 到 postgres 用户

```
$ su - postgres
Password:
$ pwd
/var/lib/postgresql
$

```

备份配置文件，防止修改过程中损毁

```
cp /etc/postgresql/9.1/main/postgresql.conf /etc/postgresql/9.1/main/postgresql.conf.original
cp /etc/postgresql/9.1/main/pg_hba.conf /etc/postgresql/9.1/main/pg_hba.conf.original

```

### postgresql.conf

启用 tcp/ip 连接，去掉下面注释,修改为你需要的 IP 地址，默认为 localhost

```
listen_addresses = 'localhost'

```

如果有多个网络适配器可以指定 'ip' 或 '*' 任何接口上的 IP 地址都可能 listen.

```
$ sudo vim /etc/postgresql/9.1/main/postgresql.conf

listen_addresses = '*'

```

### pg_hba.conf

pg_hba.conf 配置文件的权限需要注意以下，-rw-r----- 1 postgres postgres 4649 Dec 5 18:00 pg_hba.conf

```
$ ll /etc/postgresql/9.1/main/
total 52
drwxr-xr-x 2 postgres postgres  4096 Dec  6 09:40 ./
drwxr-xr-x 3 postgres postgres  4096 Dec  5 18:00 ../
-rw-r--r-- 1 postgres postgres   316 Dec  5 18:00 environment
-rw-r--r-- 1 postgres postgres   143 Dec  5 18:00 pg_ctl.conf
-rw-r----- 1 postgres postgres  4649 Dec  5 18:00 pg_hba.conf
-rw-r----- 1 postgres postgres  1636 Dec  5 18:00 pg_ident.conf
-rw-r--r-- 1 postgres postgres 19259 Dec  5 18:00 postgresql.conf
-rw-r--r-- 1 postgres postgres   378 Dec  5 18:00 start.conf

```

pg_hba.conf 配置文件负责访问权限控制

```
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     peer
# IPv4 local connections:
host    all             all             127.0.0.1/32            md5
# IPv6 local connections:
host    all             all             ::1/128                 md5

```

TYPE

local 本地使用 unix/socket 方式连接, host 使用 tcp/ip socket 方式连接

DATABASE

数据库名.

USER

用户名.

ADDRESS

允许连接的 IP 地址，可以使用子网掩码.

METHOD

认真加密方式.

下面我们做一个简单测试，首先配置 pg_hba。conf 文件

```
$ sudo vi /etc/postgresql/9.1/main/pg_hba.conf
host    *			dba         0.0.0.0/0       md5
host    test		test        0.0.0.0/0       md5

```

运行创建数据,用户 的 SQL 语句

```
CREATE ROLE test LOGIN PASSWORD 'test' NOSUPERUSER NOINHERIT NOCREATEDB NOCREATEROLE;

CREATE DATABASE test WITH OWNER = test ENCODING = 'UTF8' TABLESPACE = pg_default;

```

进入 psql

```
$ psql
psql (9.1.6)
Type "help" for help.

postgres=# CREATE ROLE test LOGIN PASSWORD 'test' NOSUPERUSER NOINHERIT NOCREATEDB NOCREATEROLE;
CREATE ROLE
postgres=# CREATE DATABASE test WITH OWNER = test ENCODING = 'UTF8' TABLESPACE = pg_default;
CREATE DATABASE
postgres=# \q

```

使用 psql 登录

```

$ psql -hlocalhost -Utest test
Password for user test:
psql (9.1.6)
SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)
Type "help" for help.

test=> \l
                                  List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-----------+----------+----------+-------------+-------------+-----------------------
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
           |          |          |             |             | postgres=CTc/postgres
 test      | test     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
(4 rows)

test=>

```

## 创建 dba 用户

创建一个远程维护数据库 dba 用户，具有创建数据库与创建用户的权限

```
CREATE USER dba PASSWORD 'dba' CREATEDB CREATEUSER;

```

进入 psql

```
$ psql
psql (9.1.6)
Type "help" for help.

postgres=# CREATE USER dba PASSWORD 'dba' CREATEDB CREATEUSER;
CREATE ROLE
postgres=# \q

```

使用 psql 登录

```
$ psql -hlocalhost -Udba postgres
Password for user dba:
psql (9.1.6)
SSL connection (cipher: DHE-RSA-AES256-SHA, bits: 256)
Type "help" for help.

postgres=#

```

## 第 60 章 PostgreSQL 命令

## psql - PostgreSQL interactive terminal

```

postgres=# \?
一般性
  \copyright            显示 PostgreSQL 的使用和发行许可条款
  \errverbose            以最冗长的形式显示最近的错误消息
  \g [文件] or;     执行查询 (并把结果写入文件或 |管道)
  \gexec                 执行策略，然后执行其结果中的每个值
  \gset [PREFIX]     执行查询并把结果存到 psql 变量中
  \q             退出 psql
  \crosstabview [COLUMNS] 执行查询并且以交叉表显示结果
  \watch [SEC]          每隔 SEC 秒执行一次查询

帮助
  \? [commands]          显示反斜线命令的帮助
  \? options             显示 psql 命令行选项的帮助
  \? variables           显示特殊变量的帮助
  \h [名称]          SQL 命令语法上的说明，用*显示全部命令的语法说明

查询缓存区
  \e [FILE] [LINE]        使用外部编辑器编辑查询缓存区(或文件)
  \ef [FUNCNAME [LINE]]   使用外部编辑器编辑函数定义
  \ev [VIEWNAME [LINE]]  用外部编辑器编辑视图定义
  \p                    显示查询缓存区的内容
  \r                    重置(清除)查询缓存区
  \w 文件          将查询缓存区的内容写入文件

输入/输出
  \copy ...             执行 SQL COPY，将数据流发送到客户端主机
  \echo [字符串]       将字符串写到标准输出
  \i 文件          从文件中执行命令
  \ir FILE               与 \i 类似, 但是相对于当前脚本的位置
  \o [文件]        将全部查询结果写入文件或 |管道
  \qecho [字符串]      将字符串写到查询输出串流(参考 \o)

资讯性
  (选项: S = 显示系统对象, + = 其余的详细信息)
  \d[S+]          		列出表,视图和序列
  \d[S+]  				名称      描述表，视图，序列，或索引
  \da[S]  [模式]    		列出聚合函数
  \dA[+]  [PATTERN]     list access methods
  \db[+]  [模式]     	列出表空间
  \dc[S+] [PATTERN]     列表转换
  \dC[+]  [PATTERN]     列出类型强制转换
  \dd[S]  [PATTERN]     显示没有在别处显示的对象描述
  \ddp     [模式]    	列出默认权限
  \dD[S+] [PATTERN]     列出共同值域
  \det[+] [PATTERN]     列出引用表
  \des[+] [模式]    		列出外部服务器
  \deu[+] [模式]     	列出用户映射
 \dew[+] [模式]       	列出外部数据封装器
   \df[antw][S+] [模式]  列出[只包括 聚合/常规/触发器/窗口]函数
  \dF[+]  [模式]   		列出文本搜索配置
  \dFd[+] [模式]     	列出文本搜索字典
 \dFp[+] [模式]     		列出文本搜索解析器
  \dFt[+] [模式]   		列出文本搜索模版
  \dg[S+] [PATTERN]     列出角色
 \di[S+] [模式]  		列出索引
  \dl                   列出大对象， 功能与\lo_list 相同
  \dL[S+] [PATTERN]     列出所有过程语言
  \dm[S+] [PATTERN]     列出所有物化视图
  \dn[S+] [PATTERN]     列出所有模式
  \do[S]  [模式]   		列出运算符
  \dO[S+] [PATTERN]     列出所有校对规则
  \dp     [模式]     	列出表，视图和序列的访问权限
  \drds [模式 1 [模式 2]] 	列出每个数据库的角色设置
  \ds[S+] [模式]    		列出序列
  \dt[S+] [模式]     	列出表
  \dT[S+] [模式]  		列出数据类型
  \du[S+] [PATTERN]     列出角色
  \dv[S+] [模式]   		列出视图
  \dE[S+] [PATTERN]     列出引用表
  \dx[+]  [PATTERN]     列出扩展
  \dy     [PATTERN]     列出所有事件触发器
  \l[+]   [PATTERN]     列出所有数据库
  \sf[+]  FUNCNAME      显示一个函数的定义
  \sv[+]  VIEWNAME      显示一个视图的定义
  \z      [模式]    		和\dp 的功能相同

格式化
  \a                  	在非对齐模式和对齐模式之间切换
  \C [字符串]        	设置表的标题，或如果没有的标题就取消
  \f [字符串]         	显示或设定非对齐模式查询输出的字段分隔符
  \H                    切换 HTML 输出模式 (目前是 关闭)
  \pset [NAME [VALUE]]  设置表输出选项
                         (NAME := {format|border|expanded|fieldsep|fieldsep_zero|footer|null|
                         numericlocale|recordsep|recordsep_zero|tuples_only|title|tableattr|pager|
                         unicode_border_linestyle|unicode_column_linestyle|unicode_header_linestyle})
  \t [开|关]       		只显示记录 (目前是 关闭)
  \T [字符串]         	设置 HTML <表格>标签属性, 或者如果没有的话取消设置
  \x [on|off|auto]      切换扩展输出模式(目前是 关闭)

连接
  \c[onnect] {[DBNAME|- USER|- HOST|- PORT|-] | conninfo}
						连接到新数据库（当前是"postgres"）
  \encoding [编码名称] 	显示或设定客户端编码
  \password [USERNAME]  安全地为用户更改口令
  \conninfo              显示当前连接的相关信息

操作系统
  \cd [目录]     		更改目前的工作目录
  \setenv NAME [VALUE]  设置或清空环境变量
 \timing [开|关]       	切换命令计时开关 (目前是 关闭)
  \! [命令]      		在 shell 中执行命令或启动一个交互式 shell

变量
  \prompt [文本] 名称 	提示用户设定内部变量
  \set [名称 [值数]] 		设定内部变量，若无参数则列出全部变量
  \unset 名称   			清空(删除)内部变量

大对象
  \lo_export LOBOID 文件
  \lo_import 文件 [注释]
  \lo_list
  \lo_unlink LOBOID   	大对象运算

```

## 第 61 章 Database Administration

## User Account Management

### Create User

```
CREATE USER user [IDENTIFIED BY [PASSWORD] 'password']
    [, user [IDENTIFIED BY [PASSWORD] 'password']] ...

```

```
CREATE USER 'test'@'xxx.xxx.xxx.xxx' IDENTIFIED BY  'your_password';

```

```
CREATE USER 'root'@'192.168.1.%' IDENTIFIED BY 'password';

```

add a new user by grant

```

GRANT ALL PRIVILEGES ON opencart.* TO 'neo'@'localhost' IDENTIFIED BY 'chen' WITH GRANT OPTION;

GRANT ALL PRIVILEGES ON *.* TO 'neo'@'localhost' IDENTIFIED BY 'chen' WITH GRANT OPTION;

FLUSH PRIVILEGES;

```

MySQL 8.0

```

mysql> CREATE USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'pMQiEge1ikst7S_6tlXzBOmt_4b';
Query OK, 0 rows affected (0.06 sec)

mysql> grant all on *.* to 'root'@'%';
Query OK, 0 rows affected (0.11 sec)

```

### Drop User

```
DROP USER user [, user] ...

```

```

mysql> drop user 'root'@'%';
Query OK, 0 rows affected (0.02 sec)

mysql> drop user admin@'localhost';
Query OK, 0 rows affected (0.00 sec)

mysql> drop user admin@'127.0.0.1';
Query OK, 0 rows affected (0.00 sec)

```

### Rename User

```
RENAME USER old_user TO new_user [, old_user TO new_user] ...

```

### SET PASSWORD

mysql 5.7 之前的版本

```
SET PASSWORD FOR 'bob'@'%.loc.gov' = PASSWORD('newpass');

SET PASSWORD FOR 'root'@'%' = PASSWORD('co2uqAMAho1aSOS62146Xoci6ogu4I');

```

MySQL 5.7

```
ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password';		

```

## Access Privilege System

```
global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
OR routine privileges

```

```
Table 12.1\. Permissible Privileges for GRANT and REVOKE

Privilege	Meaning
ALL [PRIVILEGES]	Grant all privileges at specified access level except GRANT OPTION
ALTER	Enable use of ALTER TABLE
ALTER ROUTINE	Enable stored routines to be altered or dropped
CREATE	Enable database and table creation
CREATE ROUTINE	Enable stored routine creation
CREATE TABLESPACE	Enable tablespaces and log file groups to be created, altered, or dropped
CREATE TEMPORARY TABLES	Enable use of CREATE TEMPORARY TABLE
CREATE USER	Enable use of CREATE USER, DROP USER, RENAME USER, and REVOKE ALL PRIVILEGES
CREATE VIEW	Enable views to be created or altered
DELETE	Enable use of DELETE
DROP	Enable databases, tables, and views to be dropped
EVENT	Enable use of events for the Event Scheduler
EXECUTE	Enable the user to execute stored routines
FILE	Enable the user to cause the server to read or write files
GRANT OPTION	Enable privileges to be granted to or removed from other accounts
INDEX	Enable indexes to be created or dropped
INSERT	Enable use of INSERT
LOCK TABLES	Enable use of LOCK TABLES on tables for which you have the SELECT privilege
PROCESS	Enable the user to see all processes with SHOW PROCESSLIST
PROXY	Enable user proxying
REFERENCES	Not implemented
RELOAD	Enable use of FLUSH operations
REPLICATION CLIENT	Enable the user to ask where master or slave servers are
REPLICATION SLAVE	Enable replication slaves to read binary log events from the master
SELECT	Enable use of SELECT
SHOW DATABASES	Enable SHOW DATABASES to show all databases
SHOW VIEW	Enable use of SHOW CREATE VIEW
SHUTDOWN	Enable use of mysqladmin shutdown
SUPER	Enable use of other administrative operations such as CHANGE MASTER TO, KILL, PURGE BINARY LOGS, SET GLOBAL, and mysqladmin debug command
TRIGGER	Enable trigger operations
UPDATE	Enable use of UPDATE
USAGE	Synonym for “no privileges”

```

[`dev.mysql.com/doc/refman/5.5/en/grant.html#grant-table-privileges`](http://dev.mysql.com/doc/refman/5.5/en/grant.html#grant-table-privileges)

REPLICATION CLIENT 与 REPLICATION SLAVE 区别，前者只能使用 SHOW MASTER STATUS 和 SHOW SLAVE STATUS 命令监控复制状态，后者才能从主库复制 binlog.

### SHOW GRANTS

```

mysql> SHOW GRANTS FOR 'root'@'localhost';
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------+
1 row in set (0.00 sec)

```

```

mysql> show grants;
+---------------------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------------------+
1 row in set (0.00 sec)

```

### show privileges

```

mysql> show privileges;
+-------------------------+---------------------------------------+-------------------------------------------------------+
| Privilege               | Context                               | Comment                                               |
+-------------------------+---------------------------------------+-------------------------------------------------------+
| Alter                   | Tables                                | To alter the table                                    |
| Alter routine           | Functions,Procedures                  | To alter or drop stored functions/procedures          |
| Create                  | Databases,Tables,Indexes              | To create new databases and tables                    |
| Create routine          | Databases                             | To use CREATE FUNCTION/PROCEDURE                      |
| Create temporary tables | Databases                             | To use CREATE TEMPORARY TABLE                         |
| Create view             | Tables                                | To create new views                                   |
| Create user             | Server Admin                          | To create new users                                   |
| Delete                  | Tables                                | To delete existing rows                               |
| Drop                    | Databases,Tables                      | To drop databases, tables, and views                  |
| Event                   | Server Admin                          | To create, alter, drop and execute events             |
| Execute                 | Functions,Procedures                  | To execute stored routines                            |
| File                    | File access on server                 | To read and write files on the server                 |
| Grant option            | Databases,Tables,Functions,Procedures | To give to other users those privileges you possess   |
| Index                   | Tables                                | To create or drop indexes                             |
| Insert                  | Tables                                | To insert data into tables                            |
| Lock tables             | Databases                             | To use LOCK TABLES (together with SELECT privilege)   |
| Process                 | Server Admin                          | To view the plain text of currently executing queries |
| Proxy                   | Server Admin                          | To make proxy user possible                           |
| References              | Databases,Tables                      | To have references on tables                          |
| Reload                  | Server Admin                          | To reload or refresh tables, logs and privileges      |
| Replication client      | Server Admin                          | To ask where the slave or master servers are          |
| Replication slave       | Server Admin                          | To read binary log events from the master             |
| Select                  | Tables                                | To retrieve rows from table                           |
| Show databases          | Server Admin                          | To see all databases with SHOW DATABASES              |
| Show view               | Tables                                | To see views with SHOW CREATE VIEW                    |
| Shutdown                | Server Admin                          | To shut down the server                               |
| Super                   | Server Admin                          | To use KILL thread, SET GLOBAL, CHANGE MASTER, etc.   |
| Trigger                 | Tables                                | To use triggers                                       |
| Create tablespace       | Server Admin                          | To create/alter/drop tablespaces                      |
| Update                  | Tables                                | To update existing rows                               |
| Usage                   | Server Admin                          | No privileges - allow connect only                    |
+-------------------------+---------------------------------------+-------------------------------------------------------+
31 rows in set (0.00 sec)

```

### Grant privileges

Global privileges

```
GRANT ALL ON *.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON *.* TO 'someuser'@'somehost';

```

Database privileges

```
GRANT ALL ON mydb.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost';

```

Table privileges

```
GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';

```

Column privileges

```
GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost';

```

Routine privileges

```
GRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';
GRANT EXECUTE ON PROCEDURE mydb.myproc TO 'someuser'@'somehost';

```

### Revoke privileges

```
REVOKE
    priv_type [(column_list)]
      [, priv_type [(column_list)]] ...
    ON [object_type] priv_level
    FROM user [, user] ...

REVOKE ALL PRIVILEGES, GRANT OPTION
    FROM user [, user] ...

```

### Show Privileges

```

mysql> select * from user where user = 'neo'\G
*************************** 1\. row ***************************
                 Host: 192.168.0.5
                 User: neo
             Password: *7564B7B0A062C9523700601CBA1DCE1F861D6270
          Select_priv: Y
          Insert_priv: Y
          Update_priv: Y
          Delete_priv: Y
          Create_priv: Y
            Drop_priv: Y
          Reload_priv: Y
        Shutdown_priv: Y
         Process_priv: Y
            File_priv: Y
           Grant_priv: N
      References_priv: Y
           Index_priv: Y
           Alter_priv: Y
         Show_db_priv: Y
           Super_priv: Y
Create_tmp_table_priv: Y
     Lock_tables_priv: Y
         Execute_priv: Y
      Repl_slave_priv: Y
     Repl_client_priv: Y
     Create_view_priv: Y
       Show_view_priv: Y
  Create_routine_priv: Y
   Alter_routine_priv: Y
     Create_user_priv: Y
           Event_priv: Y
         Trigger_priv: Y
             ssl_type:
           ssl_cipher:
          x509_issuer:
         x509_subject:
        max_questions: 0
          max_updates: 0
      max_connections: 0
 max_user_connections: 0
1 row in set (0.00 sec)

mysql>

```

### MAX_QUERIES_PER_HOUR/MAX_UPDATES_PER_HOUR

```

GRANT USAGE ON *.* TO ...
  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;

```

### Table Privileges

授权 tmp 用户只能访问 tabname 表

```
GRANT ALL PRIVILEGES ON tmp.tabname TO 'tmp'@'%' IDENTIFIED BY 'chen' WITH GRANT OPTION;

```

如果用户已经存在仅仅是分配权限可以使用下面方法

```
GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';			

```

### Column Privileges

mydb.mytbl 表 col1 字段允许查询，col1,col2 允许插入

```
GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost';			

```

## Maintenance 数据库维护

### CHECK 检查表

```
CHECK TABLE `dbname`.`actions`;
CHECK TABLE `dbname`.`actions` QUICK FAST MEDIUM EXTENDED CHANGED;

```

### ANALYZE 分析表

```
ANALYZE TABLE `dbname`.`actions`;

```

### CHECKSUM

```
CHECKSUM TABLE `dbname`.`actions` QUICK;

```

### OPTIMIZE 优化表

```
OPTIMIZE TABLE `dbname`.`actions`;

```

### REPAIR 修复

```
REPAIR TABLE `dbname`.`members`;
SHOW TABLE STATUS LIKE 'members';

```

## INFORMATION_SCHEMA

### 查询表字段

```

SELECT 
    GROUP_CONCAT(COLUMN_NAME) AS fields
FROM
    INFORMATION_SCHEMA.Columns
WHERE
    table_name = 'mytable'
        AND table_schema = 'test';

```

### 列出所有触发器

```

select trigger_schema, trigger_name, action_statement from information_schema.triggers

select * from information_schema.triggers where information_schema.triggers.trigger_schema like '%test%';			

select * from information_schema.triggers where information_schema.triggers.trigger_name like '%trigger_name%' and information_schema.triggers.trigger_schema like '%data_base_name%';			

```

## Backup and Recovery

### Import / Export

#### Export(Backup)

```

mysqldump -hlocalhost -proot -p**** mydb > mydb.sql

```

gzip

```

mysqldump -hlocalhost -proot -p**** mydb | gzip > mydb.sql.gz

```

#### Import(Recovery)

```

mysql -hlocalhost -proot -p**** mydb < mydb.sql

```

gunzip

```

gunzip mydb.sql.gz -c | mysql -hlocalhost -proot -p**** mydb

```

#### xml

export xml

```
$ mysqldump -uusrname -ppasswd -X -t database table -r filename.xml

```

#### 备份表数据

```
SELECT * INTO OUTFILE 'file_name' FROM tbl_name
LOAD DATA INFILE 'file_name' REPLACE INTO TABLE tbl_name

```

#### source

```

mysql> use your_db
mysql> SOURCE database.sql

```

#### 使用 mysqlhotcopy 备份 MyISAM 引擎的数据库

**shell> mysqlhotcopy db_name /path/to/some/dir**

```
mysql:~# mysqlhotcopy --user=neo --password=chen shop /tmp/backup
Locked 100 tables in 0 seconds.
Flushed tables (`shop`.`account_log`, `shop`.`ad`, `shop`.`ad_custom`, `shop`.`ad_position`, `shop`.`admin_action`,
`shop`.`admin_log`, `shop`.`admin_message`, `shop`.`admin_user`, `shop`.`adsense`, `shop`.`affiliate_log`,
...
...
...
`shop`.`user_rank`, `shop`.`users`, `shop`.`virtual_card`, `shop`.`volume_price`, `shop`.`vote`, `shop`.`vote_log`,
`shop`.`vote_option`, `shop`.`wholesale`) in 0 seconds.
Copying 299 files...
Copying indices for 0 files...
Unlocked tables.
mysqlhotcopy copied 100 tables (299 files) in 0 seconds (0 seconds overall).

```

#### AutoMySQLBackup

https://sourceforge.net/projects/automysqlbackup/

#### xtrabackup - Open source backup tool for InnoDB and XtraDB.

https://launchpad.net/percona-xtrabackup

##### Percona yum Repository

```
$ rpm -Uhv http://www.percona.com/downloads/percona-release/percona-release-0.0-1.x86_64.rpm

```

```
# yum search xtrabackup
================================================================ N/S Matched: XtraBackup =================================================================
holland-xtrabackup.noarch : Xtrabackup plugin for Holland
percona-xtrabackup.x86_64 : XtraBackup online backup for MySQL / InnoDB
percona-xtrabackup-debuginfo.x86_64 : Debug information for package percona-xtrabackup
percona-xtrabackup-test.x86_64 : Test suite for Percona Xtrabackup

```

```
# yum install percona-xtrabackup

```

##### Creating an Incremental Backup

```
xtrabackup --backup --target-dir=/data/backups/base --datadir=/var/lib/mysql/

```

### Snapshot Backup

#### LVM Snapshot

```

# mysql –uroot –pmysql
mysql> flush tables with read lock;
mysql>flush logs;
mysql>system lvcreate -L1024M -s -n snap0 /dev/vg00/lvol00
mysql>show master status；
mysql>unlock tables；
mysql>quit

```

#### Btrfs Snapshot

```
# btrfs subvolume snapshot /data /data/backup_2013-03-20
Create a snapshot of '/data' in '/data/backup_2013-03-20'

btrfs subvolume list /data
ID 315 gen 172 top level 5 path backup_2013-03-10
ID 320 gen 178 top level 5 path backup_2013-03-20

```

## 第 62 章 DDL - Data Definition Language

## 数据库管理(Database)

### create

Creating a UTF-8 database

```
CREATE DATABASE db_name DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;

```

Create a UTF-8 database with binary UTF-8 collation.

```
CREATE DATABASE dbname CHARACTER SET utf8 COLLATE utf8_bin;

```

### drop

```
DROP DATABASE db_name;

```

### Alter

```
ALTER DATABASE dbname DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;

```

### Rename

```
RENAME {DATABASE | SCHEMA} db_name TO new_db_name;

```

before 5.0 version

```
[neo@development ~]$ mysqldump -uroot -pchen db_old | mysql -uroot -pchen db_new

```

### CHARACTER

```

ALTER DATABASE <database_name> CHARACTER SET utf8;

```

### show create database

```

mysql> show create database dbname;
+----------+-------------------------------------------------------------------+
| Database | Create Database                                                   |
+----------+-------------------------------------------------------------------+
| dbname   | CREATE DATABASE `dbname` /*!40100 DEFAULT CHARACTER SET utf8 */   |
+----------+-------------------------------------------------------------------+
1 row in set (0.00 sec)

```

## 表管理(Table)

### 数据类型

#### SET 集合类型

SET 集合类型，此类型适合用于多项选择场景，例如保存表单中的 checkbox。

```
CREATE TABLE `QA` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`question` VARCHAR(255) NOT NULL COMMENT '问题描述',
	`answer` SET('A','B','C','D') NOT NULL COMMENT '问题答案',
	PRIMARY KEY (`id`)
)
COMMENT='Multiple Choice'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;

```

插入数据

```
INSERT INTO `QA` (`id`, `question`, `answer`) VALUES
	(1, 'Netkiller 系列手札始于那一年？ A.2000 年，B.2008 年，C.2010 年，D.2016 年', 'A'),
	(2, 'Netkiller 系列手札有哪些? A.《Netkiller Scals 手札》, B.《Netkiller Java 手札》, C.《Netkiller Linux 手札》, D.《Netkiller EMC 手札》', 'B,C'),
	(3, 'XXXXXXXXX', 'C,D'),
	(4, 'XXXXXXXXX', 'A,B,C'),
	...
	...
	(1000, 'XXXXXXXXXX', 'B,C,D'),
	...
	...
	(5000, 'XXXXXXXXXX', 'A,B,C,D');

```

查询 SET 结果集，MySQL 为 SET 配备了 FIND_IN_SET 函数

```

select * from QA where FIND_IN_SET('B',`answer`);

```

下面两种方法也能实现，但不推荐使用。

```

select question, answer from QA where locate('B',answer)>0;
select question, answer from QA where POSITION('B' in answer)>0;				

```

查询多个答案

```

select question, answer from QA where answer = 'B,C';				

```

### create table ... select

创建空表

```

create table admin_user_history select * from admin_user where 1 <> 1;

```

创建有数据的表

```

create table admin_user_history select * from admin_user;

```

### modifiy table

modifiy table

```
ALTER TABLE ecs_users add user_picture varchar(255);

```

### TEMPORARY Table

临时表将在你连接期间存在。一旦断开时将自动删除表并释放所用的空间。你在连接期间删除该表也同样释放空间。

```
CREATE TEMPORARY TABLE tmp_table (
	key VARCHAR(10) NOT NULL,
	value INTEGER NOT NULL
)

```

声明临时表是一个 HEAP 表，允许你指定在内存中创建它

```
CREATE TEMPORARY TABLE tmp_mem_table (
	key VARCHAR(10) NOT NULL,
	value INTEGER NOT NULL
) TYPE = HEAP

```

### Collate

```
ALTER TABLE `tmp_cats`  COLLATE='utf8_general_ci',  CONVERT TO CHARSET utf8;

```

### CHARACTER

```

ALTER TABLE <table_name> CONVERT TO CHARACTER SET utf8;
alter table <table_name> convert to charset utf8mb4;

```

### DEFAULT

#### AUTO_INCREMENT

定义 AUTO_INCREMENT 起始值

```
CREATE TABLE `bank_account` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增唯一 ID',
	`name` VARCHAR(50) NOT NULL DEFAULT '0' COMMENT '帐号名称(Name on account)',
	PRIMARY KEY (`id`)
)
COMMENT='银行帐号'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=2;				

```

设置 AUTO_INCREMENT

```
ALTER TABLE `accounts`
	AUTO_INCREMENT=792257;				

```

#### TIMESTAMP NULL DEFAULT NULL ON UPDATE

```

alter table cms.article ADD  COLUMN `mtime` TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更改时间';				

```

更新时间

`mtime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更改时间',

```

CREATE TABLE `bank_account` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增唯一 ID',
	`bank_name` VARCHAR(255) NOT NULL DEFAULT '0' COMMENT '银行名字(Bank Name)',
	`name` VARCHAR(50) NOT NULL DEFAULT '0' COMMENT '帐号名称(Name on account)',
	`account_number` VARCHAR(50) NOT NULL DEFAULT '0' COMMENT '银行帐号(Account Number)',
	`branch_location` VARCHAR(255) NOT NULL DEFAULT '0' COMMENT '支行位置(Branch Location)',
	`description` VARCHAR(255) NOT NULL DEFAULT '0' COMMENT '银行描述',
	`status` ENUM('Y','N') NOT NULL DEFAULT 'N' COMMENT '银行帐号状态',
	`ctime` DATETIME NOT NULL COMMENT '创建时间',
	`mtime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更改时间',
	PRIMARY KEY (`id`)
)
COMMENT='银行帐号'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=2;

```

#### 表存储位置(DATA DIRECTORY)

```

CREATE TABLE IF NOT EXISTS `tab_name` (
  `id` int(11) DEFAULT NULL,
  `purchased` date DEFAULT NULL,
  KEY `Index 1` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
/*!50100 PARTITION BY LIST (YEAR(purchased))
(PARTITION p0 VALUES IN (1990) DATA DIRECTORY = '/www/data' ENGINE = InnoDB) */;				

```

### KEY

#### PRIMARY KEY

一般主键定义

```
PRIMARY KEY (`id`),

```

复合主键

```
PRIMARY KEY (`id`, `user_id`),

```

### COMMENT

```
ALTER TABLE `neo`.`stuff` COMMENT = '用户表' ;
ALTER TABLE `neo`.`stuff` CHANGE COLUMN `name` `name` VARCHAR(50) NULL DEFAULT NULL COMMENT '姓名'  ;
ALTER TABLE `neo`.`stuff` CHANGE COLUMN `password` `password` VARCHAR(50) NULL DEFAULT NULL COMMENT '用户密码' ;

CREATE TABLE `stuff` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL COMMENT ''姓名'',
  `password` varchar(50) DEFAULT NULL COMMENT ''用户密码'',
  `created` date NOT NULL DEFAULT ''0000-00-00'',
  PRIMARY KEY (`id`,`created`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=latin1 COMMENT=''用户表''
/*!50100 PARTITION BY HASH (year(created))
PARTITIONS 10 */

```

### Engine 存储引擎

#### 显示当前数据库支持引擎

```

mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)

```

#### 切换引擎

修改与切换引擎

```

ALTER TABLE `test` ENGINE=BLACKHOLE;
ALTER TABLE `test` ENGINE=InnoDB;

```

#### FEDERATED

启用 FEDERATED 引擎, 服务器环境 Ubuntu 13.04

```
$ sudo vim /etc/mysql/conf.d/federated.cnf
[mysqld]
federated

$ sudo service mysql restart

```

```

mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | YES     | Federated MySQL storage engine                                 | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)

```

A 服务器

```
CREATE TABLE `t1` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(50) NOT NULL,
	`sex` ENUM('Y','N') NULL DEFAULT 'Y',
	`passwd` VARCHAR(50) NULL DEFAULT NULL,
	`ctime` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
	`mtime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=4;

```

B 服务器

```
DROP TABLE `users`;

CREATE TABLE `users` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(50) NOT NULL,
	`sex` ENUM('Y','N') NULL DEFAULT 'Y',
	`ctime` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
	`mtime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`)
) ENGINE=FEDERATED connection = 'mysql://www:qwer123@192.168.2.1:3306/test/t1';

```

上面字段描述是你需要的字段，并非所有字段。这里屏蔽了 passwd 字段

### 提示

connection = 'mysql://用户名:密码@主机:端口/数据库/表名'

```

mysql> DROP TABLE `users`;
Query OK, 0 rows affected (0.00 sec)

mysql> CREATE TABLE `users` (
    -> `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
    -> `name` VARCHAR(50) NOT NULL,
    -> `sex` ENUM('Y','N') NULL DEFAULT 'Y',
    -> `ctime` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
    -> `mtime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    -> PRIMARY KEY (`id`)
    -> ) ENGINE=FEDERATED connection = 'mysql://www:qwer123@192.168.2.1:3306/test/t1';
Query OK, 0 rows affected (0.06 sec)

mysql>
mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| users          |
+----------------+
1 row in set (0.00 sec)

mysql> desc users;
+-------+------------------+------+-----+---------------------+-----------------------------+
| Field | Type             | Null | Key | Default             | Extra                       |
+-------+------------------+------+-----+---------------------+-----------------------------+
| id    | int(10) unsigned | NO   | PRI | NULL                | auto_increment              |
| name  | varchar(50)      | NO   |     | NULL                |                             |
| sex   | enum('Y','N')    | YES  |     | Y                   |                             |
| ctime | timestamp        | NO   |     | 0000-00-00 00:00:00 |                             |
| mtime | timestamp        | NO   |     | CURRENT_TIMESTAMP   | on update CURRENT_TIMESTAMP |
+-------+------------------+------+-----+---------------------+-----------------------------+
5 rows in set (0.00 sec)

mysql> select * from users;
+----+------+------+---------------------+---------------------+
| id | name | sex  | ctime               | mtime               |
+----+------+------+---------------------+---------------------+
|  1 | neo  | Y    | 0000-00-00 00:00:00 | 2013-05-17 18:05:09 |
|  2 | zen  | Y    | 0000-00-00 00:00:00 | 2013-05-17 18:05:11 |
|  3 | lily | N    | 0000-00-00 00:00:00 | 2013-05-17 18:05:22 |
+----+------+------+---------------------+---------------------+
3 rows in set (0.01 sec)

```

### FEDERATED 与 mysqldump 问题！

切记，mysqldump 只会 dump 出使用 FEDERATED 引擎表的结构,不会包含数据。

#### BLACKHOLE

```
CREATE TABLE test(id INT, val CHAR(10)) ENGINE = BLACKHOLE;

```

#### ARCHIVE

归档(是适用于存放大量数据的存储引擎), 仅支持 select、insert 操作; 不支持 delete 、update、索引等操作；使用 zlib 无损算法压缩数据，节省磁盘空间；

适用场景：适用于大量可查询但不能删除的历史数据保存；

基于 order 表创建 order_audit 归档表

```

create table order_audit engine=archive as select * from `order`;

```

order_audit 表结构如下

```

CREATE TABLE `order_audit` (
  `id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '订单 ID',
  `name` varchar(45) NOT NULL COMMENT '订单名称',
  `price` float NOT NULL COMMENT '价格',
  `ctime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
) ENGINE=ARCHIVE DEFAULT CHARSET=utf8		

```

```

mysql> show table status like 'order_audit';
+-------------+---------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+-------------+---------------------+------------+-----------------+----------+----------------+---------+
| Name        | Engine  | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time         | Check_time | Collation       | Checksum | Create_options | Comment |
+-------------+---------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+-------------+---------------------+------------+-----------------+----------+----------------+---------+
| order_audit | ARCHIVE |      10 | Compressed |    4 |           2215 |        8861 |               0 |            0 |         0 |           NULL | NULL        | 2017-11-16 17:30:34 | NULL       | utf8_general_ci |     NULL |                |         |
+-------------+---------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+-------------+---------------------+------------+-----------------+----------+----------------+---------+
1 row in set (0.01 sec)		

```

#### CSV

创建表

```

CREATE TABLE `csv_table` (
  `id` int(11) NOT NULL,
  `name` varchar(45) NOT NULL,
  `age` int(11) NOT NULL
) ENGINE=CSV DEFAULT CHARSET=utf8		

```

查看表状态

```

mysql> show table status like 'csv_table';
+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+
| Name      | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation       | Checksum | Create_options | Comment |
+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+
| csv_table | CSV    |      10 | Dynamic    |    2 |              0 |           0 |               0 |            0 |         0 |           NULL | NULL        | NULL        | NULL       | utf8_general_ci |     NULL |                |         |
+-----------+--------+---------+------------+------+----------------+-------------+-----------------+--------------+-----------+----------------+-------------+-------------+------------+-----------------+----------+----------------+---------+
1 row in set (0.00 sec)		

```

插入数据

```

insert into csv_table values (1,'Neo',37),(2,'Jam',40);		

```

查看数据

```

mysql> SELECT * FROM test.csv_table;
+----+------+-----+
| id | name | age |
+----+------+-----+
|  1 | Neo  |  37 |
|  2 | Jam  |  40 |
+----+------+-----+
2 rows in set (0.00 sec)

```

CSV 引擎是可以直接将 csv 文件复制出来的，表存储在 /var/lib/mysql/ 目录

```

root@netkiller /etc/nginx/conf.d % ls -1 /var/lib/mysql/test/csv*
/var/lib/mysql/test/csv_table.CSM
/var/lib/mysql/test/csv_table.CSV
/var/lib/mysql/test/csv_table.frm		

```

.*CSM, *.frm 是表结构文件，*.CSV 是我们需要的文件，纯文本，可以使用 Excel 打开。

```

root@netkiller /etc/nginx/conf.d % cat /var/lib/mysql/test/csv_table.CSV
1,"Neo",37
2,"Jam",40		

```

## Partitioning

```

mysql> SHOW VARIABLES LIKE '%partition%';

+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| have_partitioning | YES   |
+-------------------+-------+
1 row in set (0.00 sec)

```

### RANGE

```
18.5.1\. Partitioning Keys, Primary Keys, and Unique Keys
This section discusses the relationship of partitioning keys with primary keys and unique keys. The rule governing this relationship can be expressed as follows: All columns used in the partitioning expression for a partitioned table must be part of every unique key that the table may have.

In other words, every unique key on the table must use every column in the table's partitioning expression. (This also includes the table's primary key, since it is by definition a unique key. This particular case is discussed later in this section.) For example, each of the following table creation statements is invalid:

SQL code:
mysql> create table tx (
    ->     id int not null ,
    ->     info_time date,
    ->     primary key(id,info_time)
    -> )
    -> PARTITION BY RANGE(info_time div 100)
    -> (
    ->     PARTITION p_2008_11 VALUES LESS THAN (200812),
    ->     PARTITION p_2008_12 VALUES LESS THAN (200901),
    ->     PARTITION p_2009_01 VALUES LESS THAN (200902),
    ->     PARTITION p_2009_02 VALUES LESS THAN (200903),
    ->     PARTITION p_2009_03 VALUES LESS THAN (200904),
    ->     PARTITION p_2009_04 VALUES LESS THAN (200905),
    ->     PARTITION p_catch_all VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (0.17 sec)

mysql>

```

```

CREATE TABLE t1 (
    year_col  INT,
    some_data INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2002),
    PARTITION p4 VALUES LESS THAN (2006),
    PARTITION p5 VALUES LESS THAN MAXVALUE
);

```

e.g.2

```

CREATE TABLE rc (
    a INT NOT NULL,
    b INT NOT NULL
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (10,5),
    PARTITION p1 VALUES LESS THAN (20,10),
    PARTITION p2 VALUES LESS THAN (MAXVALUE,15),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);

```

```

CREATE TABLE part_tab
(
	c1 int default NULL,
	c2 varchar(30) default NULL,
	c3 date default NULL

) engine=myisam
PARTITION BY RANGE (year(c3)) (
      PARTITION p0 VALUES LESS THAN (2000) ,
      PARTITION p1 VALUES LESS THAN (2001) ,
      PARTITION p2 VALUES LESS THAN (2002) ,
      PARTITION p3 VALUES LESS THAN (2003) ,
      PARTITION p4 VALUES LESS THAN (2004) ,
      PARTITION p12 VALUES LESS THAN (2012),
      PARTITION p13 VALUES LESS THAN MAXVALUE
);

```

### LIST

```

CREATE TABLE client_firms (
    id   INT,
    name VARCHAR(35)
)
PARTITION BY LIST (id) (
    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
);

```

```

CREATE TABLE lc (
    a INT NULL,
    b INT NULL
)
PARTITION BY LIST COLUMNS(a,b) (
    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
);

```

```

CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
PARTITION BY LIST(YEAR(adate))
(
  PARTITION p1999 VALUES IN (1995, 1999, 2003)
    DATA DIRECTORY = '/var/appdata/95/data'
    INDEX DIRECTORY = '/var/appdata/95/idx',
  PARTITION p2000 VALUES IN (1996, 2000, 2004)
    DATA DIRECTORY = '/var/appdata/96/data'
    INDEX DIRECTORY = '/var/appdata/96/idx',
  PARTITION p2001 VALUES IN (1997, 2001, 2005)
    DATA DIRECTORY = '/var/appdata/97/data'
    INDEX DIRECTORY = '/var/appdata/97/idx',
  PARTITION p2000 VALUES IN (1998, 2002, 2006)
    DATA DIRECTORY = '/var/appdata/98/data'
    INDEX DIRECTORY = '/var/appdata/98/idx'
);

```

### HASH

```

CREATE TABLE `test` (
  `userid` int(10) unsigned NOT NULL auto_increment,
  `username` int(10) unsigned NOT NULL DEFAULT '0',
  `password` int(10) unsigned NOT NULL DEFAULT '0',

  primary key (`userid`),
  KEY `userid` (`username`)
) ENGINE=InnoDB
PARTITION BY HASH(userid)
PARTITIONS 8;

```

使用 HASH (year(created)) 替代 RANGE(year(created))

```

CREATE TABLE stuff (
	id INT AUTO_INCREMENT,
	name varchar(50),
	password varchar(50),
	created DATE,
	PRIMARY KEY (id, created)
)
PARTITION BY RANGE(year(created)) (
	PARTITION p0 VALUES LESS THAN (2010),
	PARTITION p1 VALUES LESS THAN (2012),
	PARTITION p2 VALUES LESS THAN MAXVALUE
);

更好的方法

CREATE TABLE stuff (
	id INT AUTO_INCREMENT,
	name varchar(50),
	password varchar(50),
	created DATE,
	PRIMARY KEY (id, created)
)
PARTITION BY HASH (year(created)) PARTITIONS 10;

我们演示一下

mysql> CREATE TABLE stuff (
    -> id INT AUTO_INCREMENT,
    -> name varchar(50),
    -> password varchar(50),
    -> created DATE,
    -> PRIMARY KEY (id, created)
    -> )
    -> PARTITION BY HASH (year(created)) PARTITIONS 10;
Query OK, 0 rows affected (0.08 sec)

mysql> insert into stuff (name,password,created) values('neo','test','2010-10-1');
Query OK, 1 row affected (0.06 sec)

mysql> insert into stuff (name,password,created) values('neo1','test','2012-2-1');
Query OK, 1 row affected (0.00 sec)

mysql> insert into stuff (name,password,created) values('neo2','test','2012-3-5');
Query OK, 1 row affected (0.00 sec)

mysql> insert into stuff (name,password,created) values('neo4','test','2011-1-5');
Query OK, 1 row affected (0.00 sec)

mysql> SELECT
    ->   partition_name part,
    ->   partition_expression expr,
    ->   partition_description descr,
    ->   table_rows
    -> FROM
    ->   INFORMATION_SCHEMA.partitions
    -> WHERE
    ->   TABLE_SCHEMA = schema()
    ->   AND TABLE_NAME='stuff';
+------+---------------+-------+------------+
| part | expr          | descr | table_rows |
+------+---------------+-------+------------+
| p0   | year(created) | NULL  |          1 |
| p1   | year(created) | NULL  |          1 |
| p2   | year(created) | NULL  |          2 |
| p3   | year(created) | NULL  |          0 |
| p4   | year(created) | NULL  |          0 |
| p5   | year(created) | NULL  |          0 |
| p6   | year(created) | NULL  |          0 |
| p7   | year(created) | NULL  |          0 |
| p8   | year(created) | NULL  |          0 |
| p9   | year(created) | NULL  |          0 |
+------+---------------+-------+------------+
10 rows in set (0.02 sec)

mysql> EXPLAIN PARTITIONS SELECT * FROM stuff WHERE created='2011-01-05'\G
*************************** 1\. row ***************************
           id: 1
  select_type: SIMPLE
        table: stuff
   partitions: p1
         type: system
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
        Extra:
1 row in set (0.08 sec)

mysql> EXPLAIN PARTITIONS SELECT * FROM stuff WHERE created='2012-03-05'\G
*************************** 1\. row ***************************
           id: 1
  select_type: SIMPLE
        table: stuff
   partitions: p2
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 2
        Extra: Using where
1 row in set (0.00 sec)

```

#### LINEAR HASH

```
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITIONS 4;

```

### KEY 分区

按照 KEY 进行分区类似于按照 HASH 分区，除了 HASH 分区使用的用户定义的表达式，而 KEY 分区的 哈希函数是由 MySQL 服务器提供。MySQL 簇（Cluster）使用函数 MD5()来实现 KEY 分区；

```
CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;

```

### Subpartitioning

```
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );

CREATE TABLE ts1 (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( MONTH(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );

```

### 分区管理

#### 新增分区

mysql 5.5+

为已经存在表添加分区

```
ALTER TABLE tbl_name  ADD PARTITION PARTITIONS 6;

```

新增 RANGE 分区

```
ALTER TABLE category ADD PARTITION (PARTITION p4 VALUES IN (100,200,300,400)
                    DATA DIRECTORY = '/data/category'
                    INDEX DIRECTORY = '/data/category');

```

新增 LIST 分区

```

CREATE TABLE expenses (
  expense_date DATE NOT NULL,
  category VARCHAR(30),
  amount DECIMAL (10,3)
);

ALTER TABLE expenses
PARTITION BY LIST COLUMNS (category)
(
  PARTITION p01 VALUES IN ( 'lodging', 'food'),
  PARTITION p02 VALUES IN ( 'flights', 'ground transportation'),
  PARTITION p03 VALUES IN ( 'leisure', 'customer entertainment'),
  PARTITION p04 VALUES IN ( 'communications'),
  PARTITION p05 VALUES IN ( 'fees')
);

```

新增 HASH 分区

```
CREATE TABLE t1 (
    id INT,
    year_col INT
);

ALTER TABLE t1
    PARTITION BY HASH(id)
    PARTITIONS 8;

```

```

/* 在 MySQL 5.1 中*/
CREATE TABLE t2
(
  dt DATE
)
PARTITION BY RANGE (TO_DAYS(dt))
(
  PARTITION p01 VALUES LESS THAN (TO_DAYS('2007-01-01')),
  PARTITION p02 VALUES LESS THAN (TO_DAYS('2008-01-01')),
  PARTITION p03 VALUES LESS THAN (TO_DAYS('2009-01-01')),
  PARTITION p04 VALUES LESS THAN (MAXVALUE));

SHOW CREATE TABLE t2 \G
*************************** 1\. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `dt` date DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE (TO_DAYS(dt))
(PARTITION p01 VALUES LESS THAN (733042) ENGINE = MyISAM,
 PARTITION p02 VALUES LESS THAN (733407) ENGINE = MyISAM,
 PARTITION p03 VALUES LESS THAN (733773) ENGINE = MyISAM,
 PARTITION p04 VALUES LESS THAN MAXVALUE ENGINE = MyISAM) */

 /*在 MySQL 5.5 中*/
CREATE TABLE t2
(
  dt DATE
)
PARTITION BY RANGE COLUMNS (dt)
(
  PARTITION p01 VALUES LESS THAN ('2007-01-01'),
  PARTITION p02 VALUES LESS THAN ('2008-01-01'),
  PARTITION p03 VALUES LESS THAN ('2009-01-01'),
  PARTITION p04 VALUES LESS THAN (MAXVALUE));

SHOW CREATE TABLE t2 \G
*************************** 1\. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `dt` date DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
/*!50500 PARTITION BY RANGE  COLUMNS(dt)
(PARTITION p01 VALUES LESS THAN ('2007-01-01') ENGINE = MyISAM,
 PARTITION p02 VALUES LESS THAN ('2008-01-01') ENGINE = MyISAM,
 PARTITION p03 VALUES LESS THAN ('2009-01-01') ENGINE = MyISAM,
 PARTITION p04 VALUES LESS THAN (MAXVALUE) ENGINE = MyISAM) */

```

#### 删除分区

删除分区 p0

```
ALERT TABLE users DROP PARTITION p0;

```

#### 重建分区

使用 REORGANIZE 重建分区。

```
RANGE 分区重建
ALTER TABLE users REORGANIZE PARTITION p0,p1 INTO (PARTITION p0 VALUES LESS THAN (6000000));

将原来的 p0,p1 分区合并起来，放到新的 p0 分区中。

LIST 分区重建
ALTER TABLE users REORGANIZE PARTITION p0,p1 INTO (PARTITION p0 VALUES IN(0,1,4,5,8,9,12,13));
将原来的 p0,p1 分区合并起来，放到新的 p0 分区中。

HASH/KEY 分区重建
ALTER TABLE users REORGANIZE PARTITION COALESCE PARTITION 2;
分区的数量改为 2，
注意：在这里数量只能减少不能增加。想要增加可以用 ADD PARTITION 方法

```

调整 HASH/KEY 分区数量，将分区总数扩展到 8 个。

```
ALTER TABLE users ADD PARTITION PARTITIONS 8;

```

#### 分区维护

```
重建分区: 这和先删除保存在分区中的所有记录，然后重新插入它们，具有同样的效果。它可用于整理分区碎片。

示例：

ALTER TABLE t1 REBUILD PARTITION (p0, p1)；
·         优化分区：如果从分区中删除了大量的行，或者对一个带有可变长度的行（也就是说，有 VARCHAR，BLOB，或 TEXT 类型的列）作了许多修改，可以使用“ALTER TABLE ... OPTIMIZE PARTITION”来收回没有使用的空间，并整理分区数据文件的碎片。

示例：

ALTER TABLE t1 OPTIMIZE PARTITION (p0, p1)；
在一个给定的分区表上使用“OPTIMIZE PARTITION”等同于在那个分区上运行 CHECK PARTITION，ANALYZE PARTITION，和 REPAIR PARTITION。

·         分析分区：读取并保存分区的键分布。

示例：

ALTER TABLE t1 ANALYZE PARTITION (p3)；
·         修补分区： 修补被破坏的分区。

示例：

ALTER TABLE t1 REPAIR PARTITION (p0,p1);
·         检查分区： 可以使用几乎与对非分区表使用 CHECK TABLE 相同的方式检查分区。

示例：

ALTER TABLE trb3 CHECK PARTITION (p1)；

```

### EXPLAIN PARTITIONS

EXPLAIN PARTITIONS

```

mysql> EXPLAIN PARTITIONS SELECT * FROM users\G
*************************** 1\. row ***************************
           id: 1
  select_type: SIMPLE
        table: users
   partitions: p0,p1,p2,p3,p4,p5,p6
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 7
        Extra:
1 row in set (0.03 sec)

mysql> EXPLAIN PARTITIONS SELECT * FROM users WHERE id < 5\G
*************************** 1\. row ***************************
           id: 1
  select_type: SIMPLE
        table: users
   partitions: p0,p1,p2,p3,p4,p5,p6
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 7
        Extra: Using where
1 row in set (0.00 sec)

```

### SHOW CREATE TABLE

SHOW CREATE TABLE

```

mysql> SHOW CREATE TABLE users\G
*************************** 1\. row ***************************
       Table: users
Create Table: CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL DEFAULT '',
  `birthday` datetime DEFAULT NULL,
  PRIMARY KEY (`id`,`username`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=latin1
/*!50100 PARTITION BY KEY (id,username)
PARTITIONS 7 */
1 row in set (0.00 sec)

```

### INFORMATION_SCHEMA.partitions 表

```

SELECT
  partition_name part,
  partition_expression expr,
  partition_description descr,
  table_rows
FROM
  INFORMATION_SCHEMA.partitions
WHERE
  TABLE_SCHEMA = schema()
  AND TABLE_NAME='employees';

```

```

select
  partition_name part,
  partition_expression expr,
  from_seconds(partition_description) descr,
  table_rows
FROM
INFORMATION_SCHEMA.partitions
WHERE
    TABLE_SCHEMA = 'test'
    AND TABLE_NAME='t2';

```

### 分区数据操作

指定分区查询

```
SELECT * FROM employees PARTITION (p0, p2);

SELECT count(1) FROM employees PARTITION (p0);
SELECT count(1) FROM employees PARTITION (p0, p2);
SELECT count(1) FROM employees PARTITION (p0, p2, p1);

```

删除分区中的记录

```
DELETE FROM employees PARTITION (p0, p1);		

```

更新指定分区

```
UPDATE employees PARTITION (p0) SET store_id = 2 WHERE fname = 'Jill';		

```

指定分区连表查询

```
SELECT e.id, s.city FROM employees AS e JOIN stores PARTITION (p1) AS s ...;		

```

将某个表迁移到分区上

```
ALTER TABLE employees EXCHANGE PARTITION p0 WITH TABLE employees2;		

```

## 第 62 章 DDL - Data Definition Language

## 数据库管理(Database)

### create

Creating a UTF-8 database

```
CREATE DATABASE db_name DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;

```

Create a UTF-8 database with binary UTF-8 collation.

```
CREATE DATABASE dbname CHARACTER SET utf8 COLLATE utf8_bin;

```

### drop

```
DROP DATABASE db_name;

```

### Alter

```
ALTER DATABASE dbname DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;

```

### Rename

```
RENAME {DATABASE | SCHEMA} db_name TO new_db_name;

```

before 5.0 version

```
[neo@development ~]$ mysqldump -uroot -pchen db_old | mysql -uroot -pchen db_new

```

### CHARACTER

```

ALTER DATABASE <database_name> CHARACTER SET utf8;

```

### show create database

```

mysql> show create database dbname;
+----------+-------------------------------------------------------------------+
| Database | Create Database                                                   |
+----------+-------------------------------------------------------------------+
| dbname   | CREATE DATABASE `dbname` /*!40100 DEFAULT CHARACTER SET utf8 */   |
+----------+-------------------------------------------------------------------+
1 row in set (0.00 sec)

```

## 外键(Foreign Key)

ON DELETE, ON UPDATE 事件触发限制，可选参数： RESTRICT | CASCADE | SET NULL | NO ACTION

1.  RESTRICT（限制外表中的外键改动）

2.  CASCADE（跟随外键改动）

3.  SET NULL（设空值）

4.  SET DEFAULT（设默认值）

5.  NO ACTION（无动作，默认的）

### FOREIGN KEY (RESTRICT)

```
CREATE TABLE `bank_account_group_has_bank_account` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`bank_account_group_id` INT(10) UNSIGNED NOT NULL DEFAULT '0',
	`bank_account_id` INT(10) UNSIGNED NOT NULL DEFAULT '0',
	PRIMARY KEY (`id`),
	INDEX `FK_bank_account_group_has_bank_account_bank_account` (`bank_account_id`),
	INDEX `FK_bank_account_group_has_bank_account_bank_account_group` (`bank_account_group_id`),
	CONSTRAINT `FK_bank_account_group_has_bank_account_bank_account` FOREIGN KEY (`bank_account_id`) REFERENCES `bank_account` (`id`),
	CONSTRAINT `FK_bank_account_group_has_bank_account_bank_account_group` FOREIGN KEY (`bank_account_group_id`) REFERENCES `bank_account_group` (`id`)
)
COMMENT='bank_account_group 与 bank_account 的 N:M 关系'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=35;

```

## 视图(View)

```
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

```

update view

```
SQL CREATE OR REPLACE VIEW Syntax
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

```

## 存储过程(PROCEDURE)

### 存储程序

存储过程没有返回数据，需使用 call proc()调用

```
CREATE DEFINER=`neo`@`%` PROCEDURE `angelfund`(IN `puid` VARCHAR(50), IN `ptime` DATETIME)
	LANGUAGE SQL
	NOT DETERMINISTIC
	CONTAINS SQL
	SQL SECURITY DEFINER
	COMMENT ''
BEGIN

	DECLARE fusername VARCHAR(16) DEFAULT NULL;
	DECLARE fname VARCHAR(16) DEFAULT NULL;
	DECLARE fmembers_date VARCHAR(20) DEFAULT NULL;

	SELECT username,name,FROM_UNIXTIME(createtime) INTO fusername,fname,fmembers_date FROM members WHERE username = puid;

	IF fusername IS NOT NULL THEN
		INSERT IGNORE INTO angelfund(username,name,members_date,accounts_date,endtime,`status`,op,operator,`description`) value(fusername,fname,fmembers_date,ptime,DATE_ADD(ptime, INTERVAL +1 MONTH),'N','N','computer','');
	END IF;

END			

```

调用过程

```
call angelfund('100','2013-10-10 10:10:10');			

```

### EXECUTE 执行 SQL

在过程中运行 SQL，下面的例子是文件导出的例子。

```

DROP procedure IF EXISTS `export_file`;

DELIMITER $$
CREATE DEFINER=`dba`@`%` PROCEDURE `export_file`(IN file_name char(64), IN tabname char(64))
BEGIN
	set @sql = concat('SELECT * INTO OUTFILE ',"'/var/lib/mysql-files/",file_name,"'",' FROM ', tabname) ; 
    -- select @sql;
	PREPARE stmt FROM @sql; 
	EXECUTE stmt; 
	Deallocate prepare stmt;
END$$

DELIMITER ;

```

call 存储过程

```

call test.export_file('test', 'mytable');			

```

### PREPARE 传递参数

```

mysql> PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> SET @a = 3;
Query OK, 0 rows affected (0.00 sec)

mysql> SET @b = 4;
Query OK, 0 rows affected (0.00 sec)

mysql> EXECUTE stmt1 USING @a, @b;
+------------+
| hypotenuse |
+------------+
|          5 |
+------------+
1 row in set (0.00 sec)

mysql> DEALLOCATE PREPARE stmt1;
Query OK, 0 rows affected (0.00 sec)

mysql> 			

```

### 存储过程返回数据

```

USE `test`;
DROP procedure IF EXISTS `test`;

DELIMITER $$
USE `test`$$
CREATE DEFINER=`dba`@`%` PROCEDURE `test`(in a int, in b int ,out num int)
BEGIN

	set num = a + b;

END$$

DELIMITER ;

```

运行后返回结果 10

```

set @num = 0;
call test(3,7,@num);
select @num;

```

### 结果集转 JSON

```

USE `netkiller`;
DROP procedure IF EXISTS `table2json`;

DELIMITER $$
USE `netkiller`$$
CREATE DEFINER=`neo`@`%` PROCEDURE `table2json`(
IN `schema` VARCHAR(32), 
IN `table` VARCHAR(32), 
IN `id` VARCHAR(10), 
OUT rev VARCHAR(1024)
)
BEGIN
	SET @column = NULL;
	SET @str = NULL;

	SELECT 
    GROUP_CONCAT(fields) AS col INTO @column FROM (
		SELECT 
			CONCAT('"', COLUMN_NAME, '",', COLUMN_NAME) AS fields
		FROM
			INFORMATION_SCHEMA.Columns
		WHERE
			table_name = `table`
				AND table_schema = `schema`) AS tmptable;

	-- SELECT @column;

	SET @sql = CONCAT('SELECT json_object(',@column, ' ) as json INTO @str FROM ', `table`,' where id = ', `id`);

	-- SELECT @sql;

	PREPARE stmt FROM @sql; 
	EXECUTE stmt; 
	Deallocate prepare stmt;

	set rev = @str;

END$$

DELIMITER ;			

```

使用实例

```

set @rev = '0';
call netkiller.table2json('test', 'test', '1', @rev);
select @rev;

```

### 例子·过程返回结果

```

USE `netkiller`;
DROP procedure IF EXISTS `trigger2json`;

DELIMITER $$
USE `netkiller`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `trigger2json`(
IN `schema` VARCHAR(32), 
IN `table` VARCHAR(32), 
OUT rev VARCHAR(1024)
)
BEGIN
	SET @column = NULL;
	SET @str = NULL;

	SELECT 
    GROUP_CONCAT(fields) AS col
INTO @column FROM
    (SELECT 
        CONCAT('"', COLUMN_NAME, '", NEW.', COLUMN_NAME) AS fields
    FROM
        INFORMATION_SCHEMA.Columns
    WHERE
        table_name = `table`
            AND table_schema = `schema`) AS tmptable;

-- SELECT @column;

	SET @sql = CONCAT('SELECT json_object(',@column, ' ) as json INTO @str ');

	-- SELECT @sql; 

	PREPARE stmt FROM @sql; 
	EXECUTE stmt; 
	Deallocate prepare stmt;

	set rev = @str;

END$$

DELIMITER ;

```

```

set @rev = '0';
call neo.trigger2json('gw', 'member', @rev);
select @rev;			

```

## 函数

函数会返回数据，调用函数使用 select fun(),不能使用 call 调用，否则提示

```

mysql> call myfun();
ERROR 1305 (42000): PROCEDURE test.myfun does not exist			

```

下面做一个实验

```
CREATE TABLE `t` (
	`id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT,
	`n` INT(11) UNSIGNED NULL DEFAULT '0',
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=5;

CREATE DEFINER=`neo`@`%` FUNCTION `myfun`()
	RETURNS int(11)
	LANGUAGE SQL
	NOT DETERMINISTIC
	READS SQL DATA
	SQL SECURITY DEFINER
	COMMENT ''
BEGIN
	INSERT INTO t (n) VALUES(rand()*100);
	RETURN LAST_INSERT_ID();
END			

```

```

mysql> select myfun();
+---------+
| myfun() |
+---------+
|       9 |
+---------+
1 row in set, 2 warnings (0.07 sec)

```

### TIMESTAMP TO ISO8601

```

USE `netkiller`;
DROP function IF EXISTS `timestamp_to_iso8601`;

DELIMITER $$
USE `netkiller`$$
CREATE DEFINER=`neo`@`db.netkiller.cn` FUNCTION `timestamp_to_iso8601`(dt timestamp) RETURNS varchar(24) CHARSET utf8
BEGIN

	RETURN DATE_FORMAT( CONVERT_TZ(dt, @@session.time_zone, '+00:00')  ,'%Y-%m-%dT%T.000Z'); 

END$$

DELIMITER ;

```

调用函数

```

mysql> select timestamp_to_iso8601(current_timestamp()) as iso8601;
+--------------------------+
| iso8601                  |
+--------------------------+
| 2017-12-07T07:21:22.000Z |
+--------------------------+
1 row in set (0.00 sec)

```

## 触发器(Trigger)

### create trigger

#### Update 更新出发

实现 history 历史表功能，BEFORE update 做到数据库更新自动备份

```

CREATE TABLE user_history SELECT * FROM user WHERE 1 <> 1

DELIMITER //
CREATE TRIGGER user_history BEFORE update ON user FOR EACH ROW
BEGIN
insert into user_history SELECT * FROM user WHERE id = OLD.id;
END; //
DELIMITER ;

```

判断某字段数据修改满足条件后出发。

```

CREATE DEFINER=`dba`@`%` TRIGGER `cms`.`jc_content_BEFORE_UPDATE` BEFORE UPDATE ON `jc_content` FOR EACH ROW
BEGIN
	IF NEW.status = '1' THEN
		insert into `neo`.elasticsearch_trash(id) values(OLD.content_id);
	END IF;
    IF NEW.status = '2' THEN
		delete from `neo`.elasticsearch_trash where id = OLD.content_id;
	END IF;
END

```

#### Delete 删除出发

```

CREATE DEFINER=`dba`@`%` TRIGGER `cms`.`jc_content_BEFORE_DELETE` BEFORE DELETE ON `jc_content` FOR EACH ROW
BEGIN
	insert into `neo`.elasticsearch_trash(id) values(OLD.content_id);
END

```

#### Insert 插入出发

### drop trigger

```
DROP TRIGGER admin_user_history;

DELIMITER //
CREATE TRIGGER admin_user_history BEFORE update ON admin_user FOR EACH ROW
BEGIN
insert into admin_user_history SELECT * FROM admin_user WHERE user_id = OLD.user_id;
END; //
DELIMITER;

```

### show triggers

```
show triggers;

```

#### SHOW CREATE TRIGGER

```

mysql> SHOW CREATE TRIGGER ins_sum\G
*************************** 1\. row ***************************
               Trigger: ins_sum
              sql_mode: STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION
SQL Original Statement: CREATE DEFINER=`me`@`localhost` TRIGGER ins_sum
                        BEFORE INSERT ON account
                        FOR EACH ROW SET @sum = @sum + NEW.amount
  character_set_client: utf8
  collation_connection: utf8_general_ci
    Database Collation: latin1_swedish_ci
               Created: 2013-07-09 10:39:34.96			

```

### EXAMPLE

#### BEFORE/AFTER

例 62.1. BEFORE/AFTER

```
DROP TRIGGER MY_TEST_MONITOR;
DELIMITER //
CREATE TRIGGER MY_TEST_MONITOR BEFORE insert ON MY_TEST FOR EACH ROW
BEGIN
	INSERT INTO MY_TEST_MONITOR SELECT * FROM MY_TEST WHERE TICKET = NEW.TICKET;
END; //
DELIMITER;

```

```
DROP TRIGGER MY_TEST_MONITOR;
DELIMITER //
CREATE TRIGGER MY_TEST_MONITOR AFTER insert ON MY_TEST FOR EACH ROW
BEGIN
	INSERT INTO MY_TEST_MONITOR SELECT * FROM MY_TEST WHERE TICKET = NEW.TICKET;
END; //
DELIMITER;

```

通过触发器保护数据，防止重复插入数据

```
CREATE DEFINER=`neo`@`%` TRIGGER `members_before_insert` BEFORE INSERT ON `members` FOR EACH ROW BEGIN
	IF new.username IS NOT NULL THEN
		IF exists(select m.username from members m where m.username = new.username) THEN
	   	set new.username = '';
		END IF;
	END IF;
END					

```

#### UUID

例 62.2. uuid()

```
delimiter $$

CREATE TABLE `member` (
  `uuid` char(36) NOT NULL,
  `username` varchar(20) DEFAULT NULL,
  `password` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8$$

CREATE
DEFINER=`root`@`%`
TRIGGER `test`.`member_before_insert`
BEFORE INSERT ON `test`.`member`
FOR EACH ROW
SET new.uuid = uuid()
$$

```

#### CALL PROCEDURE

```

CREATE DEFINER=`neo`@`%` TRIGGER `accounts_angelfund` AFTER INSERT ON `accounts` FOR EACH ROW BEGIN

   IF new.paymode = 'angelfund' THEN
		call angelfund(new.name,new.ctime);		
   END IF;

END

CREATE DEFINER=`neo`@`%` PROCEDURE `angelfund`(IN `puid` VARCHAR(50), IN `ptime` DATETIME)
	LANGUAGE SQL
	NOT DETERMINISTIC
	CONTAINS SQL
	SQL SECURITY DEFINER
	COMMENT ''
BEGIN

	DECLARE fusername VARCHAR(16) DEFAULT NULL;
	DECLARE fchinese_name VARCHAR(16) DEFAULT NULL;
	DECLARE fmembers_date VARCHAR(20) DEFAULT NULL;

	SELECT username,chinese_name,FROM_UNIXTIME(createtime) INTO fusername,fchinese_name,fmembers_date FROM members WHERE username = puid;

	IF fusername IS NOT NULL THEN
		INSERT IGNORE INTO angelfund(username,chinese_name,members_date,accounts_date,endtime,`status`,op,operator,`description`) value(fusername,fchinese_name,fmembers_date,ptime,DATE_ADD(ptime, INTERVAL +1 MONTH),'N','N','computer','');
   END IF;

END				

```

## 事件调度器(EVENT)

### 启用 EVENT

```

set GLOBAL event_scheduler=ON;

```

my.cnf 配置

```

event_scheduler=on

```

查看状态

```

mysql> select @@GLOBAL.event_scheduler;
+--------------------------+
| @@GLOBAL.event_scheduler |
+--------------------------+
| ON                       |
+--------------------------+
1 row in set (0.00 sec)

mysql> SHOW VARIABLES LIKE 'event_scheduler';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| event_scheduler | ON    |
+-----------------+-------+
1 row in set (0.01 sec)

```

### 创建 EVENT

```

DROP EVENT IF EXISTS `captcha`;
DELIMITER //
CREATE DEFINER=`neo`@`%` EVENT `captcha` ON SCHEDULE EVERY 5 MINUTE STARTS '2013-07-08 16:27:03' ON COMPLETION PRESERVE ENABLE DO BEGIN
	delete from captcha where ctime < DATE_ADD(now(), INTERVAL -5 MINUTE);
END//
DELIMITER ;

```

### 禁用/启用

```
			ALTER EVENT captcha DISABLE;

```

```
			ALTER EVENT captcha ENABLE;

```

### show events

```

mysql> show events;
+--------+-------------+---------+-----------+-----------+------------+----------------+----------------+---------------------+------+---------+------------+----------------------+----------------------+--------------------+
| Db     | Name        | Definer | Time zone | Type      | Execute at | Interval value | Interval field | Starts              | Ends | Status  | Originator | character_set_client | collation_connection | Database Collation |
+--------+-------------+---------+-----------+-----------+------------+----------------+----------------+---------------------+------+---------+------------+----------------------+----------------------+--------------------+
| netkiller | captcha     | neo@%   | SYSTEM    | RECURRING | NULL       | 5              | MINUTE         | 2013-07-08 16:27:03 | NULL | ENABLED |          1 | utf8                 | utf8_general_ci      | utf8_general_ci    |
| netkiller | sms_ips_log | neo@%   | SYSTEM    | RECURRING | NULL       | '0 5'          | DAY_HOUR       | 2013-07-09 14:39:51 | NULL | ENABLED |          1 | utf8                 | utf8_general_ci      | utf8_general_ci    |
+--------+-------------+---------+-----------+-----------+------------+----------------+----------------+---------------------+------+---------+------------+----------------------+----------------------+--------------------+
2 rows in set (0.00 sec)

mysql> show events \G;
*************************** 1\. row ***************************
                  Db: netkiller
                Name: captcha
             Definer: neo@%
           Time zone: SYSTEM
                Type: RECURRING
          Execute at: NULL
      Interval value: 5
      Interval field: MINUTE
              Starts: 2013-07-08 16:27:03
                Ends: NULL
              Status: ENABLED
          Originator: 1
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
*************************** 2\. row ***************************
                  Db: netkiller
                Name: sms_ips_log
             Definer: neo@%
           Time zone: SYSTEM
                Type: RECURRING
          Execute at: NULL
      Interval value: '0 5'
      Interval field: DAY_HOUR
              Starts: 2013-07-09 14:39:51
                Ends: NULL
              Status: ENABLED
          Originator: 1
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: utf8_general_ci
2 rows in set (0.00 sec)

ERROR:
No query specified

```

### 实例·每月创建一个表

每月创建一张新表，适用于分表的场景

```

CREATE DEFINER=`neo`@`netkiller` EVENT `logging`
	ON SCHEDULE
		EVERY 1 MONTH STARTS '2017-12-11 15:51:00'
	ON COMPLETION PRESERVE
	ENABLE
	COMMENT '每月自动创建表'
DO BEGIN
	declare _table_date varchar(10);
	select date_format(date_add(curdate(),interval 1 month),'%Y%m') into _table_date;
	call logging(_table_date);
END

```

```

CREATE DEFINER=`neo`@`netkiller` PROCEDURE `logging`(
	IN `table_date` VARCHAR(10)
)
LANGUAGE SQL
NOT DETERMINISTIC
CONTAINS SQL
SQL SECURITY DEFINER
COMMENT ''
BEGIN
	set @_table_name = CONCAT('log_',table_date);
	set @_create = "CREATE TABLE If Not Exists ";
	set @_param = "(
			`id` INT(11) NOT NULL AUTO_INCREMENT,
			`type` VARCHAR(255) NULL DEFAULT NULL COMMENT '日志类型 1：网站 2：IOS 3:Android',
			`url` VARCHAR(640) NULL DEFAULT NULL COMMENT '用户访问 url',
			`serverIp` VARCHAR(255) NULL DEFAULT NULL COMMENT '服务器 ip',
			`bodyBytesSent` VARCHAR(255) NULL DEFAULT NULL,
			`bytesSent` VARCHAR(255) NULL DEFAULT NULL COMMENT '参数字节数',
			`browser` VARCHAR(255) NULL DEFAULT NULL COMMENT '浏览器信息',
			`ctime` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
			`mtime` TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
			PRIMARY KEY (`id`),
			INDEX `ctime` (`ctime`, `deviceType`,`isFirst`),
			INDEX `userIp` (`userIp`),
			INDEX `deviceId` (`deviceId`),
			INDEX `account` (`account`)
		)
		COMMENT='APP 访问记录'
		COLLATE='utf8_general_ci'
		ENGINE=InnoDB
		;";

	SET @sql = CONCAT(@_create,@_table_name,@_param);
	PREPARE stmt FROM @sql;
	EXECUTE stmt;
	Deallocate prepare stmt;
END

```

## 第 63 章 DML (Data Manipulation Language)

```
SELECT - retrieve data from the a database
INSERT - insert data into a table
UPDATE - updates existing data within a table
DELETE - deletes all records from a table, the space for the records remain
CALL - call a PL/SQL or Java subprogram
EXPLAIN PLAN - explain access path to data
LOCK TABLE - control concurrency

```

## INSERT

### INSERT INTO ... SELECT

```
SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='';
DELIMITER //
CREATE TRIGGER `members_mobile_insert` BEFORE INSERT ON `members_mobile` FOR EACH ROW BEGIN
	insert into members_location(id,province,city) select NEW.id,mobile_location.province,mobile_location.city from  mobile_location where mobile_location.id = md5(LEFT(NEW.number, 7));
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;

```

### INSERT IGNORE

INSERT IGNORE 与 INSERT INTO 的区别就是 INSERT IGNORE 会忽略数据库中已经存在 的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。

```
insert ignore into table(name)  select  name from table2

```

### INSERT...ON DUPLICATE KEY UPDATE

```

create table foo (id serial primary key, u int, unique key (u));

insert into foo (u) values (10);
insert into foo (u) values (10) on duplicate key update u = 20;

mysql> select * from foo;
+----+------+
| id | u    |
+----+------+
|  1 |   20 |
+----+------+

```

```

DROP TRIGGER IF EXISTS `cms`.`jc_content_BEFORE_DELETE`;

DELIMITER $$
USE `cms`$$
CREATE DEFINER=`5kwords`@`%` TRIGGER `jc_content_BEFORE_DELETE` BEFORE DELETE ON `jc_content`
FOR EACH ROW BEGIN

    insert into `cms`.elasticsearch_trash(id) values(OLD.content_id) on duplicate key update ctime = now();
    insert into `cms`.trash(id,`type`, site_id) values(OLD.content_id, "delete", OLD.site_id) on duplicate key update `type`="delete", ctime = now();

END$$
DELIMITER ;

```

## REPLACE

replace 类似 ON DUPLICATE KEY UPDATE，插入过程遇到已经存在的字段，会更新处理。

```
replace into (id) value('1')

```

## DELETE

### 删除重复数据

```
delete from member group by username having count(username) > 1

```

## 第 64 章 SQL Statement Syntax

### *Structured Query Language*

## DISTINCT

SELECT DISTINCT user.name FROM user

```
SELECT DISTINCT user.name FROM user

```

## group by

统计重复的手机号吗

```
select * from (select count(mobile) as c, mobile from member where length(mobile) >= 11 group by mobile) as m where m.c > 1;

```

## HAVING

```
select * from accounts where paymode='alipay' group by name having count(name) >1;

```

## REGEXP

### 正则匹配

判断非数字字符

```
select '看 89700' regexp '^[0-9]+$'
select '89 看 700' regexp '^[0-9]+$'
select '89700 看' regexp '^[0-9]+$'

```

应用到实际工作中

```
select count(*) from accounts a where a.name != '' and not a.name regexp '^[0-9]+$';
select count(*) from accounts a,members m where  a.member = m.id  and a.name != '' and  not a.name regexp '^[0-9]+$' group by member;
SELECT * FROM tablename WHERE SUBSTRING(fieldname, 1, 1) REGEXP '[[:digit:]]';

```

## IN / NOT IN

```
select * from members where id in ('1','100','1000');
select * from members where group_id in (select id from members_group);

```

## ALL / Any

NOT IN 与 <> ALL 两个语句是相同的：

```

SELECT s1 FROM t1 WHERE s1 <> ALL (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);

```

IN 与 "＝ANY" 两个语句是一样的：

```
SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);

```

例 64.1. SQL ANY example

```

select * from members where id = any(select members_id from accounts where id < 100);

```

## exists, not exists

```
SELECT c.id, companyname
FROM customers c
WHERE EXISTS(
    SELECT orderid FROM orders o WHERE o.customer_id = cu.id)

```

## UNION

union 分页问题

```
(SELECT a FROM tbl_name_a WHERE a=10 AND B=1)
UNION
(SELECT a FROM tbl_name_b WHERE a=11 AND B=2)
ORDER BY a LIMIT 10;

```

```
select * from (
	select a from tbl_name_a WHERE a=10 AND B=1
	union all
	select a from tbl_name_b WHERE a=10 AND B=1
) tbl_name
order by a limit 0,1;

```

### UNION ALL

UNION ALL 不会合并重复的记录

```
select a,b from tbl_name_a WHERE a=10 AND B=1
union all
select a,b from tbl_name_b WHERE a=10 AND B=1

```

### 两张表字段不对等解决方法

```

SELECT * FROM
    (
    SELECT contract_address, decimals, name, symbol, seq, logo FROM token 
    UNION 
    SELECT contract_address, decimals, name, symbol, 100, 'https://www.netkiller.cn/images/eth.jpg' FROM user_token WHERE address = '0xB94054c174995AE2A9E7fcf6c7924635FBa8ECF7' AND contract_address NOT IN (SELECT contract_address FROM token)
    ) AS tmp
ORDER BY seq			

```

## OUTFILE/LOAD DATA INFILE

查询结果输出到文件

```
SELECT * FROM tablename INTO OUTFILE '/tmp/tablename.txt';

```

使用 tee 将屏幕输出到文件

```

mysql>tee /home/neo/screen.txt
mysql>select * from user;
mysql>exit

```

```

SELECT * INTO OUTFILE '/home/mark/Orders.txt'
　　FIELDS
　　TERMINATED BY = ','
　　FROM Orders
　　WHERE Order_Date >= '2000-01-01'

```

```

LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table;

```

### Export data to CSV from MySQL

```
SELECT *
INTO OUTFILE '/tmp/products.csv'
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
ESCAPED BY '\\'
LINES TERMINATED BY '\n'
FROM products

```

### Import data from CSV file.

```
LOAD DATA LOW_PRIORITY LOCAL INFILE 'C:\\hx.csv' IGNORE INTO TABLE `tmp`.`creditlog`
CHARACTER SET gbk FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '"' LINES TERMINATED BY '\r\n'
(`ctime`, `login`, `mode`, `type`, `prevavailcredit`, `change`, `newavailcredit`, `comment`);

```

## CASE Syntax

```
CASE case_value
    WHEN when_value THEN statement_list
    [WHEN when_value THEN statement_list] ...
    [ELSE statement_list]
END CASE

Or:

CASE
    WHEN search_condition THEN statement_list
    [WHEN search_condition THEN statement_list] ...
    [ELSE statement_list]
END CASE

```

## MySQL 专有命令

### SQL_NO_CACHE

```
SELECT /*!40001 SQL_NO_CACHE */ * FROM table

```

### SIGNAL Syntax

```
DROP TRIGGER `members_before_insert`;
CREATE DEFINER=`neo`@`%` TRIGGER `members_before_insert` BEFORE INSERT ON `members` FOR EACH ROW BEGIN
	IF new.username IS NOT NULL THEN
		IF not exists(select username from members_available where username = new.username) THEN
	   	/*set new.username = NULL;*/
	   	SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;
		END IF;
	END IF;
END;

```

## SQL 92

insert + select

```
insert into product_type_commission select id,5,1,1,0,0,0,0,0,0 from product_type where title='notebook' and is_physical=0;

```

update table1,table2

```
begin;
ALTER TABLE `customer` ADD COLUMN `cutoff_time` TIMESTAMP NOT NULL default '0000-00-00 00:00:00';
update customer,agent set customer.cutoff_time = agent.cutoff_time where customer.id = agent.id;
ALTER TABLE `agent` DROP COLUMN `cutoff_time`;
commit;

```

update table1 set field1 = (select value from table2)

```
UPDATE
	transaction
SET
	transaction.total_sold_price = (
		SELECT
			SUM(transaction_item.price)
	FROM
			transaction_item
		WHERE transaction_item.transaction_id = 100
	)
WHERE
	transaction.id = 100

```

update table1, (select * from other) as table2 set table1.field1 = table2.field1

```
UPDATE
	transaction,(	SELECT
						SUM(product_item.bought_price) AS total_bought_price, transaction_item.transaction_id
					FROM
						transaction_item
			    	WHERE
						transaction_item.transaction_id IN ( '123','456' )
			     ) as total
SET
	transaction.total_bought_price = total.total_bought_price
WHERE
	transaction.id = total.transaction_id

```

join + subquery

```
select u.*,t.category,t.items,t.[property] from tb_sysregchkusers as u left join (select a.items as category, b.* from (select id, items from tb_sysregchktask where categoryid=0) as a left join tb_sysregchktask as b on b.categoryid=a.id ) as t on u.taskID=t.id

select * from tb_sysregchklog where CONVERT(datetime,CONVERT(varchar(10),checkTime,120)) between convert(datetime,'2007-12-12') and convert(datetime,'2007-12-12')

```

```
select DISTINCT user_point_history.user_id,user.username,
(select count(id) from transaction where id = user_point_history.transaction_id) as transactions,
(SELECT SUM(u_p_h.points) FROM user_point_history as u_p_h WHERE u_p_h.type != 'RDMP' AND u_p_h.status IN('pr','ac') AND u_p_h.user_id = user_point_history.user_id) as total_points_earned,
(SELECT SUM(u_p_h.points) FROM user_point_history as u_p_h WHERE u_p_h.type = 'RDMP' AND u_p_h.status IN('pr','ac') AND u_p_h.user_id = user_point_history.user_id) as total_points_redeemed
from user_point_history,user where user_point_history.user_id = user.id;

```

(total_points_earned - total_points_redeemed) as current_balance_points

```
select user_id, username, transactions, total_points_earned, total_points_redeemed, (total_points_earned - total_points_redeemed) as current_balance_points
from (select DISTINCT user_point_history.user_id,user.username,
(select count(id) from transaction where id = user_point_history.transaction_id) as transactions,
(SELECT SUM(u_p_h.points) FROM user_point_history as u_p_h WHERE u_p_h.type != 'RDMP' AND u_p_h.status IN('pr','ac') AND u_p_h.user_id = user_point_history.user_id) as total_points_earned,
(SELECT SUM(u_p_h.points) FROM user_point_history as u_p_h WHERE u_p_h.type = 'RDMP' AND u_p_h.status IN('pr','ac') AND u_p_h.user_id = user_point_history.user_id) as total_points_redeemed
from user_point_history,user where user_point_history.user_id = user.id) as user_performance;

```

subquery 作为一个字段使用

```
select product_type_attribute.*,(select 'selected' from product_type_attribute_set where product_type_attribute_set.product_type_attribute_id = product_type_attribute.id and product_type_attribute_set.product_type_id = 26) as selected
from product_type_attribute;

```

## 第 65 章 Functions and Operators

## COUNT

count()

```
SELECT (SELECT count(1) FROM ecs_category) as 'Export category count',
	(SELECT count(1) FROM ecs_goods) as 'Goods count',
	(SELECT count(1) FROM ecs_goods_attr) as 'Attr count';

```

## group_concat() 列传行

```
SELECT tags FROM neo.article;

linux
redis
mysql
java
php

```

tags 字段专为一行显示

```
SELECT group_concat(tags) FROM neo.article;		

linux,redis,mysql,java,php

```

distinct 去除重复数据

```
select group_concat(distinct author) from neo.article;		

```

以 id 分组，把 name 字段的值打印在一行，分号分隔

```
select id,group_concat(tags separator ';') from neo.article group by tags;		

```

排序结果

```
select group_concat(distinct author order by author desc) from neo.article;			

```

## UUID()

```
SELECT UUID(),LENGTH(UUID()),UUID_SHORT(), LENGTH(UUID_SHORT());

```

## String

### LEFT/RIGHT

LEFT(str,len)

```
mysql> select left(concat('1','0000000'),5) as number;
+--------+
| number |
+--------+
| 10000  |
+--------+
1 row in set (0.00 sec)

```

RIGHT(str,len)

```
mysql> select right(concat('0000000','1'),5) as number;
+--------+
| number |
+--------+
| 00001  |
+--------+
1 row in set (0.00 sec)

```

### RPAD/LPAD

补齐长度用'0'填充

**RPAD(str,len,padstr)**

```
mysql> select rpad('10',5,'0') as txt;
+-------+
| txt   |
+-------+
| 10000 |
+-------+
1 row in set (0.01 sec)

```

**LPAD(str,len,padstr)**

```
mysql> select lpad('10',5,'0') as txt;
+-------+
| txt   |
+-------+
| 00010 |
+-------+
1 row in set (0.00 sec)

```

### CONCAT

CONCAT(str1,str2,...)

```
mysql> select concat('Neo',' ','Chen') as Name;
+----------+
| Name     |
+----------+
| Neo Chen |
+----------+
1 row in set (0.00 sec)

```

### CONCAT_WS

```

SELECT CONCAT_WS(',', 'Neo', 'Chen');
Neo,Chen

SELECT CONCAT_WS('-', 'Neo', 'Chen');
Neo-Chen			

```

使用逗号链接字符串

```

SELECT 
    CONCAT_WS(',', id, name, age)
FROM
    mytable			

```

### 链接所有字段

当我使用 select CONCAT_WS(",", *) as string from tab 时发现不支持 * 操作。

解决方案如下

```

SET @column = NULL;

SELECT 
    GROUP_CONCAT(COLUMN_NAME) AS fields INTO @column
FROM
    INFORMATION_SCHEMA.Columns
WHERE
    table_name = 'mytable'
        AND table_schema = 'test';

-- select @column;

SET @sql = CONCAT('SELECT CONCAT_WS(",",',@column, ' )  FROM mytable');

select @sql;

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

```

### GROUP_CONCAT

```
mysql> select GROUP_CONCAT(CONVERT( username , CHAR (16)) order by username desc) as username from test;
+-------------------------------------------+
| username                                  |
+-------------------------------------------+
| jam,jam2,john,john2,john3,neo,neo1,neo2   |
+-------------------------------------------+
6 rows in set, 1 warning (0.01 sec)

```

### replace

```
select replace(goods_desc,':8000','') from ecs_goods;

update ecs_goods set goods_desc=replace(goods_desc,':8000','');

```

### SUBSTRING

```

mysql> SELECT SUBSTRING('netkiller',4,4);   
+----------------------------+
| SUBSTRING('netkiller',4,4) |
+----------------------------+
| kill                       |
+----------------------------+
1 row in set (0.00 sec)			

```

与 left,right 相同的用法

```
select right('M2014030615410572307:DEPOSIT', 7);
SELECT SUBSTRING('M2014030615410572307:DEPOSIT', -7);			

```

### SUBSTRING_INDEX

```
SELECT SUBSTRING_INDEX('M2014030615410572307:DEPOSIT', ':', -1);
SELECT SUBSTRING_INDEX('M2014030615410572307:DEPOSIT', ':', 1);			

```

### AES_ENCRYPT / AES_DECRYPT

简单用法

```

mysql> select AES_ENCRYPT('helloworld','key');
+---------------------------------+
| AES_ENCRYPT('helloworld','key') |
+---------------------------------+
|                                 |
+---------------------------------+
1 row in set (0.00 sec)

mysql> select AES_DECRYPT(AES_ENCRYPT('helloworld','key'),'key');
+----------------------------------------------------+
| AES_DECRYPT(AES_ENCRYPT('helloworld','key'),'key') |
+----------------------------------------------------+
| helloworld                                         |
+----------------------------------------------------+
1 row in set (0.00 sec)

mysql>

```

加密数据入库

```

CREATE TABLE `encryption` (
	`mobile` VARBINARY(16) NOT NULL,
	`key` VARCHAR(32) NOT NULL
)
ENGINE=InnoDB;

INSERT INTO encryption(`mobile`,`key`)VALUES( AES_ENCRYPT('13691851789',md5('13691851789')), md5('13691851789')) 
select AES_DECRYPT(mobile,`key`), length(mobile) from encryption;

```

## Date and Time

```
SELECT NOW(),CURRENT_TIMESTAMP(),SYSDATE();		

```

### year/month/day hour:minite:second

```

mysql> select year('2012-03-20');
+--------------------+
| year('2012-03-20') |
+--------------------+
|               2012 |
+--------------------+
1 row in set (0.00 sec)

mysql> select month('2012-03-20');
+---------------------+
| month('2012-03-20') |
+---------------------+
|                   3 |
+---------------------+
1 row in set (0.00 sec)

mysql> select day('2012-03-20');
+-------------------+
| day('2012-03-20') |
+-------------------+
|                20 |
+-------------------+
1 row in set (0.00 sec)

mysql> select hour('12:30:55');
+------------------+
| hour('12:30:55') |
+------------------+
|               12 |
+------------------+
1 row in set (0.00 sec)

mysql> select minute('12:30:55');
+--------------------+
| minute('12:30:55') |
+--------------------+
|                 30 |
+--------------------+
1 row in set (0.00 sec)

mysql> select second('12:30:55');
+--------------------+
| second('12:30:55') |
+--------------------+
|                 55 |
+--------------------+
1 row in set (0.00 sec)

```

### Unix time

语法：FROM_UNIXTIME(unix_timestamp,format)
返回表示 Unix 时间标记的一个字符串，根据 format 字符串格式化。format 可以包含与 DATE_FORMAT()函数列出的条目同样的修饰符。
根据 format 字符串格式化 date 值。
下列修饰符可以被用在 format 字符串中：
%M 月名字(January……December)
%W 星期名字(Sunday……Saturday)
%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）
%Y 年, 数字, 4 位
%y 年, 数字, 2 位
%a 缩写的星期名字(Sun……Sat)
%d 月份中的天数, 数字(00……31)
%e 月份中的天数, 数字(0……31)
%m 月, 数字(01……12)
%c 月, 数字(1……12)
%b 缩写的月份名字(Jan……Dec)
%j 一年中的天数(001……366)
%H 小时(00……23)
%k 小时(0……23)
%h 小时(01……12)
%I 小时(01……12)
%l 小时(1……12)
%i 分钟, 数字(00……59)
%r 时间,12 小时(hh:mm:ss [AP]M)
%T 时间,24 小时(hh:mm:ss)
%S 秒(00……59)
%s 秒(00……59)
%p AM 或 PM
%w 一个星期中的天数(0=Sunday ……6=Saturday ）
%U 星期(0……52), 这里星期天是星期的第一天
%u 星期(0……52), 这里星期一是星期的第一天
%% 一个文字“%”。

```

mysql> SELECT UNIX_TIMESTAMP('2005-03-27 02:00:00');
+---------------------------------------+
| UNIX_TIMESTAMP('2005-03-27 02:00:00') |
+---------------------------------------+
|                            1111885200 |
+---------------------------------------+
mysql> SELECT FROM_UNIXTIME(1111885200);
+---------------------------+
| FROM_UNIXTIME(1111885200) |
+---------------------------+
| 2005-03-27 03:00:00       |
+---------------------------+

```

```

SELECT UNIX_TIMESTAMP('2012-01-01 00:00:00');
SELECT UNIX_TIMESTAMP('2012-07-30 00:00:00');
SELECT UNIX_TIMESTAMP();
SELECT UNIX_TIMESTAMP('2009-08-06') ;
SELECT UNIX_TIMESTAMP( curdate( ) );

select FROM_UNIXTIME(UNIX_TIMESTAMP('2012-07-30 00:00:00'), '%Y-%m-%d');
SELECT FROM_UNIXTIME( 1249488000, '%Y 年%m 月%d 日' );

SELECT FROM_UNIXTIME(time_stamp, '%Y-%m-%d %H:%i:%S') FROM test.transaction_history;

select FROM_UNIXTIME(createtime, '%m') as month, count(1) as count from members where createtime BETWEEN UNIX_TIMESTAMP('2012-01-01 00:00:00') and UNIX_TIMESTAMP('2012-12-31 00:00:00') group by FROM_UNIXTIME(createtime, '%m');
select FROM_UNIXTIME(createtime, '%m') as month, count(1) as count from members where createtime BETWEEN UNIX_TIMESTAMP('2011-01-01 00:00:00') and UNIX_TIMESTAMP('2011-12-31 00:00:00') group by FROM_UNIXTIME(createtime, '%m');

select FROM_UNIXTIME(createtime, '%m-%d') as month, count(1) as count from members where createtime BETWEEN UNIX_TIMESTAMP('2011-01-01 00:00:00') and UNIX_TIMESTAMP('2011-12-31 00:00:00') group by FROM_UNIXTIME(createtime, '%m-%d');
select FROM_UNIXTIME(createtime, '%m-%d') as month, count(1) as count from members where createtime BETWEEN UNIX_TIMESTAMP('2012-01-01 00:00:00') and UNIX_TIMESTAMP('2012-12-31 00:00:00') group by FROM_UNIXTIME(createtime, '%m-%d');

```

### DATE_FORMAT

DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据。

```
语法
DATE_FORMAT(date,format)
date 参数是合法的日期。format 规定日期/时间的输出格式。

可以使用的格式有：
格式	描述
%a	缩写星期名
%b	缩写月名
%c	月，数值
%D	带有英文前缀的月中的天
%d	月的天，数值(00-31)
%e	月的天，数值(0-31)
%f	微秒
%H	小时 (00-23)
%h	小时 (01-12)
%I	小时 (01-12)
%i	分钟，数值(00-59)
%j	年的天 (001-366)
%k	小时 (0-23)
%l	小时 (1-12)
%M	月名
%m	月，数值(00-12)
%p	AM 或 PM
%r	时间，12-小时（hh:mm:ss AM 或 PM）
%S	秒(00-59)
%s	秒(00-59)
%T	时间, 24-小时 (hh:mm:ss)
%U	周 (00-53) 星期日是一周的第一天
%u	周 (00-53) 星期一是一周的第一天
%V	周 (01-53) 星期日是一周的第一天，与 %X 使用
%v	周 (01-53) 星期一是一周的第一天，与 %x 使用
%W	星期名
%w	周的天 （0=星期日, 6=星期六）
%X	年，其中的星期日是周的第一天，4 位，与 %V 使用
%x	年，其中的星期一是周的第一天，4 位，与 %v 使用
%Y	年，4 位
%y	年，2 位

```

实例

```
下面的脚本使用 DATE_FORMAT() 函数来显示不同的格式。我们使用 NOW() 来获得当前的日期/时间：
DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p')
DATE_FORMAT(NOW(),'%m-%d-%Y')
DATE_FORMAT(NOW(),'%d %b %y')
DATE_FORMAT(NOW(),'%d %b %Y %T:%f')

SELECT DATE_FORMAT(NOW(),'%Y-%m-%d');

select DATE_FORMAT(asctime,'%Y-%m-%d') as Date, count(1) as Count from logging where tag='www' and facility='login' group by DATE_FORMAT(asctime,'%Y-%m-%d') order by asctime desc;

```

### DATE_SUB/DATE_ADD

当前时间向后推 10 天

```

mysql> select DATE_SUB(now(), INTERVAL 240 HOUR);
+------------------------------------+
| DATE_SUB(now(), INTERVAL 240 HOUR) |
+------------------------------------+
| 2012-03-09 10:26:03                |
+------------------------------------+
1 row in set (0.00 sec)

mysql> select DATE_SUB(now(), INTERVAL 24 HOUR);
+-----------------------------------+
| DATE_SUB(now(), INTERVAL 24 HOUR) |
+-----------------------------------+
| 2012-03-18 10:28:43               |
+-----------------------------------+
1 row in set (0.00 sec)

```

```

DELETE from Message where created < DATE_sub(now(), INTERVAL 240 HOUR);

select * from PRICES_HISTORY where DATE_FORMAT(TIME ,GET_FORMAT(DATE,'ISO')) = (
select if ( WEEKDAY(CURRENT_DATE())=6 , DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) , CURRENT_DATE())
)

```

#### DATE_ADD

```
SELECT DATE_ADD('1998-01-02', INTERVAL 31 DAY);

```

### datediff / timediff

计算时间差，两个时间相减结果

```

mysql> select timediff('22:20:00','17:30:00');
+---------------------------------+
| timediff('22:20:00','17:30:00') |
+---------------------------------+
| 04:50:00                        |
+---------------------------------+
1 row in set (0.00 sec)

mysql> select datediff('2008-08-08 12:00:00', '2008-08-01 00:00:00');
+--------------------------------------------------------+
| datediff('2008-08-08 12:00:00', '2008-08-01 00:00:00') |
+--------------------------------------------------------+
|                                                      7 |
+--------------------------------------------------------+
1 row in set (0.00 sec)

```

## 数值函数

### cast 类型转换

```

mysql> SELECT cast(SUBSTRING('123456789',1,4) as UNSIGNED) * 100;   
+----------------------------------------------------+
| cast(SUBSTRING('123456789',1,4) as UNSIGNED) * 100 |
+----------------------------------------------------+
|                                             123400 |
+----------------------------------------------------+
1 row in set (0.00 sec)		

```

### truncate 保留小数位数

```

select profit, deficit, concat(truncate((profit / deficit)*100,2),'%') as percentage from ((select count(*) as profit from angelfund where profit > 0) as profit, (select count(*) as deficit from angelfund where profit < 0) as deficit);		

```

### MOD 求余

```

mysql> select 9 mod 5;
+---------+
| 9 mod 5 |
+---------+
|       4 |
+---------+
1 row in set (0.00 sec)

mysql> select mod(5,2);
+----------+
| mod(5,2) |
+----------+
|        1 |
+----------+
1 row in set (0.00 sec)

mysql> select mod(5,2);			

```

## Control Flow Functions

CASE

```

mysql> SELECT CASE 1 WHEN 1 THEN 'one'
    ->     WHEN 2 THEN 'two' ELSE 'more' END;
        -> 'one'
mysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;
        -> 'true'
mysql> SELECT CASE BINARY 'B'
    ->     WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;
        -> NULL		

```

IFNULL

```

mysql> SELECT IFNULL("TEST", 'OK');
+----------------------+
| IFNULL("TEST", 'OK') |
+----------------------+
| TEST                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT IFNULL(NULL, 'OK');
+--------------------+
| IFNULL(NULL, 'OK') |
+--------------------+
| OK                 |
+--------------------+
1 row in set (0.00 sec)		

```

NULLIF()

IF

```

mysql> SELECT IFNULL("TEST", 'OK');
+----------------------+
| IFNULL("TEST", 'OK') |
+----------------------+
| TEST                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT IFNULL(NULL, 'OK');
+--------------------+
| IFNULL(NULL, 'OK') |
+--------------------+
| OK                 |
+--------------------+
1 row in set (0.00 sec)		

```

## 第 66 章 PostgreSQL GUI

## pgAdmin III

[`www.pgadmin.org/`](http://www.pgadmin.org/)

## phpPgAdmin

homepage: http://phppgadmin.sourceforge.net/

```
$ wget http://nchc.dl.sourceforge.net/sourceforge/phppgadmin/phpPgAdmin-4.2.2.tar.bz2
$ tar jxvf phpPgAdmin-4.2.2.tar.bz2
$ ln -s phpPgAdmin-4.2.2 phpPgAdmin

```

## Monitoring

### PgBadger

[`projects.dalibo.org/pgbadger/example.html`](http://projects.dalibo.org/pgbadger/example.html)

## pgModeler - PostgreSQL Database Modeler

[`pgmodeler.com.br/`](http://pgmodeler.com.br/)

## 第 70 章 Barman for PostgreSQL

http://www.pgbarman.org/

## 第 68 章 pgbouncer - lightweight connection pooler for PostgreSQL

http://pgfoundry.org/projects/pgbouncer/

## 安装 pgbouncer

### Ubuntu

Ubuntu 13.04

```
$ apt-cache search pgbouncer
pgbouncer - lightweight connection pooler for PostgreSQL

$ sudo apt-get install pgbouncer

```

```
$ dpkg -L pgbouncer
/.
/usr
/usr/share
/usr/share/man
/usr/share/man/man5
/usr/share/man/man5/pgbouncer.5.gz
/usr/share/man/man1
/usr/share/man/man1/pgbouncer.1.gz
/usr/share/doc
/usr/share/doc/pgbouncer
/usr/share/doc/pgbouncer/config.html
/usr/share/doc/pgbouncer/README
/usr/share/doc/pgbouncer/README.Debian
/usr/share/doc/pgbouncer/README.html
/usr/share/doc/pgbouncer/faq.html
/usr/share/doc/pgbouncer/copyright
/usr/share/doc/pgbouncer/todo.html
/usr/share/doc/pgbouncer/examples
/usr/share/doc/pgbouncer/examples/pgbouncer.ini.gz
/usr/share/doc/pgbouncer/examples/userlist.txt
/usr/share/doc/pgbouncer/NEWS.gz
/usr/share/doc/pgbouncer/AUTHORS
/usr/share/doc/pgbouncer/usage.html
/usr/share/doc/pgbouncer/changelog.Debian.gz
/usr/sbin
/usr/sbin/pgbouncer
/etc
/etc/init.d
/etc/init.d/pgbouncer
/etc/pgbouncer
/etc/pgbouncer/userlist.txt
/etc/pgbouncer/pgbouncer.ini
/etc/default
/etc/default/pgbouncer

```

### CentOS

```
# yum install pgbouncer

```

```
# rpm -ql pgbouncer.x86_64 0:1.5.4-1.rhel6
/etc/pgbouncer/mkauth.py
/etc/pgbouncer/mkauth.pyc
/etc/pgbouncer/mkauth.pyo
/etc/pgbouncer/pgbouncer.ini
/etc/rc.d/init.d/pgbouncer
/etc/sysconfig/pgbouncer
/usr/bin/pgbouncer
/usr/share/doc/pgbouncer-1.5.4
/usr/share/doc/pgbouncer-1.5.4/AUTHORS
/usr/share/doc/pgbouncer-1.5.4/NEWS
/usr/share/doc/pgbouncer-1.5.4/README
/usr/share/man/man1/pgbouncer.1.gz
/usr/share/man/man5/pgbouncer.5.gz

```

## 配置 pgbouncer

databases 配置

```
[databases]
main = host=localhost port=5432 dbname=mydb user=myuser password=mypass connect_query='SELECT 1'

```

pgbouncer

```
[pgbouncer]
logfile = /var/log/pgbouncer.log
pidfile = /var/run/pgbouncer/pgbouncer.pid
listen_addr = 127.0.0.1
listen_port = 6432
auth_type = trust
auth_file = /etc/pgbouncer/userlist.txt
admin_users = postgres
stats_users = stats, postgres
pool_mode = session
server_reset_query = DISCARD ALL
max_client_conn = 100
default_pool_size = 20

```

例 68.1. /etc/pgbouncer/pgbouncer.ini

```
# grep -v '^;' /etc/pgbouncer/pgbouncer.ini | grep -v '^$'

```

```
[databases]
main = host=localhost port=5432 dbname=test user=test password=test connect_query='SELECT 1'
[pgbouncer]
logfile = /var/log/pgbouncer.log
pidfile = /var/run/pgbouncer/pgbouncer.pid
listen_addr = 127.0.0.1
listen_port = 1521
auth_type = trust
auth_file = /etc/pgbouncer/userlist.txt
admin_users = postgres
stats_users = stats, postgres
pool_mode = session
server_reset_query = DISCARD ALL
max_client_conn = 100
default_pool_size = 20

```

## 第 69 章 Foreign data wrappers

http://wiki.postgresql.org/wiki/Foreign_data_wrappers

## 第 70 章 Barman for PostgreSQL

http://www.pgbarman.org/

## 第 71 章 Connector

## Pomm

[`pomm.coolkeums.org/`](http://pomm.coolkeums.org/)

## 第 72 章 Replication

## Bucardo

### Asynchronous PostgreSQL Replication System

## 第 73 章 FAQ

## Reset root password 重置 MySQL root 密码

忘记 root 密码是使用 --skip-grant-tables 启动项

CentOS 6.x

```

# vim /etc/init.d/mysqld

 $exec --skip-grant-tables  --datadir="$datadir" --socket="$socketfile" \
    --pid-file="$mypidfile" \
    --basedir=/usr --user=mysql >/dev/null 2>&1 &

```

```

# /etc/init.d/mysqld restart
Stopping mysqld:                                           [  OK  ]
Starting mysqld:                                           [  OK  ]

# mysqladmin -u root flush-privileges password "newpassword"

```

### MySQL 5.7.x

CentOS 7.x

添加 skip-grant-tables=1 选项，然后重启 mysql

```

# cat /etc/my.cnf
# For advice on how to change settings please see
# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html

[mysqld]
#
# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M
#
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin
#
# Remove leading # to set options mainly useful for reporting servers.
# The server defaults are faster for transactions and fast SELECTs.
# Adjust sizes as needed, experiment to find the optimal values.
# join_buffer_size = 128M
# sort_buffer_size = 2M
# read_rnd_buffer_size = 2M
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
skip-grant-tables=1
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0

# Recommended in standard MySQL setup
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 

[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid

```

```

# systemctl restart mysqld

```

```

update mysql.user set authentication_string=password('netkiller') where user='root' and Host = 'localhost';
flush privileges;
quit;

```

```

# mysql
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.7.14 MySQL Community Server (GPL)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> update mysql.user set authentication_string=password('netkiller') where user='root' and Host = 'localhost';
Query OK, 1 row affected, 1 warning (0.03 sec)
Rows matched: 1  Changed: 1  Warnings: 1

mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql> quit;
Bye

```

删除 skip-grant-tables=1 重启 MySQL

### MySQL 8.0

```

[root@localhost log]# vim /etc/my.cnf

[mysqld]
skip-grant-table

```

```

ALTER USER root@localhost identified by 'MQiEge1ikst7S_6tlXzBOmt';
ALTER USER root@localhost PASSWORD EXPIRE NEVER;			

```

## 数据库内容替换

```

#!/bin/bash
HOST='localhost'
USER='neo'
PASS='chen'

SDB='neo'
TDB='netkiller'
MYSQLDUMP="mysqldump"
MYSQLDUMPOPTS="-h${HOST} -u${USER} -p${PASS}"

MYSQL="mysql"
MYSQLOPTS="-h${HOST} -u${USER} -p${PASS}"
#SED="sed -e 's/netkiller\.8800\.org/netkiller\.sf\.net/g' -e 's/陈景峰/景峰/g' -e 's/Neo/Netkiller/g'"

$MYSQL $MYSQLOPTS <<SQL
DROP DATABASE $TDB;
CREATE DATABASE $TDB DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
SQL

$MYSQLDUMP $MYSQLDUMPOPTS ${SDB} | sed -e 's/netkiller\.8800\.org/netkiller\.sf\.net/g' -e 's/陈景峰/景峰/g' -e 's/Neo/Netkiller/g' | $MYSQL $MYSQLOPTS ${TDB}
#echo "$MYSQLDUMP $MYSQLDUMPOPTS ${SDB} | $SED | $MYSQL $MYSQLOPTS ${TDB}"

```

## 查看错误代码

```

mysql> \! perror 6
OS error code   6:  No such device or address

```

### ERROR 1153 (08S01) at line 3168: Got a packet bigger than 'max_allowed_packet' bytes

```
max_allowed_packet=500M

```

### ERROR 1129 (00000): Host 'XXXXXX' is blocked because of many connection errors; unblock with 'mysqladmin flush-hosts'

连接在中途被中断了的连接请求。在 max_connect_errors 次失败请求后，mysql 阻止该主机进一步的连接，直到管理员执行命令 mysqladmin flush-hosts。

```

mysql> flush hosts;

```

```
set global max_connect_errors=1000;

```

```
max_connect_errors=10000

```

## 临时表是否需要建索引

答案：要

## Kill 脚本

查询出锁定的表

SELECT concat('KILL ',id,';') FROM information_schema.processlist WHERE user='root';

SELECT concat('KILL ',id,';') FROM information_schema.processlist WHERE command='Locked' and user='root';

SELECT concat('KILL ',id,';') FROM information_schema.processlist WHERE command='Locked' and user='root' and db='test';

拼装 kill 命令后输入到 kill.sql, source 将从 kill.sql 读取 sql 命令并执行。

```
SELECT concat('KILL ',id,';') FROM information_schema.processlist WHERE user='root' INTO OUTFILE '/tmp/kill.sql';

source /tmp/kill.sql;

```

```
mysqladmin -uroot -p processlist | grep Sleep |awk '{if (length($2) > 1) print "Kill "$2}'|xargs mysqladmin -uroot kill

```

## ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function

[`dev.mysql.com/doc/refman/5.1/en/partitioning-limitations-partitioning-keys-unique-keys.html`](http://dev.mysql.com/doc/refman/5.1/en/partitioning-limitations-partitioning-keys-unique-keys.html)

## ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.

这个错误来自 MySQL 5.7，首次登陆 MySQL 5.7 必须修改密码

```
ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_password';		

```

## ERROR 1819 (HY000): Your password does not satisfy the current policy requirements

MySQL 5.7 密码强度，必须含有 0-9，a-z,A-Z 以及“-”或“_”

https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html

禁用密码安全策略（早起 5.7 版本可用，新版已经废弃这个选项）

```
#  cat /etc/my.cnf | grep validate-password
validate-password=OFF

```

新的方式修改策略与密码长度

```

mysql> set global validate_password_policy=0;
mysql> set global validate_password_length=4;
mysql> grant all privileges on test.* to 'test'@localhost  identified by 'chen';

```

## 重新整理 AUTO_INCREMENT 字段

AUTO_INCREMENT 并非按照我们意愿，顺序排列，经常会跳过一些数字，例如当插入失败的时候，再次插入会使用新的值。有时会造成浪费，我们可以使用下面 SQL 重新编排 AUTO_INCREMENT 序列。

```
SET @newid=0;
UPDATE mytable SET id = (SELECT @newid:=@newid+ 1);

```

使用 max()查看最大值，然后使用 alter 修改起始位置。

```
select max(id) from mytable;
ALTER TABLE mytable AUTO_INCREMENT = 1000;		

```

注意外键，需要 ON UPDATE CASCADE 支持，否则无法更新。CONSTRAINT `FK_group_has_contact_contact` FOREIGN KEY (`contact_id`) REFERENCES `contact` (`id`) ON UPDATE CASCADE ON DELETE CASCADE,

```
CREATE TABLE `contact` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '唯一 ID',
	`name` VARCHAR(50) NOT NULL COMMENT '姓名',
	`mobile` VARBINARY(32) NULL DEFAULT NULL COMMENT '手机号码',
	`email` VARBINARY(50) NULL DEFAULT NULL COMMENT '电子邮件',
	`mobile_digest` VARCHAR(32) NULL DEFAULT NULL COMMENT '摘要',
	`email_digest` VARCHAR(32) NULL DEFAULT NULL COMMENT '邮件摘要',
	`birthday` DATE NULL DEFAULT NULL COMMENT '生日',
	`description` VARCHAR(255) NULL DEFAULT NULL COMMENT '备注描述',
	`status` ENUM('Subscription','Unsubscribe') NOT NULL DEFAULT 'Subscription' COMMENT '订阅状态',
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
	`mtime` TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
	PRIMARY KEY (`id`),
	UNIQUE INDEX `digest` (`mobile_digest`, `email_digest`)
)
COMMENT='会员手机短信与电子邮件映射表'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=43642;

CREATE TABLE `group` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(50) NOT NULL,
	`description` VARCHAR(512) NOT NULL,
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`),
	UNIQUE INDEX `name` (`name`)
)
COMMENT='短信分组'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=8;

CREATE TABLE `group_has_contact` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`group_id` INT(10) UNSIGNED NOT NULL,
	`contact_id` INT(10) UNSIGNED NOT NULL,
	`ctime` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`),
	UNIQUE INDEX `group_contact` (`group_id`, `contact_id`),
	INDEX `FK_group_has_contact_contact` (`contact_id`),
	CONSTRAINT `FK_group_has_contact_contact` FOREIGN KEY (`contact_id`) REFERENCES `contact` (`id`) ON UPDATE CASCADE ON DELETE CASCADE,
	CONSTRAINT `FK_group_has_contact_group` FOREIGN KEY (`group_id`) REFERENCES `group` (`id`) ON UPDATE CASCADE ON DELETE CASCADE
)
COMMENT='N:M'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=55764;

```

## 转换 latin1 到 UTF-8

```
UPDATE category SET 
    name=convert(cast(convert(name using  latin1) as binary) using utf8),
    description=convert(cast(convert(description using  latin1) as binary) using utf8)

```

## this is incompatible with sql_mode=only_full_group_by

ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'mydb.contact.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```

mysql> select @@version;
+-----------+
| @@version |
+-----------+
| 5.7.10    |
+-----------+
1 row in set (0.00 sec)

mysql> select @@GLOBAL.sql_mode;
+-------------------------------------------------------------------------------------------------------------------------------------------+
| @@GLOBAL.sql_mode                                                                                                                         |
+-------------------------------------------------------------------------------------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
+-------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SET sql_mode = '';
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> select id,name from contact group by name limit 10;
+-------+-------------+
| id    | name        |
+-------+-------------+
| 84046 |   张伟      |
| 80259 |   张磊      |
|   784 |   王岩      |
| 87685 |  杨钞       |
+-------+-------------+
10 rows in set (0.07 sec)

```

不建议设置 SET sql_mode = ''，正确方式如下：

```

mysql> set global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
mysql> set session sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';		

```

或者采用

```

Adding only one mode to sql_mode without removing existing ones:

SET sql_mode=(SELECT CONCAT(@@sql_mode,',<mode_to_add>'));
Removing only a specific mode from sql_mode without removing others:

SET sql_mode=(SELECT REPLACE(@@sql_mode,'<mode_to_remove>',''));
In your case, if you want to remove only ONLY_FULL_GROUP_BY mode, then use below command:

SET sql_mode=(SELECT REPLACE(@@sql_mode, 'ONLY_FULL_GROUP_BY', ''));		

```

## [Warning] Changed limits: max_open_files: 5000 (requested 20480)

```

2018-01-08T01:34:44.515973Z 0 [Warning] Changed limits: max_open_files: 5000 (requested 10240)
2018-01-08T01:34:44.516402Z 0 [Warning] Changed limits: table_open_cache: 1471 (requested 2000)		

```

提出出现在 CentOS 7 ulimit 配置没有问题的情况下 mysql 日志提示 Warning

```
# ulimit -Sa | grep "open files"
open files                      (-n) 40960		

```

```
[root@netkiller ~]# cat /proc/`pidof mysqld`/limits
Limit                     Soft Limit           Hard Limit           Units     
Max cpu time              unlimited            unlimited            seconds   
Max file size             unlimited            unlimited            bytes     
Max data size             unlimited            unlimited            bytes     
Max stack size            8388608              unlimited            bytes     
Max core file size        0                    unlimited            bytes     
Max resident set          unlimited            unlimited            bytes     
Max processes             63494                63494                processes 
Max open files            5000                 5000                 files     
Max locked memory         65536                65536                bytes     
Max address space         unlimited            unlimited            bytes     
Max file locks            unlimited            unlimited            locks     
Max pending signals       63494                63494                signals   
Max msgqueue size         819200               819200               bytes     
Max nice priority         0                    0                    
Max realtime priority     0                    0                    
Max realtime timeout      unlimited            unlimited            us        

```

动态改变

```
[root@netkiller ~]# egrep '^(Limit|Max open files)' /proc/`pidof mysqld`/limits
Limit                     Soft Limit           Hard Limit           Units     
Max open files            5000                 5000                 files  

```

问题的出现出现原因是 systemctl 启动脚本覆盖了 ulimit 配置

```
# cat /usr/lib/systemd/system/mysqld.service | grep -A2 open_files_limit
# Sets open_files_limit
LimitNOFILE = 5000

```

解决方法，直接修改上面的数值，不建议修改 mysqld.service，这样会影响你下次升级。请采用下面的方案完美解决：

```

mkdir /usr/lib/systemd/system/mysqld.service.d

cat >> /usr/lib/systemd/system/mysqld.service.d/override.conf <<EOF
[Service]
LimitNOFILE=40960
EOF

```

重启 MySQL

```
systemctl daemon-reload
systemctl restart mysqld

```

检查是否生效

```

mysql> show variables like 'open_files_limit';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| open_files_limit | 65535 |
+------------------+-------+
1 row in set (0.01 sec)		

```

## ERROR 1364: 1364: Field 'id' doesn't have a default value

```

set @@SESSION.sql_mode='NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
SELECT @@GLOBAL.sql_mode;
UPDATE `cms`.`content` SET `source`='test' WHERE `content_id`='1099';		

```

## ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement

MySQL 不允许向 secure_file_priv 意外的目录导出文件。

```

mysql> SELECT * FROM `order` INTO OUTFILE '/tmp/order.txt';
ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement

mysql> show variables like '%secure%';
+--------------------------+-----------------------+
| Variable_name            | Value                 |
+--------------------------+-----------------------+
| require_secure_transport | OFF                   |
| secure_auth              | ON                    |
| secure_file_priv         | /var/lib/mysql-files/ |
+--------------------------+-----------------------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM `order` INTO OUTFILE '/var/lib/mysql-files/order.txt';
Query OK, 3 rows affected (0.00 sec)

root@netkiller ~ % cat /var/lib/mysql-files/order.txt
1	Tom	22	2017-11-16 17:23:15
2	Neo	34.65	2017-11-16 17:29:28
3	Cici	34.98	2017-11-16 17:30:29

```

在 my.cnf 中 加入 secure-file-priv=/tmp 可以修改为你需要的目录。

## ERROR 1086 (HY000): File '/var/lib/mysql-files/order.txt' already exists

SELECT * FROM tabname INTO OUTFILE 不支持覆盖操作，这是 MySQL 从安全角度考虑的。

```

mysql> SELECT * FROM `order` INTO OUTFILE '/var/lib/mysql-files/order.txt';
ERROR 1086 (HY000): File '/var/lib/mysql-files/order.txt' already exists		

```

## ERROR 1415: Not allowed to return a result set from a trigger

触发器中不允许返回结果集，解决方法是顶一个变量，然后将返回值返回给变量。

```

DROP TRIGGER IF EXISTS `test`.`demo_AFTER_INSERT`;

DELIMITER $$
USE `test`$$
CREATE DEFINER=`root`@`%` TRIGGER `test`.`demo_AFTER_INSERT` AFTER INSERT ON `demo` FOR EACH ROW
BEGIN
	set @rev = "";
	SELECT 
    OUT2FILE('/tmp/demo.log',
            CONCAT_WS(',',
                    NEW.id,
                    NEW.name,
                    NEW.sex,
                    NEW.address))
	INTO @rev;
END$$
DELIMITER ;		

```

## Authentication plugin 'caching_sha2_password' cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such fileor directory

这个故障出现在 MySQL 8.0 上，用户使用 mysql client 5.7 链接 MySQL 8.0 提示如下

```

[root@netkiller ~]# mysql -h 193.112.95.53 -uroot -p
Enter password:
ERROR 2059 (HY000): Authentication plugin 'caching_sha2_password' cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such fileor directory

```

解决方案，创建用户使用 mysql_native_password 密码

```

mysql> CREATE USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'pMQiEge1ikst7S_6tlXzBOmt_4b';
Query OK, 0 rows affected (0.08 sec)

mysql> grant all on *.* to 'root'@'%';
Query OK, 0 rows affected (0.08 sec)

```

重新链接

```

[root@netkiller ~]# mysql -h 193.112.95.53 -uneo -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 24
Server version: 8.0.11 MySQL Community Server - GPL

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>

```

## com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed

问题出在现在 MySQL 8.0 版本

解决方法：在连接后面添加 allowPublicKeyRetrieval=true

```

spring.datasource.url=jdbc:mysql://192.168.0.1:3306/test?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC&useSSL=false&allowPublicKeyRetrieval=true

```